# 1.2 クラスを理解する

* コンストラクタ呼び出しのよくある勘違いに、「同じ引数のスーパークラスのコンストラクタが呼び出される」というものがあるが、これは間違いで、常に引数を持たないスーパークラスが呼び出される。そしてそれはコンストラクタ呼び出しが省略された時にそういう挙動をする、ということ。つまりスーパークラスに引数を持たないコンストラクタが存在しない場合は、`super` 構文で呼び出すコンストラクタを指定しないとエラーになる。
* ユーティリティメソッドは本来引数のインスタンスが持つべき処理の可能性が高い
* `default` メソッドを持つインターフェースと抽象クラスとの違い
* イミュータブルなクラスの作り方と使いかた
* コンストラクタからインスタンスメソッドは呼べるが推奨しない。どうしてもそうしたいシチュエーションではメソッドを `private` や `final` にする事を検討する

パーフェクトJava と Effective Java みたいな感じの章。

# 1.3 例外の取り扱い

* Java7 から `ReflectiveOperationException`が追加され、リフレクションする時の例外はスーパークラスでシンプルに受けることもできるようになった
* Java8 から `UncheckedIOException` が追加され、非チェック例外のラップが簡単になった
* 例外処理は個別に考える必要がある
* 例外の握りつぶしは最悪の手
* 例外情報を欠落させないようにすること
	* 例外を再スローするときは、原因例外が失われないようにする
	* 難しい時はせめてその箇所でログ出力する
* 呼び出し元にその例外処理が行える例外オブジェクトを送出すること

# 1.4 Java 標準ライブラリの勘どころ

## String 関係

* `equals()` メソッドで `null` チェックをしなくとも、Java7 からは `java.util.Objects#equals()` を使えばよい
* 文字列の連結は、基本 `StringBuilder`、定数やリテラルは `+` 演算子、区切り文字付きは `join()` を使う。`concat()` は殆ど使わない
* 値クラスと呼ばれる、Map のキーになるようなクラスは、イミュータブルかつ `equals()`, `hashCode()` メソッドが正しく実装されていることが安全に使用する条件

## 数値・ラッパークラス関係

* アンボクシングは、常に `NullPointerException` が発生しうる危険な処理と認識しておく
* ラッパークラスを戻り値とするメソッドを呼び出す場合は、戻り値をプリミティブ型で受けるのは避ける
* Java8 で `Optional` が追加された。今まで `null` を返すようなメソッドを作成していた場合は、 `Optional` クラスのインスタンスを返すようにする
* `Integer#getValue()` で値を返さない意味で `null` を返していたケースでは、`OptionalInt` を使うこともできる

## BigDeciamal 関係

* `BigDecimal` クラスはイミュータブルなので、`add()` してもそのインスタンスそのものは変わらない。戻り値を使うことを忘れない。CheckStyle や FindBugs でも検出可能。
* `BigDecimal` クラスはファクトリメソッドや名前付き定数を使用する。このクラスは値のみに意味があり、かつイミ`ュータブルなのでインスタンスの違いに意味は無い。そのため毎回インスタンスを生成する必要はない。static ファクトリメソッドを使うことで、余計なインスタンス生成が行われず、パフォーマンスの劣化をふせぐことができる
* `BigDecimal` クラスの比較には、`equals()` ではなく `compareTo()` を使う。スケールも同値性の対象であるため。
* 丸めモードは、`enum` で指定する。`int` で指定する方は `enum` 導入前の古いメソッドで、分かりづらい。

## 日付関係

* `Date` クラスや `Calendar` クラスは、ミュータブル。そのためフィールドや引数で扱われるといつ状態が変化するかわからない。少なくとも、引数として受け取った場合は変化させないこと、保持するフィールドの値を返す時は防御的コピーを行うことを検討する
* `Date` や `Calendar` クラスは、日付だけでなくミリ秒までを保持する。比較をする際に日付と誤認して比較して舞う間違いはよくある。日付の比較をしたい時は、日付部分のみを取り出したり、時以下をすべて 0 にしてから比較するなどの対応が必要で、よくある問題として広く認識されている。
* `SimpleDateFormat` クラスはスレッドセーフでない。フィールドとしてはならない。素直にスレッドごと（メソッド内）でインスタンスを生成する。

## コレクション関係

* 空のリストを返したい場合は、`ArrayList` のインスタンスを返すのではなく、`Collections#emptyList()` を使う
* 同様に、1つの要素のみのコレクションを返したい場合は、`Collections#singletonMap()` や `Collections#singletonList()` を使う
* `Collections#sort()` は引数のリストそのものを変更してしまうこと（破壊的なメソッド）に注意する
* `unmodiffiableList()` は、元となったコレクションや含まれる要素自体への変更は可能なことに注意する
* コレクションの有無を確認するのに、`size()` を使って確認するより、`isEmpty()` を使う
* ただ、全件処理した方が効率的。その場合は拡張 for 文を使う。Iterator を使うシチュエーションは、ループ中に要素の削除を行ったり、複数のコレクションを同時にループさせたいとき。
* Java7 までは上記の判断基準だったが、Java8 からラムダ式と Stream API が出来たので、基本的には `forEach()` メソッドを使ってラムダ式で処理することで、今まで多重ループで処理していたようなものがおどろくほど簡単に記述できるようになる

この章は細かいところで効いてくる tips や知ってて損はないことばかりなので、折を見て見返したい章。

# 1.5 実践的 Java プログラミングのポイント

## 比較

* 演算子による比較はプリミティブ型の比較がほとんど。参照型は `null` 及び `enum` 同士の比較くらいしか使わない
* `equals()` メソッドをオーバーライドする時は、反射性、対称性、推移性、一貫性と、`null` に対しては常に `false` を返すという汎用規約に従う必要があり、`HashMap` や `HashSet` はこれらを前提にして実装されている
* `equals()` メソッドや `hashCode()` メソッドは自分で実装せず、IDE や Lombok を使う
* Java7 から導入された `Objects#hash()` なども確認する

## 名前付け

* 基本的には現場のコーディング規約、Java の基本的なコーディングイディオム（ループカウンタ `i` など）に従うこと
* 変数名の長さはスコープの長さに比例させる

## コンパイラや IDE などの警告を理解する

* わからない警告が出た時こそ理解を深めるチャンス

## デザインパターン
* 自分で設計するときも役立つが、既存のプログラムを解析するときなどもパターンに照らし合わせることで全体の把握が容易になることもある

## JavaDoc

* JavaDoc タグも調べてみるとよい

## ガベージコレクション

* `static` フィールドはクラスオブジェクトが破棄されるまで回収されない
* クラスオブジェクトの生成と破棄について知るには、クラスローダーを調べるとよい
* シングルトンのインスタンスフィールドも同様
* ガベージコレクションのアルゴリズムと実装を読んでみると良い

## 入出力ストリーム

### 問題になりやすいもの

* 実装が煩雑になりやすい
* クローズ漏れによるメモリリーク
* 低パフォーマンス
* 文字コードの扱いが開発環境と検証環境、本番環境で異なる場合

### 一部解決できるもの

* `AutoCloseable` と `try-with-resources` 構文
* NIO.2
* できるだけ Java7 以降の情報を収集すること

## マルチスレッド

* `synchronized` キーワード付けるだけでも、`java.util.concurrent` パッケージのクラスを使えば大丈夫なわけではないことを肝に銘じる
* スレッドセーフなクラスを使っても、使用する側がスレッドセーフに作られていなければ意味が無い
* 従来は `Thread` クラスを使っていたが、 `Executor` インタフェースの導入以降は `Thread` クラスを直接使うことはなくなっている
* Java8 の Stream API の導入によりさらにスレッドを扱う機会は表面上減るはず。ただ、不要になるわけではなく、重要度は増している。逃れることはできない。
* イミュータブルにクラスを設計するなど、状態を制御可能なようにシンプルに設計するトレーニングは必ず役に立つ

## まとめ

* Java を使うプロダクトは、長期間運用することが多く、ただ動いただけでは不十分で、安定した物を作る必要があり、それには知識が必要。
* 知識をみにつけるには、自分の書いたコードを説明できるようになること。「おまじない」はダメ。

# 2.1 内部イテレーション事始め

* 従来の for ループを使ったイテレーションは外部イテレーション
* ループ処理を実装者が自ら行う
* fork/join フレームワークを使うと並列処理ができるが、かなり労力がいるし、変更が大変
* 内部イテレーションという関数型プログラミング由来の考え方
* こうすることで、イテレーション処理の実装をライブラリ側に任せることができ、実装者は条件だけを記述すれば良いことになり、ループだけでなく並列処理もライブラリに任せることができる
* `java.util.function.Consumer` インタフェースは `accept()` というメソッドが提議されている関数型インターフェースで、与えられた要素全てに `accept()` を適用していく
* `java.util.function.Predicate` インタフェースは、`test()` というメソッドが提議されている関数型インターフェースで、与えられた値に対して真偽値を返す

Java で内部イテレーションを記述すると、匿名クラスを使うことになるが、記述性や可読性に欠ける。これを解決するのに、Java8 でラムダ式が導入された。

# 2.2 「縦の問題」を解決するラムダ式

* 抽象メソッドが1つ提議されているインタフェースを関数型インタフェースと呼ぶ
* 関数型インターフェースを実装してインスタンスを生成する構文として、ラムダ式が導入された
* ラムダ式を使うと、型を書く必要がなくなるので `import` 文がなくなる。つまりコンパイラはラムダ式を発見すると、周辺の上っ今日に基づき実装するべき関数型インターフェースの型を推論する
* ラムダ式は更に、引数の型もコンパイラの推論に任せて省略でき、引数が1つの場合は括弧も省略できる
* ラムダ式の本体が値を返すときも、返す値が1つの式で表せる場合は、`return` などを省略できる。
* ラムダ式と匿名クラスの違いは、スコープの扱い。匿名クラスでは、`this` は匿名クラス自身を参照していたが、ラムダ式ではそうではなく、エンクロージングクラスを参照する。そのため既に宣言されているローカル変数と同名のローカル変数は宣言できない
* ラムダ式と同様に関数型インターフェースを実装してインスタンスを生成する構文として、メソッド参照とコンストラクタ参照が追加されている
* クラス名::メソッド名という形式のメソッド参照も記述できるが、この場合はレシーバ（メソッド呼び出し元）のインスタンスを第1引数に受け取るメソッドを持つ関数型インタフェースが予期（外側がそうなっていないとだめ）されないといけない

# 2.3 Stream API を使いこなすために

* Stream API は 内部イテレーションのライブラリ
* 以下の4つのインターフェースを主として構成されている
	* `java.util.stream.Stream<T>`
	* `java.util.stream.IntStream`
	* `java.util.stream.LongStream`
	* `java.util.stream.DoubleStream`
* java.io の `InputStream` や `OutputStream` とは関係ない別物
* ラッパークラスのストリーム `Stream<Integer>` などをつかうこともできるが、オートボクシングが度々発生し性能上の問題が発生するので、プリミティブ型用のストリームを使うべき

## ストリームの処理の流れ

* コレクションなどのデータソースから生成され、変換やフィルタリングなどの中間操作を繰り返し、最後に順次処理や集約などの終端操作で処理を確定させる
* 中間操作が呼び出された時点では操作が実行されずに遅延評価となることが特徴

## Stream 生成、中間操作、終端操作

* JavaDoc 参照

## 処理の逐次実行と並列実行

* 逐次実行は `sequence()`、並列実行は `parallel()`
* 並列実行は分割統治法が用いられ、データ列を複数に分けてデータ列ごとに別スレッドで処理を行い、最後にそれぞれを統合して1つの結果にする
* 並列実行で正常に実行できるのは、ある条件を満たすときのみ
	* 操作の実行中にデータソースを変更しない
		* Iterator で他から要素の変更をできないのと一緒
* 副作用がない（ステートレス）
	* 呼び出しの順序が守られないので、副作用により呼び出しの順序に依存している場合は結果が異なってしまう
	* 外部の変数を参照している場合は並列実行時に複数のスレッドから同時に外部の変数が参照される可能性があるので、適切な同期処理が必要。適切な同期処理は難しいので避ける。大抵の場合は副作用を排除できるので、そうすべき
* 操作が結合法則を満たす
	* `(A + B) + C` でも、`A + (B + C))` でも結果が同じようにならなければならない
	* 加算は結合法則を満たす。減算は結合法則を満たさない。

## 並列で実行できる時の注意点

* 逐次実行の時よりも遅くなってしまうことがある
* 行う操作や処理するデータ数によるので一概には言えない。
* 処理時間を計測して、並列実行時に速くなっているかを確認すべき

# 3 現場で役立つ Java EE

全体的に概要にとどまっていてこれだけだとアプリ作れるようにはならないので、金魚本読むとかが必要。

* 歴史と Java EE 要素技術とバージョン
* アプリケーションサーバとバージョン
* 参照実装の一覧

は良かった。

* JSF
* JPA
* EJB
* CDI

この辺りを使ったアプリを実際に組んでみる必要がありそう。

