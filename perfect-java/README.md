# Java言語

## 概論

### Java言語の特徴

* オブジェクト指向を意識した設計なので、言語の流儀や慣習に素直に従うと、オブジェクト指向の考え方に沿った書き方のプログラムになる
* 強い型付け
* JVMの簡単な概要
* 構文
    * マルチスレッドと例外を構文として提供している点
* 自動メモリ管理
    * GCの仕組みを持つ
* デザインパターン
    * Javaの標準クラスライブラリはデザインパターンを活用しているので、標準クラスライブラリを読めばプログラミングのベストプラクティスを学ぶことができる
* インターネットを想定した言語
    * プログラムの安全性を言語仕様に組み込んだ点

### オブジェクト指向の捉え方

分割統治の考え方。
データ構造とプログラムのフラットな関係 -> 構造体とサブルーチンの関係 -> データと手続きのカプセル化 -> クラスの責務と分割統治。
独立性（直行性）と機能、役割の局所性、凝集度など。

## 文字と文字列

### 文字列クラス

* 文字列は内部的には文字の配列、ただし抽象化されてるので、Javaでは文字列オブジェクトとして扱う
* StringクラスのオブジェクトはImmutable
* IndexOutOfBoundsException や StringIndexOutOfBoundsException はコードのバグなので例外を補足するのではなくコードを修正する
* new String("0123456789")は文字列リテラルで1つ、new で1つオブジェクトが生成されるのでムダ
* 文字列リテラル同士の+結合はいくら結合してもコンパイル時に最適化される
* String#concatはImmutableな性質から新しくオブジェクトを生成して返すので、ループの中で呼び出す場合は量によってはコストが高い処理になる→StringBuilderを使うこと。
* 文字列結合する場合は、文字列リテラル同士の += 演算子以外は StringBuilder#append()を使うようにしないと、大量のループで結合を行った際に処理時間に大きな違いが出る。

### 文字列比較

* == 演算子はオブジェクトの同一性を比較する。文字列の内容を比較するにはeqauls()メソッドを使う。
* 文字列リテラル同士の比較は同じ文字列リテラルは同一のオブジェクトとして最適化されるので、 == 演算子でも true が得られるが、たまたま真になると考えるべき。この動作に依存するコードは書かないようにする。
* StringBuilderの同値比較は、StringBuilder.toString().contentEquals(StringBuilder) を使う。

### 数値から文字列への変換

* String#valueOf({Type})メソッドを使う。valueOfメソッドの中で、ラッパークラスのtoStringメソッドを呼んでいるので、直接ラッパークラス#toStringメソッドを呼ぶほうが少しだけ効率的。ただし些細な差なので、気にする程でもない。
* 内部表現への変換は、toHexString(),toBinaryString()を使う。

### 文字列から数値への変換

* 利用者からの入力文字列を内部的な数値に変換するため、注意を要する。
* valueOf系メソッドとparse系メソッドは、parse系のメソッドのほうがほんの僅か効率がいいので、parse系メソッドを使う。
    * valueOfは内部的にparseIntした値に対して、-128〜127の値はキャッシュされたIntegerオブジェクトを返すが、それ以外はnew Integerして返す。
    * parseIntはintに直接変換して返す。

### 文字

* Javaプログラミングの理想は、文字列を意識して、文字を意識しないこと。
* char型の配列で文字列を扱うことはできるが、Javaの思想に反する。
* 効率性に問題がない限り、文字単位の処理は避け、文字列としての処理を意識する。
* 実行速度が問題になる場合は、文字を直接扱う。理想を追いすぎて、遅いコードを書かないようにする。
    * 文字単位で処理する場合は、クラスやメソッドに隠蔽するようにする。
* 文字列から文字の配列として取り出すときは、toCharArray()を使う。
    * toCharArrayは内部的にgetCharsメソッドを使っている。
* StringBuilderから文字の配列を取り出すときは、toCharArray()がないので、直接getCharsを使う。
* 文字の配列からStringオブジェクトを生成するには、文字の配列を引数に渡してStringオブジェクトを生成する。
    * 内部的に配列をコピーするので、元の配列を変更してもStringオブジェクトには影響しない。
* 文字の配列からStringBuilderオブジェクトを生成するには、appendメソッドに文字の配列を渡す。

### バイトと文字

* Javaの前提はバイトと文字を同一視しないこと。Java以外の世界では、バイトと文字を同一視する世界が多いため、Javaではバイトと文字を相互に変換する必要がある。
* ASCIIコードは7ビット長で英数字や記号を表現する。7ビット長なので1バイトに収まる。7ビットだと1ビットあまるので、先頭ビットを0にして8ビット長で扱う。
    * 慣習的に1バイト文字と呼ぶ
* Unicodeは16ビット長だが、最初の128文字はASCIIコードと同じ文字になっている。
    * 'a'は16進数で、0x61
    * 2進数では01100001
    * 先頭8ビットをゼロにした0000000001100001がUnicodeで文字'a'を表す。リテラル表記を使うと、u0061
* Unicodeで表現した英文字は1バイトを単純に切り落とすだけでASCIIコードになる

## 数値（1）

### どの整数型を使うべきか

* byte, char型
    * バイト及び文字としての意味に限定して使う。ループ変数として小さい範囲の数値でもintを使うべき。（実行効率がintよりも悪くなることもある）
* short,int,long型
    * どれでもいいなら、intを使う。
    * int型変数の読み書きはアトミックであることをJavaの言語仕様は保証している。
    * long型を使うのは、int型では長さが足りないときに使う。32ビットCPUでは64ビット長のlong型を濫用すると実行効率が落ちる危険がある。
    * short型は使う場面があまりない。使うとすれば、16ビット長に意味がある場合。（例えばTCP/IPのポート番号など）ハードウェアリソースの節約という意味においては現代では意味が無いどころか性能低下する可能性もある。

### 桁あふれ

* 符号ありの型で扱える範囲の正の最大値に対して1を足すと、負の最大値になる。
    * 2147483647 + 1 = -2147483648（不連続になる点）
* 符号なしの型の場合は、0になる。
* これらを踏まえて加算、減算をしないと、バグの温床になる。

### リテラル表記

* 型で表現できる範囲を超えたリテラル記述はコンパイルエラーになる。
* ソースコード上、どんな基数で整数のリテラル値を書こうと、値が等価であれば実行時にこれらの区別はない。
    * 10,012,0xa は全て同じ値。

### 文字と数値の相互変換

* 文字から数値に変換するには、Character#digit(value, radix)を使う。
    * int n = Character.digit('f', 16);
* 数値から文字に変換するには、Character#forDigit(num, radix)を使う
    * char c = Character.forDigit(10, 16); // -> 0x61

### 整数四則演算の留意点

* 大きな正の整数の和の桁あふれ
* 小さな負（絶対値の大きな負数）の整数の差の桁あふれ
* 絶対値の大きな整数同士の積の桁あふれ
* 割算（商）の結果が切り捨てになる点
* 数値0（ゼロ）による割算が実行時例外java.lang.ArithmeticExceptionを発生する点

桁あふれの境界値の算術演算でバグのないコードを書くことは職人芸の世界なので、適切な数値ライブラリを利用する。
ゼロによる割り算で発生する例外を補足して無視することはしない。ゼロによる割り算はバグ。ゼロでないことをチェックすべき。

### 剰余

* 乱数に対して10の剰余を計算し剰余が3より小さい時、という条件で30%の発生確率を実現できる。
* 与えられた集合をN分割（Nは整数）したいときにNの剰余を使うなど、剰余演算子は使い道の広い演算子。
* java.lang.ArithmeticExceptionは発生するので、非ゼロかどうかのチェックは行うこと。

### インクリメントとデクリメント

* 評価値と評価回数の違いを無視すると、加減算演算子の省略記法。同様に桁あふれに注意する。
* コードの意図が明確になるので、積極的に使う。

### 整数の型変換

* ダウンキャストして範囲に収まらない値で縮小変換すると、単純にビットが切り捨てられるので、想定と違う結果を返すことがある。原理的には桁あふれと似ている。
* メソッドやコンストラクタ呼び出しの引数についても、型変換が発生する。
* char型は常に符号が正であるため、char型からbyte型、short型との変換には明確な序列がないので常にキャストが必要になる。
* 負の数からchar型で符号反転するコードは殆どの場合想定外の結果になるので、バグの温床。

### 演算時の型変換（昇格）

* 整数に対する算術演算で、狭い型の値を広い型に拡大変換してから演算する仕組みのこと。
* 演算の結果、拡大変換された場合、代入先が狭い型で縮小変換が必要になるため、キャストしなければコンパイルエラーになる。
* 昇格は不便に見えるが、正しい値を得られるメリットがある。

### 特別な型変換

* int型リテラル値を他の整数型の変数に代入するとき、値の範囲が代入先の方が扱える範囲に収まっていれば、縮小変換にも関わらずキャストなしで代入可能。
* ただし、long型リテラル値の場合はコンパイルエラーになる。

### ブーリアン（真偽値）

* true, false はリテラル
* フラグ変数は無駄なことが多い（そのままリテラルをreturnすれば済むコードは多い）
    * 昔のCOBOLなどの名残でわざわざフラグ変数にtrue, false を入れるコードをよく見かけるが、無駄。
    * 未初期化のローカル変数が残るのも良くない
* フラグ変数が多い場合、メソッドが長すぎることを疑うべき。フラグ変数を使った条件分岐がだらだらと続くコードは典型。
* ド・モルガンの法則を使って、否定演算式を入ったコードを書き換えたり、if節ではなくelse節にやりたいことを書くようにすると、わかりやすくなる。

```
#!java

if (!Character.isDigit(c) && !Character.isLetter(c)) {
    System.out.println("any simbol?");
}
```

```
#!java

// ド・モルガンの法則を使って書き換え
if (!(Character.isDigit(c) || Character.isLetter(c))) {
    System.out.println("any simbol?");
}
```

```
#!java

// 否定演算子をなくす書き換え
// c が数字（digit）または英字（Letter）なら何もしない。それ以外なら出力。
if (Character.isDigit(c) || Character.isLetter(c)) {
    ; // through
} else {
    System.out.println("any simbol?");

}
```

## 変数とオブジェクト

### 参照型変数と基本型変数の代入の概念モデルを分けて考える理由

参照型の変数の代入時は、基本型の変数と同じように“参照値（ポインタ）”のコピーが行われる。ただし、Javaには参照値自体を加算する演算がないので、概念として分けて考えた方が良い。

### 変数の型とオブジェクトの型

* 変数の型は、その変数が参照するオブジェクトに対してどんな操作ができるかを確定する。（振る舞いの確定）
* オブジェクトの型は、呼ばれた先の動作を確定する。（実装の確定）

### 変数のスコープ

* ローカル変数とインスタンスフィールド変数が同じ名前で使用されている場合、ローカル変数の方が優先される。
* 明示的にthisを付けてインスタンスフィールド変数を参照できるが、thisの濫用は継承関係にあるクラス間のリファクタリングをしにくくする面もあるため、注意して使う。（ローカル変数とインスタンスフィールド変数のスコープが被っている時のみ使う、とか
    * 上位クラスにインスタンスフィールド変数を移したりすると、サブクラスからthisを付けて参照しているのにスーパークラスを参照しにいく、など
    * superは、上位クラスを参照するキーワードだが、実際には名前解決の対象を自身のフィールドまたはメソッドを対象外とするだけ。

### オブジェクトの寿命

* 参照が外れた時、ガベージコレクションの対象になる。いつ破棄されるかは、ガベージコレクションの内部動作に依存するので、開発者は参照のなくなったオブジェクトのその後を気にする必要はない。

### final変数と不変オブジェクト

* final変数の厳密な意味は「**再代入不可**」の変数。
    * final変数が基本型の場合は変更不可の意味と等価だが、final変数が参照型の場合は、変数が参照するオブジェクト自体の変更は可能。
* 参照先オブジェクトそのものの変更を禁止するには、不変オブジェクトを使う。
    * 不変オブジェクトの一つの例がStringクラス。

### 堅牢なプログラムのための工夫

* 変数は宣言と同時に初期化する（無理のない範囲で）
* 変数を使い回さない（再代入は避ける）
* 変数のスコープを小さくする
* オブジェクトの寿命を意識する
* 不変オブジェクトを活用する

## クラス

### Javaの型

* Javaでは、変数の型とオブジェクトの型と一致させないことにより多態性を実現できる

### オブジェクトを生成する手段

* new式による明示的な生成
* Stringリテラル表記および結合演算式による暗黙の生成
* オートボクシングによる暗黙の生成
* リフレクションによる生成
* Objectクラスのcloneメソッドによる複製

### オブジェクトのライフサイクル管理

* 変数のスコープに注意して、不要に長い寿命を持つオブジェクトをなくす
* オブジェクトの寿命を意識して、寿命の短いオブジェクトと寿命の長いオブジェクトを分離する
* ファクトリパターンやDIなど、オブジェクト生成に着目した技法を活用する
* オブジェクトのライフサイクル管理をフレームワークなどの階層に隠蔽する

などの技法がある。

### ファクトリパターン

基本的な考え方としては、オブジェクト生成を1つの役割とみなして、その機能を分離すること。

```
#!java

class My {
	private My {}
	static My getInstance() {
		My my = new My();
		return my;
	}
}
// 呼び出し側
My my = My.getInstance();
```

ファクトリメソッドには、次の利点がある。ファクトリメソッドを提供する場合、コンストラクタのアクセス制御をpublicにすべきではない。コンストラクタを外部から直接呼ぶ手段を禁止し、APIドキュメントに、オブジェクトの生成方法を明記する。

* コンストラクタと異なり、自由にメソッド名をつけられるので、生成のために意味のある名前を付けられる
* ファクトリメソッドは、必ずしも新規のオブジェクトを生成して返す実装にする必要はない
    * 生成済みオブジェクトをプーリング（キャッシュ）して、ファクトリメソッドがプール内のオブジェクトを返すオブジェクトプーリング（オブジェクトキャッシング）が可能
    * シングルトンパターン（オブジェクトの数を1つに制限する技法）が使える。ファクトリメソッドが常に同じオブジェクトを返す実装をする。
* ファクトリメソッドの戻り値の型を抽象型にできる
    * 具象クラスへの依存をファクトリクラスだけに限定でき、呼び出し側のクラスは依存を減らせるので堅牢なコードになる（変更に強い）

### ユーティリティクラス

オブジェクトを生成せずに直接使う。例えばjava.lang.Mathクラスのメソッドなどはユーティリティクラスのメソッド。
自分でユーティリティクラスを作成するときは、以下の方針を守る。

* コンストラクタをprivateにして、インスタンス化を禁止する。
* finalクラスにして、無用な継承を禁止する。
* すべてのメソッドとフィールドにstatic修飾子をつける

static修飾子をつけるのは、本質的に処理に状態を持つ必要がない場合で、これらはユーティリティクラスとして抽出できる。

### クラス

* クラスに使える修飾子

|修飾子|意味|
|------|----|
|public|publicにするとグローバルスコープ。書かないとパッケージスコープ。|
|final|継承による拡張を禁止|
|abstract|抽象クラス|
|strictfp|クラス内に記述した浮動小数点演算を厳密に評価|
|アノテーション|定義したアノテーションで挙動を制御する|

### フィールド

* フィールド宣言と同時にフィールド変数を初期化できる。明示的な初期化をしない場合、デフォルト初期値になる。

|型|デフォルト初期値|
|--|----------------|
|参照型|null|
|boolean|false|
|char|'\u0000|
|byte, short, int, long|0|
|float, double|+0.0|

* フィールド宣言と同時に変数を初期化するコードは、オブジェクト生成のタイミングで実行される。

```
#!java

public class My {
	public static void main(String[] args) throws Exception {
		My my1 = new My();
		System.out.println(my1.createdAt);
		Thread.sleep(1000);
		My my2 = new My();
		System.out.println(my2.createdAt);
	}
	long createdAt = System.currentTimeMillis(); // オブジェクト生成時に初期化される
}
```

### フィールド宣言の修飾子

|修飾子|意味|
|------|----|
|public|すべてのクラスから参照できる|
|protected|自身とサブクラスから参照できる|
|private|自身からしか参照できない|
|final|再代入を禁止|
|static|クラスフィールド|
|transient|シリアライズの対象外のフィールドとする|
|volatile|スレッド間で変数の値を同期する|

### 変数this

* ローカル変数とフィールド変数の名前が被る時は、フィールド変数にthisを付ける必要がある。変数のスコープの項を参照。

### メソッド

### メソッド宣言の修飾子

|修飾子|意味|
|------|----|
|public|すべてのクラスから呼び出せる|
|protected|自身とサブクラスから呼び出せる|
|private|自身のみ呼び出せる|
|abstract|抽象メソッド|
|final|オーバーライド不可|
|static|クラスメソッド|
|synchronized|同期のためのロック獲得|
|native|ネイティブメソッド|
|strictfp|浮動小数点演算を厳密に評価|

### メソッド引数（パラメータ変数）とローカル変数

* パラメータ変数とローカル変数は、メソッドが呼ばれた時にのみ変数として存在する。メソッドを抜けると、変数は消滅する。変数が存在することと、参照先のオブジェクトの存在は無関係であることに留意する。（独立して存在するのは変数）
* パラメータ変数とローカル変数がメソッド呼び出し毎に常に新規に存在し、メソッドを抜けると同時に消滅する動作を特に意識するのは、マルチスレッド動作と再帰呼び出しの時。

### メソッドのシグネチャ

あるクラスの中でメソッドを一意に区別するために必要な情報。

* メソッド名
* 引数の型の並び

引数名（仮引数名）はシグネチャに含まれない。

### 再帰呼び出し

* [コード例](../../commits/26d9803d2ffcd51fe533e2383b27d42a0311ad99)

再帰呼び出しとループ処理はどちらも本質的に繰り返し処理。
再帰処理は、入力値を列とみなして、先頭の要素と残りの要素に分けて考える。再帰メソッドは先頭要素があるかをチェックする。先頭要素がなければ何もしない。先頭要素があれば処理をする。残りの要素列（入力値から処理済み先頭要素を取り除いた列）を実引数として自分自身のメソッドを呼ぶ。
再帰呼び出しも停止するための条件判定が必要。これを停止条件と呼ぶ。無限な再帰呼び出しを書くと、StackOverflowError実行時例外が発生する。このバグは絶対に修正するバグ。
ループで書ける処理は必ず再帰処理で書ける。逆も真。多くの場合はループ処理で書くことを推奨するが、一部のアルゴリズムは再帰処理で書くとコードが簡潔になる。

### 可変長引数

内部的には配列として引数が渡る。可変長引数を使うコードのほうが記述が簡単になるケースがある。
原理上、可変長引数は最後の1つの引数にだけ使える。
```
#!java

void doit(int i, String... messages) // OK
void doit(int i, String... messages, String... m2) // コンパイルエラー
void doit(int i, String... messages, int i) // コンパイルエラー
```

### コンストラクタ

指定できる修飾子は以下。

* public
* protected
* private

コンストラクタ内から、フィールドアクセスやメソッド呼び出しができるが、これらは推奨しない。オブジェクト初期化処理の順序を意識しないと微妙なバグを生み出しやすいから。
コンストラクタには戻り値がない。厳密に言えば、new演算子を使った式の評価値がオブジェクトの参照値であって、コンストラクタ呼び出しの返り値が参照値というわけではない。

### コンストラクタの意義

コンストラクタを使うことで同じスタイルの初期化処理を強制できる。
```
#!java

// 悪い例
Book book = new Book();
book.initTitle("Peopleware");
book.initPrice(2310);
book.initAuthor("Demarco");
book.initTitle(DateFormat.getDateInstance(DateFormat.SHORT).parse("11/26/01"));
```
初期化に順序がある場合はさらに悪くなる。initとして分かるようにしていても未来の誰かにとってそれは自明ではなくなる。
順序があるなど暗黙の規則がある場合は、言語の機能やプログラミングの技法で強制すること。上記の例であればコンストラクタに順序も含めて初期化処理を隠蔽することで、クラスを使う側に初期化処理を強制できる。

また、オブジェクトの完全性を意識するプログラミングができることも利点。理想的なオブジェクトは生成時に完全な状態で生まれるべき。コンストラクタでオブジェクトを完全な状態に初期化できるように意識する。（ただし、初期化処理を遅延させることで有効な場合も存在する。SQLのリレーションがあるオブジェクトをO/Rマッピングする時など）

### this呼び出しとsuper呼び出し

コンストラクタのオーバーロードで、初期化するフィールドの値が違うコンストラクタを定義することができる。これを利用して、コンストラクタ内からほかのコンストラクタを呼び出すことで初期化の共通部分をまとめることができる。

* [コード例](../../commits/14fa2c4fd3e6e590539e5c1e45d734bda62554a3)

同様に、拡張継承したクラスの初期化の際に継承元のコンストラクタを呼び出し、拡張部分だけをサブクラスで初期化するようにして、初期化処理を共通化できる。

* [コード例](../../commits/1ccf5ccf39c12eb7acfb94d483e8d2c26f87dde0)

### デフォルトコンストラクタ

コンストラクタ宣言が1つもないクラスには、引数なしのコンストラクタが宣言されているとみなされる。暗黙にできる引数なしのコンストラクタをデフォルトコンストラクタと呼ぶ。
デフォルトコンストラクタのアクセス制御は、クラス自身のアクセス制御を引き継ぐ。暗黙のsuper呼び出しを含めると、次の3つのコードは同じになる。
```
#!java

// 以下の3つは同じ
class My { // デフォルトコンストラクタができる
}

class My {
    My() {}
}

class My {
    My() {
        super();
    }
}
```

デフォルトコンストラクタは、コンストラクタ宣言が1つもない場合のみに暗黙に作られる。1つでもコンストラクタを書き足すとデフォルトコンストラクタは消滅する。そのため、コンストラクタがなかったクラスに新しいコンストラクタを追加した途端、次のようなエラーを引き起こすことがある。
```
#!java

class My {

	private int num;
	// コンストラクタがなかったクラスに新しいコンストラクタを追加した途端...
	My(int num) {
		this.num = num;
	}

}

// 別の場所にある new My() の呼び出し箇所がコンパイルエラーもしくは実行時エラーになる
My my = new My();

// Myクラスを継承するクラスが引数のないコンストラクタに依存しているとコンパイルエラーもしくは実行時エラーになる
class Sub extends My {
	// デフォルトコンストラクタは暗黙に引数なしのMyのコンストラクタを呼ぶ
}

class Sub extends My {
	Sub() {}	// 暗黙に引数なしのMyのコンストラクタを呼ぶ
}

class Sub extends My {
	Sub(int num) {
		super();	// 明示的に引数なしのMyのコンストラクタを呼ぶ
	}
}
```

### 初期化ブロック（インスタンスイニシャライザ）

オブジェクトの初期化を行うための仕組みに初期化ブロックがある。
クラスの中に初期化ブロックを書くと、オブジェクトの初期化時に実行される。初期化ブロックはいくつでも書くことができる。複数の初期化ブロックはコードに書かれた順に実行される。
```
#!java

class My {
    int i;
    // 初期化ブロック
    {
        i = 5;
        System.out.println(i);
    }
}
```

初期化ブロックの役割はコンストラクタとほぼ同じ。初期化ブロックの用途は主に次の2つ。
* 全てのコンストラクタの共通処理を記述
* 匿名クラスの初期化のため（匿名クラスにはコンストラクタがないため）

### オブジェクト初期化処理の順序

オブジェクトの初期化時に走る処理は、次の順序で実行される。

1. フィールド変数にデフォルト値代入
2. フィールド宣言時の初期化および初期化ブロックをコードで上から書かれた順に実行
3. コンストラクタ呼び出し

```
#!java

// オブジェクト初期化時は、下記の数字の順に実行される。
class My {
    int i = 1;
    {
        System.out.println("2");
    }
    int j = 3;

    My() {
        System.out.println("6");
    }
    int k = 4;
    {
        System.out.println("5");
    }
}
```

### クラスフィールド、クラスメソッド

* クラスフィールドにオブジェクト参照を通じてアクセスするのではなく、クラス.フィールドのようにアクセスすること。
* クラスメソッドも同様だが、クラスフィールドよりも切実な理由として、クラスメソッドには多態性が機能しないことがある。

* インスタンスメンバ（インスタンスメソッド、フィールド変数の初期化子とインスタンスイニシャライザ）、コンストラクタ、クラスメソッドを除くと、クラスフィールド変数のスコープは宣言行以降。
* インスタンスフィールド変数とクラスフィールド変数は同じ名前空間に属するので、同名のフィールド変数は宣言できない。
* クラスメソッドはクラスに属するものでオブジェクトに属するものではないので、クラスメソッドの中からインスタンスフィールドにアクセスしたり、インスタンスメソッドを呼び出すことはできない。また、クラスメソッド内でthis変数は使えない。
    * ただし、引数で受け取ったオブジェクトに対して、インスタンスフィールドにアクセスしたりインスタンスメソッドを呼び出すことはできる。

### staticイニシャライザ

オブジェクト用の初期化ブロック（インスタンスイニシャライザ）と同様の仕組みとして、クラス用にstaticイニシャライザが存在する。
staticイニシャライザはいくつでも書くことができる。複数のstaticイニシャライザはコードに書かれた順に実行される。
staticイニシャライザの実行順序の規則と具体例としては、

1. クラスフィールド変数にデフォルト値代入
2. クラスフィールド変数宣言時の初期化およびstaticイニシャライザをコードで上から書かれた順に実行

```
#!java

// クラス初期化時は、下記の数字の順に実行される
class My {
    static int i = 1;
    static {
        System.out.println("2");
    }
    static int j = 3;
}
```

### クラスをオブジェクトとして扱う問題点

* クラスフィールドとクラスメソッドを使うと、クラス自身をオブジェクトのように扱えるように見えるが、実際はオブジェクトとして参照値でコレクションの要素に持たせたり、メソッドに引数として渡したりすることができないので、そういう使い方はしない。
* クラス自身を扱うと、グローバルスコープでどこからでも見える（参照できる）ので、コードの構造をわかりづらくする。また、継承による恩恵も受けられない。

### クラスフィールドとクラスメソッドの用途

クラスフィールドとクラスメソッドは次のような用途に限定すべき。

* ユーティリティクラスのメソッド
* クラスの役割（型定義とひな形）に関連する状態や操作

後者の例として、オブジェクトの生成数を数えるクラスを考える。現実のプログラミングでは、これを応用してシングルトンオブジェクトパターンやオブジェクトプーリングを行える。

```
#!java

class My {
    private My() {}
    static int instance_num;
    static My getInstance() {
        instance_num++;
        return new My();
    }
}
```

### クラスの共通処理

共通な処理をくくり出す方法として、以下の3つがある。

* 手続き（メソッド）として共通部をくくり出す
* 共通部をクラスとしてくくり出して、そのオブジェクト参照をフィールドに持ち、処理を受け渡す（**移譲**する）
    * 共通部分を横に追い出すイメージ
* 共通部を基底クラスとしてくくり出して、クラスを階層管理する（継承）
    * 共通部分を上に追い出すイメージ

クラスの継承は、実装の継承（オーバーライド）と振る舞いの継承（インタフェース）の2つの視点がある。
実装の継承（拡張継承）は、単なる共通処理のくくり出しではなく、**型定義の共通部のくくり出し**として捉える必要がある。
継承による依存関係は強い関係になるので、濫用はコードの柔軟性を落とす。
移譲で書くべき関係（**共通処理を単にくくり出す処理**）を拡張継承で書くのは避けるべき。

### 継承について

* 上位クラスの構成要素を下位クラスは受け継ぐが、単に引き継ぐのであればextendsは単なる省略記法でしかない。
* 継承の強みは、継承したメソッドをオーバーライドして、多態性を使えることにある。
* 引き継ぐ要素の削除は基本的には不可能。ただし、privateにしたり、メソッド内でUnsupportedOperationExceptionを投げるようにオーバーライドすれば使えなくはなる（削除と言うより変更）

### フィールド変数の隠蔽

* 継承したクラスで継承元と同じフィールド名で宣言すると、継承元のフィールド変数を隠蔽する。隠されるだけで存在はしているので、superなりキャストしたthisなりで呼び出せる。
* つまり、フィールドはメソッドと違ってオーバーライドされず、別々に存在する。

### オーバーライドで気をつけること

* 同じメソッド名
* 引数の数と型がすべて一致
* 戻り値の型が一致、もしくは戻り値の型が継承型（たとえば、CharSequenceを返すメソッドをStringを返すメソッドでオーバーライド可能）
* throws節の例外型が一致、もしくは継承した例外型（たとえば、throws IOExceptionのメソッドをthrows EOFExceptionでオーバーライド可能）
* アクセス制限が一致、もしくはより緩いアクセス制限（たとえば、protectedのメソッドをpublicでオーバーライド可能）

これらが満たされない場合、オーバーライドされない。（引数の型が継承型だったりした場合、同じ名前のオーバーロードされたメソッドとしてしか存在しない）
オーバーライドを意図するには、@Overrideアノテーションをつけること。

### 継承時のオブジェクト初期化処理の順序

1. 継承分も含めたすべてのフィールド変数にデフォルト値代入
2. 次のAとBを継承階層の最上位型（Objectクラス）から順に実行
    1. フィールド変数宣言時の初期化および初期化ブロックをコードで上から書かれた順に実行
    2. コンストラクタ呼び出し

### super呼び出し

* super呼び出しが明示的にない場合、コンストラクタは暗黙に継承元クラスの引数なしコンストラクタを呼び出す。

### 抽象クラスと抽象メソッド

抽象クラスになる条件は、

* 抽象メソッドを持つクラス
* interfaceを実装して、interfaceのすべてのメソッドの実装を持たないクラス
* 抽象クラスを継承して、すべての抽象メソッドの実装を持たないクラス

* 抽象クラスの存在意義は、ひな形としての役割（インタフェースとの違いでもある）と、テンプレートメソッドパターンにある。

### テンプレートメソッドパターン

* 抽象基底クラスは、骨格実装を提供する。骨格実装の中から内部メソッドを呼ぶことを決め、そのメソッドは抽象メソッドにする。
* オブジェクトを参照する変数の型を抽象基底クラスにすることによって、呼び出し側は特に意識せずに実装を切り替えることができる。
* テンプレートメソッドパターンには、変わりやすい部分を外に追い出す、というプログラミングの基本的な発想がある。複雑なものを外に追い出す感覚は、規模の大きなプログラミングでは必須の感覚。
* [コード例](../../commits/ae22f1e560ea179956383011fd10dd119eab86f5)

### クラスメンバのアクセス制御の使い分けの指針

* フィールドは基本的にprivateにする。ただし、クラス自身がパッケージスコープやネストクラスでスコープが小さく、かつデータを運ぶ役割しか持たない場合などは限定的にpublicにする設計もありうる
* 特定のクラスの実装に依存した下請け処理メソッドはprivateにする
* 継承先のクラスでも使う下請け処理メソッドはprotectedにする
* パッケージ内で他から呼ぶメソッドはパッケージスコープにする
* パッケージ外から呼ぶメソッドはpublicにする

### ネストしたクラス

クラスの中に定義したクラスをネストしたクラスと呼ぶ。ネストしたクラスには次の4種類がある。

* static なネストしたクラス
* 非static なネストしたクラス
* ローカル内部クラス
* 匿名クラス

ネストしたクラスのことをメンバクラスとも呼ぶが、メンバクラスを含むクラスの方をエンクロージングクラスと呼ぶ。
ネストしたクラスにはstaticがついている。staticがつかない場合は、内部クラスと呼ばれ、特別な動作をする。

### ネストしたクラスの使い方

* ネストクラスした自身のアクセス制御
    * public,packageスコープの他に、private修飾子をクラス定義につけると、プライベートスコープにできる。（protectedも可能）
    * エンクロージングクラスから見れなくなる（ただし、見えなくなるのは型であって、オブジェクトの参照は見える。）
* ネストしたクラスとエンクロージングクラスとの親和性
    * ネストしたクラスは、エンクロージングクラスのメンバとして扱われるので、エンクロージングクラスのprivateメンバにアクセスできる。逆に、エンクロージングクラスはネストしたクラスのprivateメンバにアクセスできる。

ex). [コード例](../../commits/3462d5ea03569dd32b4cc2ff2634bc44ca47aebb)

### ネストしたクラスの用途

* エンクロージングクラス内部だけでオブジェクトを使う場合
* ネストしたクラスの実装をエンクロージングクラス内に隠蔽したい場合
* トップレベルクラスの名前を節約する場合（非推奨）
    * この場合は、パッケージ活用してサブパッケージの中にクラス定義をして管理すべき

### 内部クラス

非staticなネストしたクラスを内部クラスと呼ぶ。内部クラスとエンクロージングオブジェクトは次の特別な関係を持つ。

* 内部クラスのオブジェクトは、エンクロージングオブジェクトへの参照を（暗黙に）持つ。
* （上記のために）エンクロージングクラスのクラスメソッド内では、内部クラスのオブジェクト生成ができない。

ex). [コード例](../../commits/fb9cf18128b2e75616f2d78a546ecf101fe09a5e)

staticなネストしたクラスと比較した場合、doit()メソッド内で、引数でエンクロージングオブジェクトを貰っていたのに対し、内部クラスの場合は直接フィールドにアクセス可能。これは、内部クラスのオブジェクトがエンクロージングオブジェクトへの参照を暗黙に持っているために可能。
このため、内部クラスとエンクロージングクラスで同名のフィールドやメソッドがあれば、名前の隠蔽が起きるので、明示的にクラス名.this.フィールド名などでアクセスする。

### ローカル内部クラス

ローカル内部クラスは、

* メソッド内
* コンストラクタ内
* 初期化ブロック内
* if節のブロック内

などのブロック内で定義するクラス。

ex). [コード例](../../commits/a48ab813f6accb65beab6253e8cdd36db289d646)

ローカル内部クラスはブロックの外からはアクセスできない。static修飾子は意味がないため、つけることができない。アクセス制御も意味がないため、アクセス制御用修飾子もつけることができない。
ローカル内部クラスを使う目的は、主に次の通り。

* ブロック内部だけでオブジェクトを使う場合（非推奨）
    * ローカル内部クラスを使う長いブロックは、その長さ自体が問題になるため、現実的には推奨しない。メソッドを分割するなどして、長いブロックをなくすことを考えるべき。
* クラスの実装をブロック内に隠蔽したい場合

ex). [コード例](../../commits/8d5f49605f80955fc24524f03506f906cfbda1f4)

### 匿名クラス

* 匿名クラスの構文

```
#!java

// 匿名クラスの構文
new 基底クラス(実引数) {
    拡張実装(メソッド宣言とフィールド宣言)
}
```

上記のローカル内部クラスを匿名クラスで書き直すと、以下のようになる。

ex). [コード例](../../commits/be4028e1b808703677722974c3de3c31a0ed9ccd)

以下はArrayListの初期化ととComparatorの実装を匿名クラスで表現する例。

```
#!java

import java.util.*;
class MyAnnon {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>() {
            {
                add("foo");
                add("bar");
                add("bazbazbazbaz");
                add("foofoo");
                add("barbarbar");
                add("baz");
            }
        };
        Collections.sort(list, new Comparator<String>() {
            @Override public int compare(String s1, String s2) {
                return s1.length() - s2.length();
            }
        });
        for (String s : list) {
            System.out.println(s);
        }
    }
}
```

### 匿名クラスを使う基準

* コンストラクタが不要（初期化ブロックだけで十分）
* オブジェクト作成が1つだけ

### アプリケーションのクラス分割の例

* データを運ぶクラス（VO,DTO）
* 外部とやり取りするクラス（ファイル、データベース（DAO）、ネットワーク（Web）、ユーザ（UI）)
* 内部ロジックの実装クラス
* 内部ロジッククラスを使いやすくするサービスクラス（API）
* 内部ロジックを下支えするフレームワーク的なクラス
* オブジェクトのライフサイクル管理
* イベントループ（骨格実装とイベント発火（コールバックの呼び出し））
* （個別に）下請け処理を行うヘルパークラス
* ユーティリティクラス

### クラス設計の指針

* オブジェクト指向の「クラスはデータと手続きを一体化したもの」という標題に無理に従う必要はなく、無理に手続きを書く必要はない。
* 外部との接点の役割を分離する。（DAOやUIとのインタフェース部分など）
* 上に向かってくくりだす役割は、他モジュールとの接点、サービス層やAPI層などと呼ばれる部分は、デザインパターンでファサードパターンと呼ばれたりもするが、この部分を変化しないクラスとして位置づけ、全体の中に変化しにくい層を作ることで、全体の堅牢性を高めることができる。建築に例えれば柱や梁に相当。絵画に例えれば、輪郭線や構図を決める線。
* 下に向かってくくり出す役割が、内部ロジックの実装クラスを下支えする機能。オブジェクトのライフサイクル管理やイベントループなどの役割を担う。フレームワークとして存在しているかもしれないし、処理をモジュール化して下請け処理を担うヘルパークラスをくくりだすこともある。
* 手続きや関数をくくりだすユーティリティクラスも存在する。ユーティリティクラスを作る場合は、既存のライブラリに同じ処理がないかを確認すること。

### パラメータ化の意識

クラス設計に王道は無いので、書けないくらいであれば分割は考えずまず書くべき。その後、内部に抱え込んだ値を外部から与えることを考える。

* メソッドレベル
    * 引数で値を与える
* クラスレベル
    * コンストラクタやメソッドで値を与えて、フィールドに状態を持たせる

など。

## コレクションと配列

### コレクションフレームワーク

物の集まりを表現するコレクションに対して、基本的でかつ汎用性の高いデータ構造やアルゴリズムをフレームワークとして提供するAPI。
大きくは分類すると、以下のようになる。

| |ハッシュテーブル|配列|ツリー|リンクリスト|ハッシュテーブル+リンクリスト|
|-|:--------------:|:--:|:----:|:----------:|:---------------------------:|
|セット|HashSet| |TreeSet| |LinkedHashSet|
|リスト| |ArrayList| |LinkedList| |
|デック| |ArrayDeque| |LinkedList| |
|マップ|HashMap| |TreeMap| |LinkedHashMap|

### 変数の型をインタフェース型にする意味

変数の型をインタフェース型にすることで、参照先のオブジェクトを具象クラスのインスタンスとして見立てるのではなく、インタフェースとして振る舞うオブジェクトとして見立てる意図の表明になる。
また、コードから具象クラスへの依存を減らせる。具象クラスは本質的に実装を持つため、変化しやすい存在。一方、インタフェースは変化しにくい部分をインタフェースとして規定するのが本質のため、変更の影響を受けにくいコードになるため。

### リスト

Listインタフェースの代表的なメソッドは以下のとおり。

* add
* contains
* get
* indexOf
* lastIndexOf
* remove
* set
* size

Listインタフェースを実装する具象クラスは、次の2つがある。

* ArrayList
* LinkedList

### ArrayList

* 良い点
    * インデックスを指定して要素を読み出す速度が速い[get]
    * インデックスを指定して要素を書き換える速度が速い[set]
    * 先頭から順にすべての要素をなめる処理が速い
* 悪い点
    * 要素の挿入が遅いことがある（先頭に近い位置への挿入は遅い。末尾に近い位置への挿入は速い時もあるが、遅い時もある）[add]
    * 要素の削除が遅いことがある（先頭に近い位置の削除ほど遅く、末尾に近い位置の削除ほど速い。最後尾の削除は高速。）[remove]
* その他
    * 条件に合致した要素を検索する処理の速度は特別速くはない（工夫によりかなり速くもできる）[contains,indexOf,lastIndexOf]

* 留意点
    * 先頭に近い位置へ要素を追加・削除するほど移動の手間がかかるので、要素数が多いArrayListほど処理が重くなる。
    * 要素の挿入は、ArrayListのデータ構造が連続したメモリ領域を必要とするため、新しい連続メモリ領域を確保して、そこに古い領域のデータをコピーする動作を取る。これは、要素数が多い場合に非常に重い処理になるので、予め要素数の上限がわかっている場合は初期サイズを指定できるコンストラクタを使うことで最確保の無駄を防げる。

### LinkedList

* 良い点
    * 要素の挿入が速い（ただし、多くの場合、挿入の前に検索があることに注意）[add]
    * 要素の削除が速い（ただし、多くの場合、挿入の前に検索があることに注意）[remove]
* 悪い点
    * インデックスを指定して要素を読み出す速度が速くはない[get]
    * インデックスを指定して要素を書き換える速度が速くはない[set]
    * 条件に合致した要素を検索する処理の速度は速くはない[contains,indexOf,lastIndexOf]

* 留意点
    * n番目の要素へアクセスするには、先頭からn個のリンクを辿る必要があるため、要素数が多いほど効率が落ちる。
    * nがリスト全体の真ん中より前か後ろかに応じて、辿る位置を先頭か末尾かを切り替えるような実装になっているため、リストの真ん中当たりにある場合が一番アクセスが遅くなる。
    * 要素の追加と削除は、リンクを付け替えるだけで済む。リンクの付け替えは軽い処理。メモリ領域の再確保も不要（要素ごとにメモリを割り当てるため）
    * 挿入処理の前にインデックスでアクセスするため、リンクを辿る処理が必要なので、挿入処理は速い、という理由だけで一辺倒に使わないようにすること。

### Listの利用方針

* 要素の読み込みが中心（要素すべてを舐める処理や検索）の場合、ArrayListの方が効率的
* 要素の挿入や削除の頻度が高い場合、LinkedListの方が効率的
* 要素の書き換え処理が多い場合、ArrayListの方が効率的
* リストの先頭への追加や削除は、LinkedListでは常套手段だが、ArrayListでは禁じ手。

### バイナリサーチ

* Collections#sortをしてから、Collections#binarySearchを使う。
* 要素数が少ない場合、リニアサーチとバイナリサーチの速度差はほとんどない。処理が単純な分、リニアサーチが早い場合もある。

### マップ

Mapインタフェースの代表的なメソッドは以下のとおり。

* containsKey
* containsValue
* entrySet
* get
* keySet
* put
* remove
* size
* values

Mapインタフェースを実装する具象クラスは、次の3つがある。

* HashMap
* LinkedHashMap
* TreeMap

### HashMap

* 内部動作
    * 内部的に配列（ハッシュ表）を持っている。
    * キーをハッシュ関数に通して出力を得る。これがハッシュ表のインデックスになる。
    * ハッシュ表の得られたインデックス位置に、キーと値のペアを格納する。
* 性能
    * ハッシュ関数の得られる値の範囲で、同じ出力値になった場合にコンフリクトが起こる。
    * いいハッシュ関数ほど、コンフリクトの確率が低い（出力値の偏りが少ない）が、コンフリクトが起こった時HashMapでは内部にリンクリストを形成する。getした時はハッシュ値でインデックスをとった後、リンクリストをたどって、キーの完全一致の比較をして求めるキーと値のペアを見つける。
    * Java6のHashMapのハッシュ表のサイズは16でデフォルト値設定されている。HashMapは自動的にハッシュ表のサイズを拡張するが、この処理は軽い処理ではない。（すべての既存要素のハッシュ関数の再計算が必要になるため）これを防ぐため、コンストラクタで最初に適切なハッシュ表のサイズを指定して使う。

### LinkedHashMap

* 内部動作
    * ハッシュ表に加えて、LinkedListと同じリンクリストを持っており、これで順序を保持する。
    * put時に、ハッシュ表とリンクリストの両方に要素を追加する。リンクリストに対する要素の追加は、単なる末尾への追加なので、高速に動作する。
    * get時はHashMapと同様にハッシュ表から要素を検索する。
    * 要素を全て列挙する処理は、リンクリストをなめる処理になる。要素を追加した順序で列挙する。
    * コンストラクタの第3引数のaccessOrderにtrueを指定すると、リンクリストの順序がアクセスした順（getもしくはputしたタイミング）になる。このモードは、get時にハッシュ表から要素を探した後、リンクリストの該当要素を削除して先頭に追加する。要素の追加や検索の処理速度が少し遅くなる。

### TreeMap

LinkedHashMapで得られる順序ではなく、数値の大小や文字列の辞書順などの順で扱いたい場合は、Treemapを使う。TreeMapの要素のキーは、 *比較可能* でなければいけない。

* 内部動作
    * JavaのTreeMapは、赤黒木と呼ばれるツリー構造で、2分探索木の一種。
    * 要素を追加する場合、左のノードが小さくなるように並べる。
    * 検索する場合は、左下の要素から開始して、その親ノードと右の子ノードをなめる。その後、1つ上に階層を上がり、右の子孫ノードを同じ規則でなめる。
    * この処理は、再帰構造を利用しているため簡易なコードで実現されている。
    * 要素を追加する時に暗黙に検索処理を行なっている。要素の検索時に起きる処理は要素の追加時に走る処理とまったく同じ。
* 性能
    * 2分探索木の高さに比例する。高ければ高いほど、比較する要素が増えるので検索処理が遅くなる。
    * 理想的に動作した場合、バイナリサーチとアルゴリズム上同じ速度になる。HashMapほど速くはないが、実用上十分な速度。
    * 正確には、赤黒木というツリー構造のため高さがバランシングされるようになっているため、TreeMapは追加も検索も十分に速いデータ構造になっている。

### マップクラスの利用の指針

* 順序が不要な場合
    * HashMap（追加や検索が速い）
* 追加した順序やアクセスした順序が欲しい場合
    * LinkedHashMap
* 任意の比較規則に従った順序が欲しい場合
    * TreeMap

### NavigableMap

Java6で、キーの部分検索で近いキーを検索できるNavigableMapインタフェースが追加された。

* ceilingEntry
* ceilingKey
* higherEntry
* higherKey
* floorEntry
* floorKey
* lowerEntry
* lowerKey
* headMap
* tailMap

などのメソッドが使える。

ex). [コード例](../../commits/d9e4e14fac8ba11ccf669b13c29db509979ea9ed)

### セット

集合を表すコレクション。重複のない要素の集まり。順序もない。

Setインタフェースを実装した具象クラスは以下のとおり。

* HashSet
* LinkedHashSet
* TreeSet

Mapインタフェースを実装した具象クラスと似ている。抽象的な意味は異なるが、マップのキーだけに注目すると、抽象的な意味も合致する。
そのため、JavaではMapインタフェースの実装クラスをそのままSetインタフェースで利用している。具象クラスの名前が似ているのは偶然ではなく、内部実装が同じだから。

具象クラスの性質は、マップのそれと全く同じなので、利用の指針も同じ。
セット自体は要素が順序どおりに並ぶことを抽象的な概念として持っていないが、順序どおりに並ぶことを禁じるものではない。要素に順序を持つLinkedHashSetとTreeSetはセットの概念に違反しているわけではない。

Setインタフェースの代表的なメソッドは以下のとおり。

* add
* contains
* remove
* size

### スタック、キュー、デック

* java.util.Stack クラスは、古いクラスなので、スタック構造のコレクションが欲しい場合は、デック（java.utilDeque インタフェースの実装クラス）で代用するか、Listで代用する。
* キューは java.util.Queue インタフェースの実装クラスを使う。
* デックは java.util.Deque インタフェースの実装クラスを使う。

### イテレータ

要素に対して繰り返して操作する場合は、以下の3パターンがある。

* 拡張for文を使う
* イテレータを使う
* インデックスでforループを回す（非推奨）
    * 順序が必要なため、リストにのみ適用できる繰返し処理のため。

コレクション自体に順序の概念が必須でなく、単にモノの集まりという抽象概念しかないのであれば、繰り返し処理に必要な処理は、要素を1つずつ取り出すという概念のみ。
これをイテレータと呼ぶ。

Javaでは、 java.util.Iterator インタフェースを使う。

* boolean hasNext()
* E next()
* void remove()

が主なメソッド。

### 拡張for構文を使えない場合

拡張for構文は、イテレータの簡易記法（シンタックスシュガー）。
次のような場合に、拡張for構文ではなくイテレータを使う必要がある。

* コレクションの要素を逆になめる場合
    * java.util.ListIterator インタフェースを使う
* ループを途中で中断して抜けた後、再び同じ位置からループを再開したい場合
    * 途中で抜ける時にIteratorオブジェクトを保持しておいて、後でまた参照すれば良い
* コレクションの要素をなめるループの中で、要素の追加や削除を行う場合
    * 拡張for構文の中で要素の中を更新すると、ConcurrentModificationException が発生する。（典型的なバグ）
    * インデックスでループを回しながらコレクションの要素を更新すると、ループの回数も変化するため、すべての要素を操作できないのでバグ。
    * 一般に、コレクションの要素をなめる処理中に、要素の追加や削除のような要素の数を変化させる処理を行うことは危険。
    * リストの具象クラスによっては、ループ内で挿入処理を繰り返すコードは遅くなることも注意。
    * 消す場合はclear()メソッドを使ったほうが良い。
    * 順序がないメソッドで追加する場合は、追加すべき要素の一時的なコレクションを作成してから、まとめてaddAll()などで追加するのが定石。

### コレクションの技法

一般に引数で渡ってくるオブジェクトを書き換えるメソッドは良い習慣ではない。破壊的なメソッド、副作用があるメソッドと呼ばれる。
呼び出し側でオブジェクトが変更されるかどうかを気にしなければならないため。

引数のオブジェクトを変更しないメソッドを関数的と呼ぶ。一般論では、関数的なメソッドのほうが良いとされるが、状況によっては非効率にもなるため、絶対にどちらが良いと断言できるものではない。

[コード例](../../commits/69b4e4079104deffc742fd6ff73c1c0dbd26b102)

### 変更不能コレクション

メソッドに渡したコレクションが破壊されないことを保証できると便利。Collectionsクラスに、コレクションを変更不能に変換できるクラスメソッドがある。

* unmodifiableListなど

これを使うと、変更不能リストを渡すことができる。このコレクションに対して変更処理を行うと、実行時にUnsupportedOperationException例外が発生して、予期せぬ破壊的なメソッドを検出できる。

Collectionsクラスには他にも、同期版コレクションへの変換ができるsynchronizedCollectionメソッドなど、便利なメソッドがあるので、一度眼を通すこと。
変更不能コレクションでも、参照先のオブジェクトの変更は防げない。

```
#!java

void rejectLongString(List<StringBuilder> list, int n) {
    for (StringBuilder sb : list) {
        if (sb.length() > n) {
            sb.setLength(n);
        }
    }
}

// 呼び出し側
reject(Collections.unmodifiableList(list), 3);
```

これを防ぐには、要素自体を不変オブジェクトにする必要がある。

### コレクションの初期化記法

以下にコレクションを簡易に初期化する2つの記法を示す。

```
#!java

// コレクションの初期化（配列を利用）
List<StringBuilder> list = Arrays.asList( new StringBuilder[]{ new StringBuilder("foo"),
                                                               new StringBuilder("bar"),
                                                               new StringBuilder("baz") });

// コレクションの初期化（無名クラス + staticイニシャライザ）
List<StringBuilder> slist = new ArrayList<StringBuilder>() {
    {
        add(new StringBuilder("foo"));
        add(new StringBuilder("bar"));
        add(new StringBuilder("baz"));
    }
};

List<StringBuilder> slist = Collections.unmodifiableList(new ArrayList<StringBuilder>() {
    {
        add(new StringBuilder("foo"));
        add(new StringBuilder("bar"));
        add(new StringBuilder("baz"));
    }
});
```

### ソートとアルゴリズム（高階関数の概念）

リストのバイナリサーチにおいて、事前にソートする必要があることは前述のとおり。リストをソートするには、Collectionsクラスのsortクラスメソッドを使える。
sortメソッドには2つの形式がある。

```
#!java

// Collectionsクラスのsortメソッドの定義
<T extends Comparable<? super T>> void sort(List<T> list);
<t> void sort(List<T> list, Comparator<? super T> c);
```

前者はリストの要素の型がComparableインタフェースを実装している必要性を示している。後者は第2引数に渡すオブジェクトがComparator型であることを示している。
要素の型がComparableインタフェース（java.lang.Comparable）を実装していることの意味は要素同士を比較可能という意味。要素同士を比較可能であれば要素を並べる基準が得られる。
後者のsortメソッドは要素同士を比較するためのメソッドを持つオブジェクトを引数に渡してソートを実現する。

特定のメソッドを渡すことを目的とするオブジェクトを *ファンクタ* と呼ぶ。専門的には、関数に渡す関数のことを *高階関数（higher order function）* と呼ぶ。アルゴリズムを移譲の形で外部に追い出す、いわゆるストラテジパターンの関数版。Javaは関数（メソッド）だけを取り出して引数に渡すことができないため、関数メソッドを持つインタフェースを定義して、その実装オブジェクト（ファンクタ）を引数パラメータで渡すことで高階関数相当の処理を実現するのが定石。

```
#!java

// Comparable によるソート
List<String> list = new ArrayList<String>() {
	{
		add("foo");
		add("bar");
		add("bazbazbazbaz");
		add("foofoo");
		add("barbarbar");
		add("baz");
	}
};
Collections.sort(list);
for (String s : list) {
	System.out.println(s);
}
```

Stringクラス自身が持つ比較基準でソートする。文字列オブジェクトは辞書順でソートする基準を持つのでリストは辞書順に並ぶ。
ファンクタを使う例は以下。

```
#!java

// Comparatorによるソート
private static class StringLengthComparator<T extends String> implements Comparator<T> {

	@Override
	public int compare(String o1, String o2) {
		return o1.length() - o2.length();
	}
}

public static void main(String[] args) {
	List<String> list = new ArrayList<String>() {
		{
			add("foo");
			add("bar");
			add("bazbazbazbaz");
			add("foofoo");
			add("barbarbar");
			add("baz");
		}
	};
	Collections.sort(list, new StringLengthComparator<String>());
	for (String s : list) {
		System.out.println(s);
	}
}
```

多くの場合、ファンクタには無名クラスを使う。無名クラスを使いsortメソッドを呼ぶ例を示す。

```
#!java

// Comparatorによるソート（無名クラス版）
List<String> list = new ArrayList<String>() {
	{
		add("foo");
		add("bar");
		add("bazbazbazbaz");
		add("foofoo");
		add("barbarbar");
		add("baz");
	}
};
Collections.sort(list, new Comparator<String>() {
	@Override public int compare(String o1, String o2) {
		return o1.length() - o2.length();
	}
});
for (String s : list) {
	System.out.println(s);
}
```

ComparatorのファンクタはTreeMapのコンストラクタに渡してTreeMapのソート基準にも使える。
```
#!java

TreeMap(Comparator<? super K> comparator);
```

### コレクションと歴史的コード

コレクションAPIはJava1.2でコレクションフレームワークとして整理された経緯がある。それまでに集合を扱うクラスとして使用されていたクラスがあり、現在は非推奨だが存在している。古いクラスは新しいコレクションフレームワークに書き換えることができる。以下にその対応を示す。

|_. 古いクラス|_. 新しいクラス|
|Vector|ArrayList|
|HashTable|HashMap|
|Stack|ArrayDeque or ArrayList|
|Enumeration|Iterator|
|Dictionary抽象クラス|Mapインタフェース|

古いAPIには、Enumerationを引数に取るメソッドがある。

```
#!java

public SequenceInputStream(Enumeration<? extends InputStream> e)
```

CollectionクラスのenumerationクラスメソッドでコレクションオブジェクトをEnumerationオブジェクトに変換できる。
また、Collectionクラスのlistクラスメソッドで、EnumerationオブジェクトをArrayListオブジェクトに変換できる。

### 配列

配列はコレクションよりもよりプリミティブな言語機能。したがって、配列を非常に上手く使うと高速な実装になる可能性がある。
ただし、その高速性は安全さと可読性を犠牲にした速度。しかも、失うものに比べて得られる性能はごく僅か。

* 配列は、Javaが言語機能としてプリミティブな機能を提供しているだけと割り切り、一般の開発者は高レベルに構築されたコレクションフレームワークを使うべき。
* 高レベルAPIの内部実装に配列を使う（ArrayListの実装に配列を使うように）は許容範囲だが、APIとして配列を外に見せることは非推奨。メソッドの戻り値は引数に配列を使おうと考えていたら、コレクションフレームワークのList型にすることを検討する。
* 配列とリストは簡単に相互変換ができる。
* 配列にできてコレクションにできないこと
    * 基本型を要素とすることができる。

配列は、オブジェクトの並びではなく、変数の並び。参照型変数に要素オブジェクトのポインタが入っているイメージ。
各要素の変数の値は初期状態ではnull。要素数が0の配列も作成可能で、空の配列と呼ぶ。空の配列を使うべき場面でnullを使うことはバグの元
のなのでやめるべき。

### 配列のイテレーション

インデックス値を使うことがない限り、（多くの場合、必要ない）拡張for構文を利用する。
```
#!java

void method(StringBuilder[] arr) {
    for (StringBuilder sb :arr) {
        System.out.println(sb);
    }
}

void method(StringBuilder[] arr) {
    for (int i = 0; i < arr.length; i++) {
        System.out.println(arr[i]);
    }
}
```

### 配列の初期化

配列をnewで初期化すると、要素の型に応じたデフォルト値になる。
配列はnewによる生成以外に、特別な初期化構文を持っている。

```
#!java

int[] arr = {0, 1, 2};

// 要素が参照型
StringBuilder[] arr = {new StringBuilder("012"), new StringBuilder("345")};
// 最後に余計なカンマを書いても無視される
StringBuilder[] arr = {new StringBuilder("012"), new StringBuilder("345"),};

// 愛列生成時の初期化子の例
StringBuilder[] arr;
arr = new StringBuilder[]{ new StringBuilder("012"), new StringBuilder("345") };
// メソッド呼び出しの引数の例
method(new StringBuilder[]{ new StringBuilder("012"), new StringBuilder("345") });
```

### 多次元配列

人間の理解力の問題から、特殊な用途を除いて3次元配列よりも大きな次元の配列は推奨しない。

```
#!java

// 3次元配列のコード例
StringBuilder[][][] arr;
arr = new StringBuilder[2][][];
arr[0] = new StringBuilder[2][];
arr[1] = new StringBuilder[2][];
arr[0][0] = new StringBuilder[2];
arr[0][1] = new StringBuilder[2];
arr[1][0] = new StringBuilder[2];
arr[1][1] = new StringBuilder[2];
arr[0][0][0] = new StringBuilder("000");
arr[0][0][1] = new StringBuilder("001");
arr[0][1][0] = new StringBuilder("010");
arr[0][1][1] = new StringBuilder("011");
arr[1][0][0] = new StringBuilder("100");
arr[1][0][1] = new StringBuilder("101");
arr[1][1][0] = new StringBuilder("110");
arr[1][1][1] = new StringBuilder("111");
// 個数を揃える必要はない
// 個数が揃っている場合は、一気に初期化できる
StringBuilder[][][] arr = new StringBuilder[2][2][2];
arr[0][0][0] = new StringBuilder("000");
arr[0][0][1] = new StringBuilder("001");
arr[0][1][0] = new StringBuilder("010");
arr[0][1][1] = new StringBuilder("011");
arr[1][0][0] = new StringBuilder("100");
arr[1][0][1] = new StringBuilder("101");
arr[1][1][0] = new StringBuilder("110");
arr[1][1][1] = new StringBuilder("111");
```

### 多次元配列の初期化子

```
#!java

StringBuilder[][][] arr = {
    {
        { new StringBuilder("000"), new StringBuilder("001") },
        { new StringBuilder("010"), new StringBuilder("011") },
    },
    {
        { new StringBuilder("100"), new StringBuilder("101") },
        { new StringBuilder("110"), new StringBuilder("111") },
    },
};
```

### 配列のコピー

以下の4つの方法がある。

* System.arraycopyメソッドを使う
* Arrays.copyOfメソッドを使う（Java6以降）
* Object.cloneメソッドを使う
* 自分でイテレーションしてコピー（手動コピー）

```
#!java

// System.arraycopyメソッドの定義
void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
// srcで指定した配列のsrcPos位置から、destで指定した配列のdestPosの位置へ、lengthの数の要素をコピー
srcとdestは同じ配列を指定することもできる

// System.arraycopyメソッドの例
StringBuilder[] src = { new StringBuilder("0"), new StringBuilder("1"), new StringBuilder("2") };
StringBuilder[] dest = new StringBuilder[src.length];
System.arraycopy(src, 0, dest, 0, src.length);
for (StringBuilder sb : dest) {
    System.out.println(sb);
}

// Java6以降
StringBuilder[] src = { new StringBuilder("0"), new StringBuilder("1"), new StringBuilder("2") };
StringBuilder[] dest = Arrays.copyOf(src, src.length);
for (StringBuilder sb : dest) {
    System.out.println(sb);
}
```

コピー先の配列の長さが足りないなどで書き込み位置が終端を超える場合はArraysIndexOutOfBoundsException実行時例外が発生する。

配列要素が参照型の場合、System.arraycopyによる配列のコピーは要素だけをコピーする。専門的には *shallow copy* と言う。参照先のオブジェクトを一緒にコピーする動作を *deep copy* と呼ぶ。 deep copy をするには、自分でイテレーションして参照先のオブジェクトのコピーも同時に行う必要がある。

### 配列とコレクションの相互変換

* 配列 → Listオブジェクト

Arrays.asListクラスメソッドを使う。

```
#!java

StringBuilder[] src = { new StringBuilder("0"), new StringBuilder("1"), new StringBuilder("2") };
List<StringBuilder> dest = Arrays.asList(src);
```
asListメソッドは、内部的に配列のコピーをしていないため、生成したリストは変更不能（要素の追加や削除ができない）。（shallow copy ですらなく、同じ配列を内部で参照し続ける　→だから「as」）
生成したリストに変更を加えようとすると、UnsupportedOperationException実行時例外が発生する。
同じ配列を参照しているので、配列側から要素を書き換えると、Listから要素の変更が見える。

shallow copy をするためには、自前でコピーする必要がある。CollectionクラスのaddAllメソッドを使う。
```
#!java

// 配列からListオブジェクトに変換（shallow copy）
StringBuilder[] src = { new StringBuilder("0"), new StringBuilder("1"), new StringBuilder("2") };
List<StringBuilder> dest = new ArrayList<StringBuilder>();
Colletions.addAll(dest, src);
```

* Collectionオブジェクト → 配列

toArrayメソッドを使う。タイプセーフにするために、引数のあるtoArrayメソッドの利用を推奨する。 → 「to」なのでコピーする。

```
#!java

List<StringBuilder> src = new ArrayList<StringBuilder>() {
    {
        add(new StringBuilder("0"));
        add(new StringBuilder("1"));
        add(new StringBuilder("2"));
    }
};
StringBuilder[] dest = src.toArray(new StringBuilder[src.size()]);
```

## インターフェース

### インタフェースを意識する重要性

内部実装ではなく、全体の公正を組み立てるときには、それぞれの構成要素を組み合わせるために部品として抽象化する頭の切り替えが必要。
その際に、分割した部品の境界を意識することで、ソースコードの複雑さに退治できる。

### Javaにおけるインタフェース

オブジェクトに対して、文脈によってそのオブジェクトをどう見立てるかによって、オブジェクトの振る舞いを制御できる。
その見立てをどう見立てるかが、インタフェースによる抽象化。

### クラスとインタフェースの違い

* インタフェースがひな形としての役割を持たない点
    * オブジェクトがどう振る舞うかを決めることのみに特化した言語機能。型定義に特化した言語機能とも言い換えられる。
* クラスは、型定義の役割と同時に、ひな形としての役割、つまりオブジェクトの実装を提供する役割を担う。

### インタフェースと多態性

* 参照型変数を通じてオブジェクトに対して呼べるメソッドは、変数の型で決まる
* 呼ばれたメソッドの本体は、参照先のオブジェクトで決まる

変数の型をインタフェース型にすると、本来参照先のオブジェクトが持っているメソッドを限定するように見えるが、それは適切な見方ではなく、変数側から見ると参照可能なオブジェクトの幅が広がる。もし、変数の型が具象クラスの型であれば、その変数が参照可能なオブジェクトは具象クラスのみになる。変数の型をインタフェース型にすることで、そのインタフェースを実装した任意のクラスのインスタンスを参照できる。
クラスの拡張継承には、多態性と同時に実装コードの共有という目的もあるが、インタフェースの拡張継承は、純粋に多態性のみが目的。

### オブジェクトの振る舞いとオブジェクトの実装

* オブジェクトの振る舞い
    * インタフェース
* オブジェクトの実装
    * クラス

境界を意識するコード、APIとして公開を意識するコード（公開メソッドの日キスや戻り値の型）では、変数の型をインタフェース型にし、それ以外の場合は変数の型をクラス型にするのが一つの指針。

### コードの依存性とインタフェース

変化しにくいものや、変化させるべきでないものをインタフェースにする。使い分けは次のようにする。

* 変化しにくい振る舞いを規定して、それをインタフェースにまとめる
* クラスはインタフェースを実装すると宣言することで、変化しにくい部分を持つことを表明する
* クラスではなくインタフェースに依存することで、変化しにくい部分にのみ依存することを保証する

変化しにくい部分を抽出し、インタフェースとして宣言するのは、変化させないことの意思表示になる。

Javaでは、タイプセーフを実現するための縛りとして、以下の関係でない限り、オブジェクトの参照を変数に代入できない制約を言語仕様として設けている。

* 変数の型が、オブジェクトのクラス型と一致
* 変数の型が、オブジェクトのクラスの拡張元のクラス型と一致
* 変数の型が、オブジェクトのクラスが実装するインタフェース型と一致

### インタフェースと抽象クラス

* 抽象基底クラスは、実装の拡張の役割
    * クラスの拡張による継承は、実装の継承のために用いる
* インタフェースは振る舞いの表明の役割
    * インタフェースの実装による継承は、振る舞いの継承のために用いる

### インタフェース宣言

インタフェースの構成要素は次の通り。

* メソッド（本体なし）
* 定数フィールド
* staticなネストしたクラス
* staticなネストしたインタフェース

インタフェースに使える修飾子は次の通り。

|修飾子|意味|
|------|----|
|public|publicにするとグローバルスコープ。書かないとパッケージスコープ。|
|abstract|インタフェースは暗黙にabstractなので書いても書かなくても同じ。|
|strictfp|インタフェース内に記述した浮動小数点演算を厳密に評価。|
|アノテーション| |

### インタフェースのメンバ

* 定数フィールド宣言
    * 暗黙にpublic static final
* メソッド宣言
    * 暗黙にpublic abstract
* ネストしたクラス宣言およびネストしたインタフェース宣言

インタフェースの場合、メンバのアクセス制御はすべてが暗黙にpublic。なので慣習的には省略することが多い。
定数フィールドは、publicの場合定数定義のように使用できるが、このようなインタフェースの使い方に異論もある。列挙型などを使うべきとの意見に変わってきた。
インタフェースのメソッド宣言に書ける修飾子は以下のとおり。

|修飾子|意味|
|------|----|
|public|暗黙にpublicなので書いても書かなくても同じ|
|abstract|暗黙にabstractなので書いても書かなくても同じ|
|protected,private,static,final,native,synchronized,strictfp|禁止|

### ネストしたインタフェース

クラスと同様、インタフェースもネストすることができる。以下の組み合わせがある。

* クラス内のネストしたインタフェース
* インタフェース内のネストしたインタフェース
* インタフェース内のネストしたクラス

static修飾子があろうとなかろうと常にstatic。なので、内部クラスのような仕組みは存在しない。

```
#!java

class NestedInterfaceSample {
    interface Foo {
        String getMessage();
    }
    private class FooImpl implements Foo {
        private String s;
        FooImpl(String s) {
            this.s = s;
        }
        @Override public String getMessage() {
            return s;
        }
    }
    Foo getFoo() {
        return new FooImpl("abc");
    }
}

// 呼び出し側
NestedInterfaceSample sample = new NestedInterfaceSample();
NestedInterfaceSample.Foo obj = sample.getFoo();
System.out.println(obj.getMessage());
```

```
#!java

// インタフェース内のネストしたクラスの例
interface Foo {
    // インタフェース内のネストしたクラスのアクセス制御は常にpublicかつ、static。記述は慣習的に省略。
    class Baz {
        private String s;
        public Baz(String s) {
            this.s = s;
        }
        public String getMessge() {
            return s;
        }
    }
    // ネストしたクラスをFooインタフェースの戻り値として使える
    Baz getBaz();
}

// 実装クラス側
class FooImpl implements Foo {
    public Baz getBaz() {
        return new Foo.Baz("abc");
    }
}

// 呼び出し側
Foo obj = new FooImpl();
Foo.Baz baz = obj.getBaz();
System.out.println(baz.getMessage());
```

### 多重継承

クラスは複数のインタフェースをimplementsで指定できる。

```
#!java

// 多重継承した2つのインタフェースが同じシグネチャのメソッドを持つ場合
interface Foo {
    void print(String s);
}
interface Bar {
    void print(String s);
}
class FooBar implements Foo, Bar {
    public void print(String s) {
        // 実装
    }
}

// 多重継承したインタフェースが同じ同名のメソッドを持つ場合
interface Foo {
    void print();
}
interface Bar {
    void print(String s);
}
class FooBar implements Foo, Bar {
    public void print() {
        // 実装が必要
    }
    public void print(String s) {
        // 実装が必要
    }
}

// 次の例はシグネチャとして戻り値の型を含まないため、オーバーロードとして認められずコンパイルエラー
interface Foo {
    void print();
}
interface Bar {
    String print();
}
class FooBar implements Foo, Bar {
    public void print() {
        // 実装してもコンパイルエラー
    }
    public String print() {
        // 実装してもコンパイルエラー
    }
}

// ただし、次のように戻り値の型に型の継承関係がある場合、有効
interface Foo {
    Object print();
}
interface Bar {
    String print(); // StringはObjectの継承型
}
class FooBar implements Foo, Bar {
    public String print() {  // 最下のサブタイプを戻り値の型としたメソッドを実装する
        // 実装が必要
    }
}

// 多重継承でのインタフェース定数
// 以下の例はコンパイルエラー
interface Foo {
    int FOO = 1;
}
interface Bar {
    int FOO = 1;
}
class FooBar implements Foo, Bar {
    // 省略
}

// 定数を上書きで宣言してコンパイルエラーを回避
// ただし、このような定数の隠蔽はコードの可読性を落とすので、避けるべき。
interface Foo {
    int FOO = 1;
}
interface Bar {
    int FOO = 1;
}
class FooBar implements Foo, Bar {
    int FOO = 1;
}
```

## 文，式，演算子

Javaのソースコードは文の集合。文は式と文から構成される。
Javaの文は、次の4つのカテゴリに分類できる。

* 制御文
* ブロック文
* 宣言文
* 式文（空文を含む）

### 制御文

* if文やfor文などの制御構造
* try-catch文
* synchronized文

文は、

* 予約語
* 式
* 記号

に分解でき、式は最終的に

* 識別子
* リテラル値
* 記号

に分解される。

識別子は、以下のような定義となる。

* 予約語以外の単語
* true, false, null以外の単語（リテラル値以外）
* Unicodeの（非空白）文字で始まり、その後にUnicodeの文字または数字が続く単語
* 単語の長さに特に制限はない

識別子は上記の定義の範囲であれば自由に作成可能だが、現実的なプログラミングでは、次の規則に従うべき。

* 英文字（大文字及び小文字の英文字およびアンダースコア。大文字と小文字は区別される）で始まり、英文字と数字（0から9）が続く単語

### ブロック文

* 文が並んだ集合を{}で囲むと、文の集合が文になる。
* ブロック文のなかにブロック文を並べることも可能。

```
#!java

// ブロック分の中のブロック文。文法的に正しいコード。
public static void main(String[] args) {
	{{{ {} }}}
}
```

### 宣言文

* クラス宣言
* インタフェース宣言
* パッケージ宣言
* インポート宣言
* フィールド宣言
* メソッド宣言

* 終端のセミコロンまで含めて宣言文。
    * ブロック文は、文ではあるが終端にセミコロンは不要。
    * このことから、「Javaの文は最後に必ずセミコロンを書く必要がある」ではなく「Javaの文の一部は終端としてセミコロンを必要とする」である。

### 式文

* 式とは、演算子とオペランドを演算子の規則に従って並べたもの。
    * 単項演算子、2項演算子、3項演算子
    ** 単項演算子は、前置演算子と後置演算子に分類できる
    * 3項演算子は条件演算子のみ。

式も再帰的に定義できるが、式は文よりずっと可読性が悪くなりがちなので、大きな式は適切に一時変数を使って分解する。

* 式の評価
    * 基本的にオペランド（の式）を先に評価してから、演算子を適用する。一部の演算子（||論理演算子、&&論理演算子、3項演算子）は、例外的にオペランドの評価を遅延する。（遅延の結果、評価しないこともある）

式の評価値（評価の結果得られた値）は以下の3つのパターンに分類できる。

|種類|説明|
|----|----|
|値|右辺値|
|変数（左辺値）|値を代入する先としての変数（いわゆる代入先）|
|空（void）|返り値の型がvoidのメソッドの呼び出し先の評価値|

代入式の評価値は代入値そのもの。
```
#!java

// 最初にiを評価して、iの参照場所を返す
// 次にオペランドを評価して、1を得る
// 最後に演算をして、iに1を代入する。
// 最終的に評価値は1。
// 代入式の左辺値に書くオペランドは変数もしくは配列参照式。
i = 1;
```

また、メソッド呼び出しの()も演算子。オペランドはメソッド名と引数式。

* 式文にできる式は以下の式。
```
#!java

i = 0; // 代入式
i++; // 前置、後置のインクリメント、デクリメント式（i++、++i、i--、--iなど）
System.out.println("foo"); // メソッド呼び出し式
new StringBuilder("foo"); // new演算子を使ったオブジェクト生成式。一般的には代入式の右オペランドになる。
```

### 空文

空文は、書かなくても意味的にも文法的にも問題はないが、敢えて式文を書くことで、ブロックの中の書き忘れではなく何もしないことを意図したコードであることを読み手に伝えることができる。

### 空白文字と改行文字

* 連続した空白文字と改行文字（CRおよびLFを含む）は1つの空白文字と同じ扱い
* // コメントを除いて、改行文字は構文的に意味を持たない
* 文字列リテラルの中に改行文字を直接記述できない（使う場合はエスケープシーケンスを使う）

### 式の評価順序

* &&演算子、||演算子、? :演算子の3つの演算子を除いて、すべてのオペランドを演算前に評価する
* オペランドは左のオペランドから評価する
* メソッド及びコンストラクタ呼び出し式では、呼び出し前に引数を左から評価する
* 括弧内は先に評価する
* オペランドの評価中に例外が発生すると、残りのオペランドは評価しない
* メソッド及びコンストラクタ呼び出し式の、途中の引数の評価で例外が発生すると、残りの引数は評価しない

### 演算子の優先順序と結合規則

* 同じ優先順の演算子の間では、演算子の結合規則により演算の順序が決まる

### インクリメント演算とデクリメント演算

* 前置演算子と後置演算子の違いは、評価値の違い
    * 前置演算子の評価値は加算と減算を行った後の値になる
    * 後置演算子の評価値は加算や減算を行う前の値になる

```
#!java

// 前置演算子と後置演算子の違い
int n = 10;
int m = n++; // nは11になる。n++の評価値は加算前の値なのでmの値は10

int n = 10;
int m = ++n; // nは11になる。++nの評価値は加算後の値なのでmの値は11
```

```
#!java

// 前置演算子を使ったループ
// 9回まわるループ
int n = 0;
while (++n < 10) {
	System.out.println("x");
}

// 後置演算子を使ったループ
// 10回まわるループ
n = 0;
while (n++ < 10) {
	System.out.println("x")
}
```

評価値を使う必要がない場合は、前置演算子と後置演算子どちらを使っても違いはない。どちらでもいい場合は後置演算子が多いが、C++では演算子のオーバーロード機能により、整数値以外に++演算子を定義でき、後置演算子は適用前の値を覚えておく必要があるため、前置演算子が好まれる。

### ビット演算

|演算子|意味|
|------|----|
|&|ビット積（AND）|
|||ビット和（OR）|
|^|排他的ビット和（XOR）|
|<<|左シフト|
|>>|右シフト（最左ビットは符号維持の値)|
|>>>|右シフト（最左ビットをゼロにする）|
|~|1の補数|

### 文字列の演算

|演算子|意味|
|------|----|
|+|文字列の結合|
|+=|文字列の結合と代入|

2つのオペランドの型が数値型の場合、+演算子は数値の加算式になる。両方もしくは片方のオペランドの方が文字列であれば、文字列結合式になる。非文字列型の方のオペランドをtoStringメソッドでString型に型変換する。

```
#!java

// 暗黙にlist.toString()が呼ばれて、文字列に型変換される
List<String> list = new ArrayList<String>();
list.add("bar");
list.add("baz");
String s = "foo" + list;
System.out.println(s); //=> "foo[bar, baz]"

// 暗黙に数値1がボクシング変換でInteger型に変換され、さらにInteger.toString()が呼ばれる
String s1 = "foo" + 1;
System.out.println(s1); //=> "foo1"

// nullと文字列の結合
String s2 = "foo" + null;
System.out.println(s2); //=> "foonull"

// +=演算子の例
String s3 = "foo";
s3 += "bar";
System.out.println(s3); //=> "foobar"

// 文字（char）型は数値の加算減算
System.out.println('a' + 'b'); //=> 195

// 文字列結合演算になる例
System.out.println("a" + 'b'); //=> "ab"
```

### 関係演算と等価演算

* 関係演算子のオペランドの型は数値型（整数型もしくは浮動小数点型、数値ラッパー型。boolean型を除く）
    * 評価値の型はboolean
    * 2つのオペランドの方が異なる場合、オペランドを型変換してから評価する
* 等価演算子のオペランドの型は数値型（整数型もしくは浮動小数点型。boolean型を含む）もしくは参照型。
    * 評価値の型はboolean

|演算子|意味|
|------|----|
|>|大なり|
|>=|以上|
|<|小なり|
|<=|以下|
|==|等しい|
|!=|等しくない|

### 同一性と同値性

* 同値性の比較基準はオブジェクトごとに異なる
    * Stringクラスのオブジェクトであれば、2つのオブジェクトの文字列の内容が一致していれば真になる
    * Stringクラスが同値性をそのように定義しているため
* 同値性の比較にはequalsメソッドを使う。equalsメソッドはObjectクラスのメソッドで、同値性を判定するために、派生クラスがそれぞれに実装を提供することを期待しているメソッド
    * デフォルトのequalsの実装は同一性を判定する
* 同一性が真であれば同値性は必ず真になる。逆は必ずしも成り立たない

* 基本型変数に対する==演算子及び!=演算子は、値が等しいかどうかを判定する
    * 言語仕様上は同一性の判定
    * 同一性を正確に定義すると、変数の値は一致を判定することで、参照型変数の場合も、同一性の判定は、同じ参照値を持つことの判定に他ならない
    * 基本型変数では同一性の判定が同値性の判定と等価の働きをする

### 論理演算

* 論理演算子のオペランドの型はboolean。演算の評価値の型もboolean
* &演算子及び|演算子と&&演算子及び||演算子の違いは、右オペランドを評価遅延すること
    * そのため、&&演算子及び||演算子の右オペランドに副作用のある式を書くと、遅延評価により評価されないことがあるため、この動作に依存するコードは書かないこと
* 否定演算子!は、使い過ぎるとコードの可読性を落とすので、避ける

### 代入演算

代入演算子=は、左オペランドは左辺値として評価される。左オペランドに書ける式は次の2つ。

* 変数（フィールドアクセス式を含む）
* 配列要素の参照式

代入演算子の結合規則は右結合。他のすべての演算子は全て左結合なので、例外的な結合規則。次のような代入式を成立させるための特別な文法規則。

```
#!java

int i, j, k;
i = j = k = 0;
// i = (j = (k = 0));と評価され、i, j, kのすべてに0を代入する
```

### new演算

new演算子は単項前置演算子。オペランドは型名（クラス名、インタフェース名、配列生成式の配列指定）。

### キャスト演算子

キャスト演算子は単項演算子。オペランドの型はキャストで指定する方に依存。

### instanceof演算

instanceof演算子はオブジェクトの型を判定する演算子。2項演算子で左オペランドがオブジェクト参照、右オペランドが参照型の型名（クラス名もしくはインタフェース名）。評価値の型はboolean。左オペランド式が右オペランドの方に代入可能な参照型の時、式の評価値が真になる。instanceof演算子は型比較演算子とも呼ぶ。左オペランドがnullの場合、評価値は常に偽になる。

instanceof演算子は、ダウンキャストと密接に関連する。instanceof演算子を使う目的は、ダウンキャストを安全に行えるかを事前にチェックするため。

```
#!java

void doit(Object obj) {
	if (obj instanceof String) {
		String s = (String)obj;
		System.out.println(s);
	}
}
```

ClassCastExceptionを補足することもできなくはないが、ClassCastExceptionは一般的にバグ。
以下のようなinstanceof演算はコンパイルエラーとなる。

```
#!java

void doit(String s) {
	if (s instanceof StringBuilder) {
		StringBuilder sb = (StringBuilder)s;
		System.out.println(sb);
	}
}
```
StringクラスからStringBuilderクラスへダウンキャストできないのはコンパイル時点でわかるため。

### 配列要素の参照演算

[]も演算子の1つ。[]の中のインデックス値が右オペランドでint型、左オペランドの型が配列参照型の2項演算子。

### フィールドまたはメソッドのアクセス演算

フィールドやメソッドにアクセスする.（ドット）も演算子。左オペランドの型はオブジェクト参照。右オペランドはフィールド名およびメソッド名。

### メソッド呼び出し演算

メソッド呼び出しの()も演算子。左オペランドがメソッド名で、右オペランドは引数式。

## Javaプログラムの実行と制御構造

### Javaプログラムの実行

mainメソッドは、javaコマンドを起動した時にJVMが最初に制御を移すという以上の意味は無い。

+ Javaプログラムを実子するには、引数にクラス名を与えてjavaコマンドを実行する
+ JavaコマンドはJVMを起動する
+ JVMは、クラス名からクラスファイルを探す
+ JVMは見つけたクラスファイルをメモリに読み込む（クラスのロード）
+ JVMはクラスのバイトコードを解釈して実行する

このため、mainメソッドはstaticかつpublicである必要がある。（JVMから見える必要があり、かつヒープではなくパーマネント領域にロードされるため？）

### メソッドのコールチェイン

[コード例](../../commits/4ad67128699195d81ccbe49b2ec835358ca242a1)

### nullチェック

```
#!java

void dumpList(List<String> list) {
	for (String s : list) {
		System.out.println(s);
	}
}
```

上記のメソッドの引数にnullが渡ると、NullPointerExceptionが発生する。NullPointerExceptionが起きるコードはバグ。このバグを修正する方法の一つは、次のように呼び出し元でnullとの比較をする条件分岐を行う方法。

```
#!java

void caller(List<String> list) {
	if (list != null) {
		for (String s : list) {
			System.out.println(s);
		}
	}
}
```

このように、オブジェクト（厳密にはオブジェクト参照）とnullとの比較はしばしば行う。（nullチェック）
すべての呼び出し元にnullチェックを入れるのは現実的ではないので、上記の例の場合はdumpListメソッド内でnullチェックを行うようにすれば、一箇所で済む。また、新規に書かれるコードでnullチェックを忘れる可能性も低くなる。
nullチェックをどちらで行うべきかの間に明確な答えはなく、1つの理想は、null参照の変数を避けること。（nullオブジェクトパターン）

### 定数条件式

コメントアウトでコードのある部分を一時的に無効にしたい局面があるが、代わりに以下のようなif-else文を書くこともある。

```
#!java

if (true) {
	// something
}
if (false) {
	// something
}
```

### 条件演算子

    条件式 ? 式1 : 式2

次のコードはコンパイルエラー。

```
#!java

flag ? System.out.println("1") : System.out.println("0");
```

理由は、条件演算子を使った式は式文ではないため。結果を代入するような代入式であれば、メソッド呼び出しを式1及び式2に書いてもエラーにはならない。
次の例は有効なコード。

```
#!java

int len = flag ? (new StringBuilder("abc")).length() : (new StringBuilder("defght")).length();
```

式1および式2に書けるのは式で、文ではない。そのため、次のコードもエラー。

```
#!java

int len = flag ? { (new StringBuilder("abc")).length(); } : (new StringBuilder("defght")).length();
```

if-else文よりも制約が大きいと言えるが、式をつなげることで条件演算子でもネストした式を書ける。

```
#!java

int i = flag1 ? (flag2 ? 0 : 1) : 2;
```

if文の条件式に条件演算子を使うことも、評価値の型が真偽値であれば、使うことができる。

```
#!java

if (flag ? s.contains("abc") : s.contains("xyz")) {
	System.out.println("true");
}
if (s.contains(flag ? "abc" : "xyz")) {
	System.out.println("true");
}
```

条件演算子は、多用しすぎても可読性を落とす可能性があるため、使い方の指針としては、変数の初期化に利用できる場合のみ条件演算子を使用する、というのがわかりやすい。

```
#!java

int len = flag ? 1 : 0;
```

### switch-case文

使い方の指針としては、ある局面でif-else文よりも可読性が高くなる。その局面としては、

* ==演算による比較式が並ぶ場合
* breakを使わず、caseラベルからそのまま下に流れることを生かしたコード（if-else文では、||で比較式をつなげる必要がある）
* enumの比較を使うコード（switch文の式にenum型を使うと、caseラベルの定数式のenum型名を省略できる）

```
#!java

enum DayOfWeek {
	SUNDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
};
public static void doit_by_day(DayOfWeek dow) {
	switch (dow) {
		case SUNDAY:
		case SATURDAY:
			System.out.println("day off");
			break;
		case MONDAY:
		case TUESDAY:
		case WEDNESDAY:
		case THURSDAY:
		case FRIDAY:
			System.out.println("workday");
			break;
		default:
			assert(false);	// not reached
			// 曜日なのでここに到達しないことは自明だが、書き忘れのミスを防ぐために防衛的に拾う仕組み
	}
}
```

### while文

使い所は、条件式でオブジェクトに対し特定のメソッドを繰り返し呼び出す場合。例えば、ストリームに対するreadメソッドや、正規表現のMatcherに対するfindメソッドなど。

### do-while文

使い所は、事実上以下の2つの場合。

* 文を少なくとも1回実行しないと、条件式の評価に意味が出ない場合
* 文を少なくとも1回っ実行することを保証したい場合

例えば以下の様な場合。
```
#!java

static void printNumberFromRight(int n) {
	do {
		System.out.println(n % 10);
		n /= 10;
	} while (n > 0);
}
```

### for文

* ループ変数がそのfor文だけに使われる場合、ループ変数の宣言と初期化を初期化式に書くべき。（ループ変数のスコープが小さい）
* for文の条件式は省力可能（省略した場合、常に真と評価される式があるとみなされる）
* 更新式には任意の式を書くことができ、一般的にはループ変数を更新する式を書く。更新式は条件式の評価の前に評価される。continue文をforループ内に書いた場合も更新式を評価する。
* 更新式の記述は省略可能
* 10回のループは明確な意図がなければ i = 1; i <=10; i++ よりも、 i = 0; i < 10; i++ にすべき。
* 初期化式と更新式では、複数の式をカンマで区切って並べることもできる。その場合、型は同じものである必要がある。
    * 違う型を変数として使いたければ、for文の外で宣言する必要がある
* 初期化式と更新式には任意の式を書くことができる。極論だが、初期化式と更新式にprint文を書くことすら可能。
* 無限ループは for (;;) {}

### ジャンプ

ループの中からループを抜けたい場合は、ループ変数をループ内で書き換えたりするのではなく、breakやcontinueを使う。

```
#!java

// これは絶対やらない
for (int i = 0; i < 10; i++) {
	if (ループを抜ける条件) {
		i = 10;
	}
}

for (int i = 0; i < 10; i++) {
	if (ループを抜ける条件) {
		break;
		// break文は、while&dowhileの条件式の評価、for文の更新式の評価はしない
	}
}
```

```
#!java

// ループ変数が偶数の時だけ処理をするforループ
// continueを使うことでインデントを1段節約できた。インデントの節約は可読性の向上につながる
for (int i = 0; i < 10; i++) {
	if (i % 2 != 0) {
		continue;
	}
	// something
}
```

### ラベルジャンプ

入れ子になったループでbreakで抜けると、抜けるのは内側のループだけ。入れ子になったループを同時に抜けるには、フラグ変数を使う方法があるが、これは推奨されない。変更に弱いため。

```
#!java

// 推奨しない
// 内部ループを抜けた後、外部ループ内に処理を加える変更があった場合、
// flag_loop変数を見て処理を飛ばすif文が必要
boolean frag_loop = true;
while (flag_loop) {
	System.out.println("outer loop");
	while (条件式) {
		System.out.println("inner loop");
		if (ループを抜ける条件) {
			flag_loop = false;
			break;
		}
	}
}

// 入れ子のループを抜ける
outer_loop:
while (true) {
	System.out.println("outer loop");
	while (true) {
		System.out.println("inner loop");
		break outer_loop;
	}
}
```

continue文もラベルを使うことができる。

## 数値（2）

### 浮動小数点数

* 浮動小数点型は、同じビット長のint（32ビット）やlong（64ビット）よりも広い範囲の数値を表現できる
    * これは、絶対値が大きければ大きいほど飛び飛びの値で表現しているから
    * 逆に言うと、整数型数値から絶対値の大きな浮動小数点型に変換した時、正しい値になる保証がないことを示す

### どの浮動小数点型を使うべきか

* メモリに厳しい制約がない限り、doubleを使うのが一般的。わざわざ精度の低い浮動小数点数を使う意味があまりない

### 浮動小数点数の演算

* 整数との大きな違いは、桁あふれや0による除算
* 浮動小数点数の特別な値
    * POSITIVE_INFINITY
        * 正の無限大
    * NEGATIVE_INFINITY
        * 負の無限大
    * NaN
        * 非数（Not a Number）

浮動小数点数の特別値をもたらす演算をまとめると、以下のとおり。

|x|y|x/y|x%y|
|-|-|---|---|
|通常値|0.0|無限大|NaN|
|通常値|無限大|0.0|x|
|0.0|0.0|NaN|NaN|
|無限大|通常値|無限大|NaN|
|無限大|無限大|NaN|NaN|

これらは、 Double.java の中で次のように定義されている。

```
#!java

public static final POSITIVE_INFINITY = 1.0 / 0.0;
public static final NEGATIVE_INFINITY = -1.0 / 0.0;
public static final NaN = 0.0d / 0.0;
```

### strictfp

strictfp修飾子は、インタフェース、メソッドに適用でき、ハードウェアに依存しない浮動小数点演算を指定する。Javaの思想はプラットフォーム依存を排除することなので、これに反するが、浮動小数点演算は重い処理である。
そのため、以下の様な使い分けができる。

|修飾子|意味|
|------|----|
|strictfp|プラットフォーム非依存の浮動小数点演算を行う|
|非strictfp|高速化のためプラットフォーム依存の浮動小数点演算を行なってもよい。ハードウェア命令を使うかは実装次第|

### 浮動小数点数の内部表現

浮動小数点の内部形式はIEEE754と呼ばれる標準規格。

[コード例](../../commits/0232be1f22af672c5306af2f275d4b5b1d8fc16f)

### 浮動小数点のリテラル値

* fまたはFで終わる浮動小数点リテラルの型はfloat
* dまたはDで終わる浮動小数点リテラルの方はdouble
* その他の浮動小数点リテラルの型はdouble
* 指数部を指定するリテラル表記
    * eもしくはEの後に指数を表記
        * 例えば 1.8e1 // 1.8 x 10の1乗 = 18
        * 1.8e-1 // 1.8 x 10の-1乗 = 0.18
* 16進数で指数表記する場合は
    * pもしくはPの後に指数を表記
        * 0x1.1p0 // (1 + 1 x (1/16)) x 2の0乗 => 1.0625
        * 0x1.1p4 // (1 + 1 x (1/16)) x 2の4乗 => 17.0

### 数値クラス（ラッパークラス）

数値のラッパークラスを使う場面は次の場合。

* 数値をオブジェクトとして扱いたい場合
* 特に、コレクションの要素に数値を使う場合

数値ラッパークラスは、new演算子による直接的なオブジェクト化はせずに、valueOfクラスメソッドを使う。これは、valueOfメソッドを使うと、同じ値に対して同じオブジェクトを再利用できる可能性があるため。[数値クラスは不変クラス（イミュータブル）。]
現実では、ボクシング変換で暗黙に数値クラスをオブジェクト化することもよく行われる。

### Booleanクラスの注意点

Boolean型変数はnullになる可能性があるので、事実上、3状態値である。例えば次のコードは、NullPointerException実行時例外が発生する。

```
#!java

void cond(Boolean b) {
    if (b) {
        System.out.println("true");
    } else {
        System.out.println("false");
    }

// 呼び出し側
Boolean b = null;
cond(b);
```

そのため、Booleanオブジェクトには次の2つの定数のいずれかが確実に代入されることを保証すべき。

* Boolean.TRUE
* Boolean.FALSE

### ボクシング変換

ボクシング変換は、基本型数値と数値ラッパークラスのオブジェクトを自動的に変換する仕組み。

```
#!java

// ボクシング変換の例
Integer i = 0;
```

内部的にはInteger.valueOf(0)が自動的に実行され、Integerオブジェクトを生成する。
逆に数値オブジェクトから基本型数値への変換をアンボクシング変換と言う。

```
#!java

int i = list.get(0);
```

ボクシング変換とアンボクシング変換は便利だが、裏側で暗黙にオブジェクト生成が起きることを忘れないこと。特に、ループ内でインクリメント演算するようなコードは、都度オブジェクト生成がなされるため、パフォーマンス影響することがある。

```
#!java

// 暗黙のボクシング変換（見た目以上に非効率）
Integer i = 0;  // ここでボクシング変換
i++;  //ここではアンボクシング変換とボクシング変換
```

また、アンボクシング変換により、NullPointerException実行時例外が起こる可能性も注意すること。

### 数値オブジェクトの同値性

同値性の判定のためにはequalsメソッドを使う。しかし、数値オブジェクトは==演算子による同一性判定がたまたま同値判定になることがある。絶対値が小さい数値は、高速化のために同じ値の数値に同じ数字オブジェクトを使いまわす実装になっているため。

```
#!java

// たまたま==演算式で数値オブジェクトの同値性判定ができる例
Integer i0 = 1;
Integer i1 = 1;
if (i0 == i1) {
    System.out.println("equal");
}

// ==演算式でオブジェクトの同値性判定ができない例
Integer i0 = 65536;
Integer i1 = 65536;
if (i0 == i1) {
    System.out.println("equal");
}
```

```
#!java

// int → Integerへの変更で問題が見つかりづらい例
class My {
    private int val;
    public int getVal() {
        return val;
    }
}

// 使う側
if (my1.getVal() == my2.getVal()) {
    // 省略
}

// 変更後
class My {
    private Integer val;
    public Integer getVal() {
        return val;
    }
}

// 使う側
if (my1.getVal() == my2.getVal()) {  // Integer.equals() に変更しないと、コンパイルエラーになることなく、単に不正な動作（バグ）になる
    // 省略
}
```

### 型変換

* 拡大変換はキャストなしで変換できる
* 縮小変換にはキャストが必要
* 浮動小数点数から整数への変換では、小数点以下の情報が抜け落ちる

```
#!java

// 精度の損失の例
int i = 16777216; // (=2の24乗)
float fn = i;
System.out.println((int)fn);  // => 1677216
i++;
fn = i;
System.out.println((int)fn); // => 1677216
```

### ビット演算

ビット演算が有効に使える場面があるの事実だが、濫用はコードの可読性を落とすので、利用には注意を払う。

## パッケージ

### パッケージの役割

* 名前空間
* 意味的なまとまりの管理
* アクセス制御

### インポート

import java.util.* と記述すると、java.util パッケージの何かを取り込むわけではなく、List や ArrayList などをjava.util.List, java.util.ArrayList と名前解決させるだけ。生成されるクラスファイルに何か違いがあるわけではない。クラスファイルはパッケージへの参照関係を持つのではなく、java.util.List や java.util.ArrayList への参照関係を持つため。

アスタリスク(*)を使ったインポートを *オンデマンドインポート* と呼ぶ。

java.lang パッケージは特別で、暗黙にインポートされる。

### 単純名の名前解決の優先度

1. そのファイル内で定義する型名
2. 単一型インポートした型名
3. 同じパッケージ内の型名
4. オンデマンドインポートした型名

単純名の衝突を防ぐ指針としては、

* 標準ライブラリの型名と同名は避ける（特に、よく使う型名と同名は避ける）
* オンデマンドインポートをなるべく避ける

### static インポート

static インポートは、クラス及びインタフェースの static メンバ名

* クラスフィールド名
* クラスメソッド名

をインポートする。型のインポート以上に static インポートは慎重に使用すべき。できれば、定数フィールドにのみ static インポートを使うとよい。

### パッケージとアクセス制御

パッケージスコープがデフォルトのアクセス制御である。これを使って、インタフェース及びファクトリクラスを public にして、実装クラスをパッケージスコープとすることで隠蔽するテクニックがある。いかにコードを示す。

[コード例](../../commits/5bd0197ae3e0b35388a7f9e6a41810699e94be1b)

こうして、インタフェースだけをパッケージの外にさらして、実装クラスをパッケージ内に隠蔽する技法はよく使う。

## 列挙型と定数と不変型

### リテラル表記

|名称|型|具体例|補足|
|----|--|------|----|
|ブール値リテラル|boolean|true,false|ブール値リテラルはtrueとfalseのみ|
|文字リテラル|char|'a'||
|文字列リテラル|Stringクラス|"abc"||
|整数リテラル|int or long|123 or 123L|lもしくはLを末尾につけるとlong型。直接short型やbyte型の変数に代入する時はshort型やbyte型|
|浮動小数点リテラル|double or float|1.23 or 1.23f|fもしくはFを末尾につけるとfloat型|
|クラスリテラル|Classクラス|String.class||
|参照リテラル|なし|null|参照リテラルはnullのみ||

### 定数表記

特に数値リテラルはマジックナンバーは排除するよう、定数化するようにして、意味を持たせるとともにタイプミスを未然に防ぐ。また、定数は final 修飾子を付けて再代入を禁止する。

基本型変数の場合は再代入不可が値が変わらないことが等価だが、参照型変数の場合は再代入不可であることと、参照先オブジェクトが変更不可であることは別の話なので、不変オブジェクトでない限りは変更できてしまうので注意する。Stringオブジェクトは不変オブジェクトなので、final修飾子をつけると定数扱いできる。

### 定数定義の使い方

* メソッド内で定数定義をする場合、変数宣言に final 修飾子を付けて、変数名を大文字にする
* クラス内の定数定義は、static final にする
    * インスタンスごとに定数のコピーを持つことは無駄なので、 static でクラスフィールドにする
* クラスにまたがった定数定義は、アクセス修飾子を public にして外部から参照する
* Java5以降は、staticインポートを使って簡潔に書く
    * 定数インタフェースを定義する方法も以前はあったが、今は使わない

* 定数はすべてクラスフィールドかつfinalにする
* コンストラクタをprivateにして、インスタンス化させる意思のないことを示す
* クラスにfinal修飾子を付けて、継承させる意思のないことを示す

* 注意
    * インポートではインポート先の値を取り込むようなことはせず、名前解決のためだけに使う。
    * 基本型変数と文字列の定数定義だけは、例外的に値をとり込むので、定数の値を変更した後インポートした側の再コンパイルが必要

### enum型

Java5で列挙型（enum型）が導入された。値そのものに意味がなく、区別するための定数定義はenum型で書くことができる。例えば、DBの項目によくある「区分」など。

```
#!java

static final int MAN = 0;
static final int WOMAN = 1;
static final int OTHER = 2;

// enumで書き換え
enum Gender {
	MAN,
	WOMAN,
	OTHER,
}
```

enumで定義した型は java.lang.Enum クラスの継承型になっている。つまり、enumは内部的にはクラス。通常のクラスと異なり、new演算子でオブジェクトを生成することはできない。その代わり、enum宣言内に列挙したenum値が暗黙にオブジェクトを生成する。

Enum値の列挙は、valuesメソッドを使う。
```
#!java

for (Gender gender : Gender.values()) {
	System.out.println(gender);
}
```

valuesメソッドはenum値を記述した順序を保証する。ただし、enum血の順序に依存するコードは変更に弱いため推奨しない。

enum値に意味のある値を持たせることもできる。次のようにフィールドとコンストラクタを定義する。

```
#!java

enum Gender {
	MAN("man"),
	WOMAN("woman"),
	OTHER("other");

	private String val;
	private Gender(String val) {
		this.val = val;
	}
}
```

フィールドやメソッドを独自に定義することで、クラスに近い利用も可能。次のコードは、表示用の文字列とデータベース保存用の値定義を持つenum型の例。

```
#!java

enum Gender {
	MAN("man", 0),
	WOMAN("woman", 1),
	OTHER("other", 2);

	private String name4disp;
	private int val4db;
	private Genger(String name4disp, int val4db) {
		this.name4disp = name4disp;
		this.val4db = val4db;
	}
	public String toString() {
		return this.name4disp;
	}
	public int toDatabaseValue() {
		return this.val4db;
	}
}

// 利用側
System.out.println(Genger.MAN); // => 暗黙にtoString()メソッド呼び出し
System.out.println(Gender.MAN.toDatabaseValue()); // => "0"
```

### enum値とswitch文

enum値をswitch-case文の式に書くことができる。enum値以外を書くとコンパイルエラーになるので、単なる定数定義よりも変更に強いコードになる。

### 不変型

不変型にする実装方法は、

* フィールドをprivateにする
* 変更メソッドを提供しない
* フィールドはコンストラクタで初期化して、以降は変更しない
* フィールドをfinalにする（初期化した値を別のスレッドが読めるように保証するため）
* finalクラスにする（拡張継承したクラスが不変性を破ることを防ぐため）

外部からフィールドを変更されない限り、広義の不変オブジェクトと言えるが、狭義の不変オブジェクトは、最初にオブジェクトが生成された時点から一切状態が変化しないオブジェクト。これを保証するには、コンストラクタですべての状態を完全に初期化すべき。
マルチスレッドを考慮してフィールドをfinalにする。たとえ別のスレッドから参照されないオブジェクト出会っても、finalにすることで失うものはない。

### 不変型の注意

一見不変クラスのようで、不変性が破れる例がある。

[コード例](../../commits/35df5e547c6adc065ce514de1ad2fb250b213393)

これらはStringBuilderオブジェクトが不変でないために起きる事故。これを防ぐには次の2つの指針を守る必要がある。

* 引数で受け取る不変でないオブジェクトをフィールド変数で参照する場合、コピーしたオブジェクトを参照する（防御的コピー）
* 不変ではない内部フィールドを返す場合は、不変型（StringBuilderではなくStringなど）に変換して返すか、もしくはコピーして返す

例に上げたような、StringBuilderの事故はあまり起きない。文字列であれば無意識にStringクラスを使うことが多いから。しかし、コレクションオブジェクトをフィールドに持っていると、コレクションオブジェクトを返すメソッドを定義してしまうことがある。

不変クラスにするためには、変更不能なコレクションを返す必要がある。次のようにCollectionクラスのクラスメソッドで簡単に実現できる。こうして返したコレクションを変更しようとすると、UnsupportedOperationException例外が発生する。

内部フィールドの配列を返すメソッドがある場合、配列は変更不能にできない。メソッドの返り値をList型に変更して、Collections.unmodifiableList(Arrays.asList(array))で変更不能なListに変換して返す。
List<String>と異なり、List<StringBuilder>は変更不能なListに変換しても、要素を不変にできないことに注意する。
Collections#unmodifiableListは、要素のコピーをするわけではないため、パフォーマンス的にも問題ない。

## 例外処理

### エラー処理の方法

伝統的なエラー処理の方法としては、以下の2つがある。どちらも今でも普通に利用する手法。

* メソッドの返り値
    * 例えば String#indexOf の返り値は、見つからない時に-1を返す
* エラーハンドラ（エラーコールバック）処理

エラーハンドラ処理の例は、以下のようになる。

```
#!java

interface ErrorHandler {
	void onError(String error);
}

class ErrorHandlerImpl implements ErrorHandler {
	public void onError(String error) {
		System.out.println("error:" + error);
	}
}

// 対象オブジェクト
My my = new My();
my.registerErrorHandler(new ErrorHandlerImpl());

class My {
	private ErrorHandler errorHandler;
	public void registerErrorHandler(ErrorHandler errorHandler) {
		this.errorHandler = errorHandler;
	}
	public void doit() {
		// something
		if (hasError()) {
			if (errorHandler != null) {
				errorHandler.onError("something wrong happend.");
			}
		}
	}
}
```

エラー発生とエラー処理が正常なメソッド呼び出しの外部に括りだされている。メソッドを呼ぶ側の視点では、メソッド内でのエラー発生の詳細が隠蔽されている。メソッド呼び出しの先はブラックボックス化され、エラー発生が単なる取り決めの1つになっている。Javaの例外の考え方は、この考え方の延長線上にある。

### 例外の利点

* 返り値で対処する手法に対する利点
    * エラー返り値は無視できるが、例外は無視できないようにできる
    * メソッドのコールチェインに依存するエラー返り値と違い、例外はコールチェインから独立して定義できる
    * エラー返り値を使う場合に比べ、異常系の処理を分離できる
    * エラー返り値を使う場合に比べ、実行効率が良いこともある
* エラーハンドラで対処する手法に対する利点
    * 例外は言語機能なので、構文サポートが得られる（エラーハンドラの登録処理が不要。記述も容易。）
    * 例外は宣言的に記述できる（構文サポートがあるため）
    * 例外をメソッドの契約として宣言できる

### 例外の具体例

* printStackTraceメソッドは、catch節の中に何を書いていいか不明な場合の定石。
* 検査例外はメソッドと呼び出し側との間の取り決め、実行時例外はいわばJava実行環境と開発者の間の取り決め。

### 例外の補足

* catch節は複数記述できるが、最初の節から順番に評価するため、2番めのcatch節が絶対に使われることがない順序（先により上位の基底例外クラスを記述してしまう）だと、コンパイルエラーになる。

### finally節

* finally節は、try節が正常に終了しようと、例外が発生してtry節の実行を中断しようと、必ず実行される。メソッド呼び出しのコールチェインの先で例外が発生すると、途中のメソッドを中断してcatch節まで飛んでくる。finally節だけはコールチェインを中断して戻ってくる途中で必ず実行する。
* finally節を実行せずにtryブロックを抜ける手段はなく、continue文でtryブロックを抜けた場合でも、finally節は実行される。break文やreturn文でtryブロックを抜けた場合も同様。
* tryブロックがネストされている場合、両方のtryブロックで実行される

### return文とfinally節

return文で抜けてもfinally節を実行するが、finally節の中に別のreturn文があると、その返り値が有効になる。finally節の中にreturn文がなければ、try節の中のreturn文の返り値が有効。

### リソース開放処理のイディオム

リソースの開放処理では、たとえ例外が発生しなくても、try-finally構文を使うことを推奨する。finally節の中に書くことによって確実な後処理の必要性が明示できるため。

```
#!java

try {
	obj = open();
} finally {
	if (obj != null) {
		obj.close();
	}
}
```

次のコードはコンパイルエラーになる。内側のtryブロックのcatch節で補足した例外が外側のcatch節に伝播しないため、外の側のcatch節を決して実行しないため。コンパイルを通すには、内側のcatch節で再度外側のcatch節で例外を補足するようにすればいい。catch節の中から例外を投げるコードは一般的。

```
#!java

import java.io.IOException;

public class My {

	public static void main(String[] args) {
		try {
			try {
				throw new IOException();
			} catch (IOException e) {
				System.out.println("IOException catched.");
				// throw e; // ここから例外をスローすればコンパイルが通るようになる
			} finally {
				System.out.println("finally1");
			}
		} catch (IOException e) {
			System.out.println("IOException catched.");
		} finally {
			System.out.println("finally2");
		}
	}

}
```

### 例外の送出

* throw構文による明示的な例外送出
* 演算による例外送出
* assert構文による例外送出
* JVMによる例外送出（メモリ不足など）

メソッドの抜け方は次の3種類のいずれか1つに限る。

* return文で値を返す
* 返り値の方がvoidで、メソッドの最後の文まで実行して抜ける
* throw文で例外を投げる

throwでメソッドを抜けるのは、return文で抜けるのと似ているが、返り値を持たない。ただし、例外を補足したcatch節やfinally節でreturnすれば返り値を持たせることもできる。
コールチェインを遡っていく途中でどのcatch節にも補足されなかった例外は、最終的に補足されない例外になって、補足されない例外は、そのスレッドの実行を止める。

### 演算による例外送出

```
#!java

// 0による整数除算
int i = 1 / 0; //=> ArithmeticException

// 配列の範囲を超えたアクセス
int[] array = new int[0];
array[0] = 0; //=> ArrayIndexOfBoundsException

// 配列の要素型の違反
Object[] array = new String[1];
array[0] = 0; //=> ArrayStoreException

// 不正な型キャスト
Object obj = "";
Integer i = (Integer)obj; //=> ClassCastException

// null値へのドット演算子アクセス
Object obj = null;
String s = obj.toString(); //=> NullPointerException
```

### 独自例外クラスのコンストラクタの定石

[コード例](../../commits/fc2b4868d4f928e0e0db20584d7c8d052bbf9a9d)

多くの独自例外クラスは、定石のコンストラクタだけを持ち、独自のフィールドやメソッドは持たない。特別なメソッドやフィールドを持たなくても、例外の分割の目的を果たせるため。

### 検査例外と実行時例外の違い

|例外の種類|目的|特徴|
|----------|----|----|
|検査例外|メソッド内で起きる異常の抽象化|throws節での宣言が必須。throws節で宣言していない検査例外は投げられない。投げることが必須ではない。catch節での補足が必須。|
|実行時例外|誤ったメソッド呼び出しの検出|throws節での宣言は自由。catch節での補足は必須ではない。|

### 例外とメソッドのオーバーライド

```
#!java

class MyException extends Exception {}
class MyMyException extends MyException {}
class YouException extends Exception {}

abstract class Base {
	abstract void doit() throws MyException;
}

// 基底例外と同じ例外型をthrows節で宣言できる
class Sub extends Base {
	void doit() throws MyException {}
}

// 基底例外の派生例外型をthrows節で宣言できる
class Sub extends Base {
	void doit() throws MyMyException {}
}

// 実行時例外の例外型をthrows節の宣言に加えるのは自由
class Sub extends Base {
	void doit() throws MyException, MyMyException, RuntimeException {}
}

// throws節の宣言から例外を除去するのは自由
class Sub extends Base {
	void doit() {}
}

// 基底例外の派生元の検査例外型をthrows節の宣言に加えるのは不可
class Sub extends Base {
	void doit() throws Exception {} // コンパイルエラー
}

// 基底例外と派生関係にない検査例外型をthrows節の宣言に加えるのは不可
class Sub extends Base {
	void doit() throws YouException {} // コンパイルエラー
}
```

### 契約によるデザイン（assert）

```
#!java

// assert文の文法
assert 真偽値の式;
assert 真偽値の式 : 詳細式;
```

真偽値の式の評価値が偽の時、assert文はAssertionError例外を送出する。
等価な式を書くと、

```
#!java

assert s != null;
if (s != null) {
	throw new AssertionError();
}

assert s != null : "s must be valid";
if (s != null) {
	throw new AssertionError("s must be valid");
}
```

となる。

assert文が構文として用意されている意味は、絶対に成立すべき式を書くために使い、コードのバグであることの意思表示をするため。コメントで記述することも可能だが、コメントは開発者の良心に依存する弱い制約であるため、より厳密に、より強く仮定を明記するにはassert文を書く。

```
#!java

class User {
	private String name;
	private int birthYear;

	User(String name, int birthYear) {
		assert birthYear > 0;
		// 省略
	}
}
```

assert文を有効にするには、javaコマンドに特別な引数（-ea）が必要。assert文は開発中のプログラムのための機能と考える。実運用時には無効にすることが普通。
assert文を実行する保証がないため、assert文の式に副作用を期待する式を書いてはいけない。

### メソッドの引数チェック

メソッドの引数チェックにassert文を使うのは定石。この場合、それは内部メソッドに限定すべき。
外部公開APIでは、適切な実行時例外を投げる。assert文は開発中にバグを発見するために使うべきで、公開APIの誤った呼び出しのような普通に起こりうることの検出に使うべきではない。javaコマンドに引数(-ea)がないときに不正な引数のチェックをしない公開APIでは役に立たない。

```
#!java

public class User {
	private String name;
	private int birthYear;

	public User(String name, int birthYear) {
		if (name == null || name.isEmpty() || birthYear <= 0) {
			throw new IllegalArgumentException();
		}
		// 省略
	}
}
```

引数チェックにString nameのnullチェックもassertで行うようにすべきか？これはバランスの問題で、どちらにしろnameにnullが渡ればどこかでNullPointerExceptionが起こるはずなので、チェック不要という考え方も出きる。

### 例外の指針

* ExceptionクラスおよびRuntimeExceptionクラスは直接扱わない（直接throwしない。直接throws節に宣言しない）
* 独自の例外（アプリケーション例外）を検査例外として定義する（Exceptionのサブクラス）
* 実行時例外は可能な限り、標準ライブラリで定義済みの例外を使い回し、独自に定義しない（後述する広域脱出用例外を除く）
* Error（エラー例外）のサブクラスは作らない

### 独自の例外（アプリケーション例外）と例外翻訳

ライブラリが投げる検査例外に対していたるところにcatch節を追加してしまい、コードの可読性や保守性の観点から好ましくないコードを書きがちであるが、かと言ってライブラリコードを呼ぶたびにメソッドのthrows節に検査例外を追加して伝播してもthrows節に検査例外が延々と並ぶコードになる。これも同様に可読性の悪いコード。
このような場合、ライブラリの例外を補足して、アプリケーション例外を投げる技法がよく使われる。これを「*例外翻訳*」と呼ぶ。

```
#!java

class AppException extends Exception {
    // 省略
}

void doit() throws AppException {
    try {
        int c = System.in.read();  // 低レベルの検査例外が発生する処理
    } catch (IOException e) {
        throw new AppException();  // 高レベルの検査例外に翻訳
    }
}
```

例外翻訳によって、低レベルの細かい例外への対応コードではなく、高レベルの例外への対応コードだけに集中できる。

例外翻訳を行った場合、原因となった低レベルの例外を知りたいことがある。例外オブジェクトは内部に原因例外オブジェクトを保持できる。この目的のために、アプリケーション例外クラスには、「*例外型と例外オブジェクト*」の定石のコンストラクタに従い、原因例外オブジェクトを引数で受け取るコンストラクタを実装する。


```
#!java

class AppException extends Exception {
    // 省略
    public AppException(String message, Throwable cause) {
        super(message, cause);
    }
    public AppException(Throwable cause) {
        super(cause);
    }
}

void doit() throws AppException {
    try {
        int c = System.in.read();  // 低レベルの検査例外が発生する処理
    } catch (IOException e) {
        throw new AppException(e);  // 高レベルの検査例外に翻訳
    }
}
```

### イディオム化している実行時例外

検査例外に比べて実行時例外を独自に定義する機会は多くない。実行時例外を独自に定義する前に、標準ライブラリで定義済みの実行時例外を使いまわせないかを検討する。

|実行時例外|意味|
|----------|----|
|IllegalArgumentException|不正な引数|
|IllegalStateException|オブジェクトの不正な状態|
|IndexOutOgBoundsException|境界を越えたインデックス値|
|NullPointerException|null値へのアクセス|
|ConcurrentModificationException|オブジェクトの不正な変更|
|UnsupportedOperationException|不正な操作|

### 広域脱出のための実行時例外

* 実行時例外の基本的な利用目的はプログラムの誤りを検出すること
* 検査例外はメソッド呼び出しが複雑化すると、例外変更の変更コストが乗数的に増える危険性がある
* 実行時例外の呼び出し側で補足しなければ自動的に例外が通過する性質を利用した方法として、フレームワークなどで有効に利用される技法がある
    * フレームワークとアプリケーションの間で、何か異常があれば実行時例外を投げる取り決めをしておき、アプリケーション側で実行時例外を補足することはしない
    * 結果として、実行時例外は元のフレームワークのコードまで伝播し、フレームワーク側で実行時例外の補足処理を書くことで、アプリケーション側で例外コードを各所に記述する必要がなくなる
    ** 実行時例外なので、throws節に例外を宣言する必要もない
    * フレームワーク側も、アプリケーション側に立ち入ることなく、異常が起きたことだけを検出可能になる。Webアプリケーションであれば、画面のレスポンスが必要なので、この技法で異常時の処理を一括して記述することができる
* 大局的に見ると、アプリケーションの任意の場所から、実行時例外の例外処理コードにジャンプしているように見える。一般的にメソッドのコールチェインを一気に抜けてジャンプすることを広域脱出と呼ぶ
    * GOTO文など、広域脱出は一般的に可読性の悪いコードをもたらすとして伝統的に悪い手法と呼ばれてきたが、使い所によっては有効に使える一例

## ジェネリック型

### ジェネリック型の典型例

* ArrayList<String> と ArrayList<Integer> は概念的には異なる型として考えて問題ない
    * 内部的には Object 型に置き換えた型が1つ生成されるだけ（ <E extends Object> と等価）。ただし、ジェネリック型を使う側に適切なキャストが挿入される
    * <E extends {型名}> や <E super {型名}> とすると、境界のある型パラメータとして指定した型に置き換えられる。インタフェースでもOKで複数指定でき、アンパサンドで繋げる。並び順は クラス名 & インタフェース名 & インタフェース名 & …（複数OK）
    * このことを *イレイジャ* と呼ぶ。（実行時には型情報が消えているから）

もし、ジェネリック型の仕組みがなかった場合を考えると、ListString 型や ListInteger 型などを個別に作るか、Object 型として一括で扱って、具象クラス要素の型を instanceof 演算子で一つ一つ調べて、ダウンキャストを自分で挿し込む必要がある。これは、コンパイルできるが実行時例外（ClassCastException）が発生するおそれがある。つまり、型安全（タイプセーフ）ではない。可読性も落ちる。
ジェネリック型を上手く使うと、タイプセーフに記述することができ、コンパイル時にエラーを見つけることができる。実行時にエラーを見つけるよりも堅牢になる。

### ジェネリック型の形式

```
#!java

// 形式
ジェネリック型として定義されたクラスやインタフェース<境界内の任意のクラス>
// サンプル
List<String> list;
ArrayList<Integer> intArray;
```

### ジェネリック型の意味

* List<E> のように定義したジェネリック型は、 List<String> や List<Integer> などの新しい形を作るためのひな形としての役割を担う
    * ちょうどクラスとオブジェクトの関係に似ている
    * ジェネリック型をひな形として、それをインスタンス化した新しい形（パラメータ化された型）を生成する
    ** ただし、ジェネリック型をインスタンス化して生成した型も、オブジェクトに対するひな形の役割を担う。そういう意味で、ジェネリック型は *ひな形のひな形* と言える。

### ジェネリック型と多態性

クラスのインスタンスであるオブジェクトを生成するとき、new 式を使う。この時にパラメータ引数を渡すことができる。ジェネリック型に型名を<>の中に渡す。
List<E> のEに相当するものを *型変数* 、List<String> のStringに相当するものを *型引数* と呼ぶ。
ジェネリック型を別の側面で見ると、型変数に渡す型引数に応じたコードの切り替え、と見なすことができる。型に応じた動作の切り替えで思い出すのは、実行時にオブジェクトの型で動作を変える多態性（ポリモフィズム）である。
多態性とは、1つのコードが複数の型を扱えることを指す。この定義から、ジェネリック型も多態性の1つである。

* 継承をベースにした多態性は、型に応じた動作の切り替えを実行時に行う
* ジェネリック型による多態性は、コンパイル時に（概念的に）新しい形を創出し型に応じたコードの切り替えをする

### ジェネリック型宣言

```
#!java

// 宣言例
public class Owner<E> {
	private E element;
	public E get() {
		return element;
	}
	public void put(E element) {
		this.element = element;
	}
}
```

* 最初の行の <E> が型変数
* 複数の型変数をカンマで区切って並べることができる
    * この並んだリストを型パラメータと呼ぶ
* 型変数は慣習的に英語大文字1文字を使う

|型変数名|由来|
|--------|----|
|E|element|
|K|key|
|V|value|
|T|type|

ジェネリックに関する用語のまとめは以下。

|名前|意味|
|----|----|
|型パラメータ|ジェネリック型の型宣言の中の<>の中の型変数の並びのこと。class Owner<E>のE|
|型変数|型パラメータ内に並ぶ変数。ジェネリック型の定義内の型として利用される。Owner<E>の定義ないでE element;のように使われる|
|型引数|ジェネリックを使う時に<>に渡す具体的な型。Owner<String>のStringの部分|
|パラメータ化された型|型引数を渡された実際に使えるようになった型のこと。Owner<String>,Owner<Integer>など|

### 型変数

型変数を使える場所と使えない場所は以下のとおり。

* 使える場所
    * インスタンスフィールド変数の型（型引数も含む。以下同様）
    * インスタンスメソッドの返り値の型
    * インスタンスメソッド内のローカル変数の型
    * インスタンスメソッド内のパラメータ変数の型
    * ネストした型の型名
* 使えない場所
    * クラスフィールド変数の型
    * クラスメソッドの返り値の型
    * クラスメソッド内のローカル変数の型
    * クラスメソッド内のパラメータ変数の型
    * new演算子のオペランド

覚える必要はない。原理は単純で、内部的に Object 型に置き換えた型が1つ生成されるだけであるため。List<String> List<Integer> も List<Object> 相当のクラスを使いまわす。クラスが1つしか存在しないから、型変数をクラスフィールドやクラスメソッドに使えないことがわかる。クラスフィールドやクラスメソッドの中で型変数を使っても区別できないため。
また、型変数はObject型なので、型変数を使ったnew式が使えないこともわかる。

```
#!java

public class Owner<E> {
	public void put(E element) {
		this.element = new E(element); // コンパイルエラー
		// 結局 new Object(element) 相当に置き換わるため、ジェネリック型にとって意味のないオブジェクト生成
		// 同様に new E[n] のような配列の生成もできない。
	}
}
```

### 境界のある型パラメータ

```
#!java

public class Owner<E> { // <E extends Object> と等価
	private E element;
	public E get() {
		return element;
	}
	public void put(E element) {
		this.element = element;
	}
	public String getString() {
		return element.toString(); // OK（Object#toString()を呼んでいる）
	}
	public int getLength() {
		return element.length(); // コンパイルエラー（CharSequence#length()なので、Object型ではない）
	}
}
```

```
#!java

public class Owner<E extends CharSequence> { // 境界はCharSequenceインタフェースとした
	private E element;
	public E get() {
		return element;
	}
	public void put(E element) {
		this.element = element;
	}
	public String getString() {
		return element.toString(); // OK
	}
	public int getLength() {
		return element.length(); // OK
	}
}
// 上記の定義では、CharSequenceの下位型（クラスもしくはインタフェース）しか書けない
```

境界のある型パラメータは、境界型がクラスであろうとインタフェースであろうと extends を使う。
境界型に（拡張継承する）クラスを1つ書け、継承するインタフェースは複数書け、後から書く。
```
#!java

class Foo<E extends クラス名 & インタフェース名> // OK
class Foo<E extends インタフェース名 & クラス名> // NG
```

### 型引数のワイルドカード

次のようにコレクション型の継承関係で、上位型の変数に下位型のオブジェクトを代入できる。

```
#!java

List<Integer> nlist = new ArrayList<Integer>();
Collection<Integer> nlist = new ArrayList<Integer>();
```

要素型の継承関係による上位型の変数への代入はコンパイルエラー。

```
#!java

// コンパイルエラー（NumberはIntegerの上位型にも関わらず）
List<Number> list = new ArrayList<Integer>();
```

次のように型引数をワイルドカードを使い境界型を指定すると、コンパイルできる。
```
#!java

List<? extends Number> nlist = new ArrayList<Integer>();
```

現実的には型引数ワイルドカードはメソッドのパラメータ変数に使う。
<? extends Number> の意味は、型引数がNumberの下位型であるパラメータ化された型を受け入れることを意味する。逆に <? super Number> と書くと、型引数がNumberの上位型であるパラメータ化された型を意味する。

### ジェネリックメソッドとジェネリックコンストラクタ

ジェネリック型と同様の仕組みでジェネリックメソッドとジェネリックコンストラクタがある。ジェネリックメソッドとジェネリックコンストラクタの理屈は同じ。

```
#!java

// ジェネリックメソッドの例
<T> List<T> arrayToList(T[] array) {
	List<T> list = new ArrayList<T>();
	for (T elem : array) {
		list.add(elem);
	}
	return list;
}
```

ジェネリックメソッドの型変数はメソッド内の以下の場所に使える。

* 返り値の型
* パラメータ変数の型
* ローカル変数の型

```
#!java

// 境界のある型パラメータを使う例
<T extends String> List<T> arrayToList(T[] array) {
	List<T> list = new ArrayList<T>();
	for (T elem : array) {
		elem += ".";
		list.add(elem);
	}
		return list;
}
```

ジェネリックメソッドとジェネリック型は独立したもので、非ジェネリッククラス内でもジェネリックメソッドを使える。例えば java.util.Collections クラスは非ジェネリッククラスだが、多くのジェネリックメソッドを持っている。クラスメソッドをジェネリックメソッドにすることも問題ない。
ジェネリッククラスとジェネリックメソッドは独立しているので、ジェネリッククラス内のメソッドをジェネリックメソッドとした場合、その型変数は独立している。

```
#!java

// ジェネリックメソッドの例
class <T> Foo {
	static <T> T f(T t) { // クラス宣言の<T>とメソッド宣言の<T>は別物
		return t;
	}
}
```

### ジェネリック型の設計

ジェネリック型を使う条件は、同じコード（アルゴリズム）で型ごとに独立したコードの実態が欲しい場合にジェネリック型を使う。

例えば、ジェネリック型を使わないで与えられた引数の中の最大値を返すメソッド（関数）を考える。
引数で与えた配列の要素の中で最大値の要素を返す、という仕様の場合、どんな要素型でも受け入れることを想定すると、最初に思いつくメソッド定義は次のようになる。

```
#!java

Object max(Object[] array)
```

maxメソッドの中では要素同士の比較が必要となるため、インタフェースに対してプログラミングする技法に通じていれば、次のようなインタフェース定義とmaxメソッドの実装が考えられる。

```
#!java

// 比較用インタフェース
interface MyComparable {
	int compareTo(Object o);
}
// max関数の実装
static Object max(MyComparble[] array) {
	MyComparable ret = null;
	for (MyComparable e : array) {
		if (ret == null) {
			ret = e;
			continue;
		}
		if (e.compareTo(ret) > 0) {
			ret = e;
		}
	}
	return ret;
}
```

maxメソッドの返り値の型はMyComparableでもよいが、比較可能であることの振る舞いを返り値に期待する理由は無いので、Object型にしている。compareToメソッドの返り値の意味は java.lang.Comparable#compareTo と同じ。
MyComparableインタフェースの実装クラスを定義する。数値クラスと文字列クラスのために独自に比較用クラスを実装する。

```
#!java

class MyInteger implements MyComparable {
	int i;
	MyInteger(int i) {
		this.i = i;
	}
	@Override public int compareTo(Object o) {
		if (o instanceof MyInteger) {
			return i - (Integer)o;
		} else {
			throw new IllegalArgumentException();
		}
	}
}
```

```
#!java

class MyString implements MyComparable {
	String s;
	MyInteger(String s) {
		this.s = s;
	}
	@Override public int compareTo(Object o) {
		if (o instanceof MyString) {
			return s.length() - ((MyString)o).s.length();
		} else {
			throw new IllegalArgumentException();
		}
	}
}
```

compareToメソッドは、比較対象オブジェクトが同じクラスでない場合に実行時例外を投げるようにしている。本質的に不正な比較なので、実行時例外を投げることは妥当。
maxメソッドを使ってみる。次のコードはObject型からMyString型へのダウンキャストがあることを無視すれば、動作に問題はない。

```
#!java

MyString[] sarray = new MyString[] { new MyString("a"), new MyString("aa"), new MyString("aaaa"), new MyString("aaa") };
MyString m = (MyString)max(sarray);

// 実行時例外が起こる例
MyComparable[] oarray = new MyComparable { new MyString("a"), new MyInteger(0) };
Object o max(oarray);
```

内部的にMyStringオブジェクトとMyIntegerオブジェクトを比較しようとするので、実行時例外が起きる。困ったことにこのコードはコンパイルが普通に通る。無理なキャストすら無い。
インタフェースだけに依存した、コードの表面上はきれいなコードにもかかわらず、実行時に致命的なエラーが起きてしまう。

上記から、インタフェースに対してプログラミングする技法だけでは何かを満たせていないことがわかる。
足りないのは、インタフェースに依存した実装ではなく、型ごとに独立したコードの実体である。つまり、MyStringクラスにはMyStringオブジェクト群から最大値を得るmaxメソッドがあるべきで、MyIntegerクラスにはMyIntegerオブジェクト群から最大値を得るmaxメソッドがあるべき。同じ事は比較メソッドにも言える。

そして、maxメソッドの入力と出力関係を考えてみると、maxメソッドの入力はTの配列で、出力はTオブジェクト。入力と出力を、値としての側面だけではなく型という側面で見てみると、maxメソッドの出力の型Tは入力から直接に決まっている。このパターンのメソッドこそがジェネリック型を使う候補となる。
入力と出力は、引数と返り値だけでなく、もっと広い意味で捉える。例えばJavaの標準のsortメソッド（java.util.Collectionsのクラスメソッド）は、引数で与えたコレクションの要素をソートするが、返り値は特に無い。入力はソート前のコレクション、出力はソート後のコレクションと捉える。入力と出力は引数にすら現れないこともある。コレクションに要素を追加するaddメソッドは、要素追加前のコレクションと追加したい要素が入力で、要素追加後のコレクションが出力。この場合の入力と出力はオブジェクトのフィールド（状態）も含めて捉えていることがわかる。

ここまでの例で、入力のT情報がそのまま出力に引き継がれていることがわかる。このようなパターンのメソッドがジェネリックメソッドの候補であり、このようなメソッドを持つクラスやインタフェースがジェネリック型の候補。

### ジェネリック型とパラメータ化

これまでトップダウン的にジェネリック型を使える条件を見てきたが、現実的にはボトムアップ的にジェネリック型やジェネリックメソッドを作る事のほうが多いはず。

具体的な利用方法の例として、int型変数のリストから最大値を返すmax_iメソッドがあったとする。double型数値のリストから最大値を返すmax_dメソッドを次に作ったとする。その後、short型数値のリストから最大値を探すmax_sメソッドを作ったとする。
これらのメソッドは、型を除けば、それ以外は同じコードであることに気づくことがジェネリック型への第1歩。共通部分と異なる部分を分けて、異なる部分をパラメータ化して外部に追い出す技法は、プログラミングの大原則。今、京津する部分はコードで、パラメータ化して外部に追い出せるのは型情報。
こうして型情報をパラメータ化して外部化したものがジェネリック型。ジェネリック型は特殊な技法に見えるが、根源となる発想そのものは、変わる部分や異なる部分をパラメータ化して外に追い出すという、プログラミングの大原則に則った正攻法な技法であることがわかる。

## ストリーム

### Java のストリームクラスの概論

Javaのストリームクラスの抽象基底クラスは、
| |入力ストリーム|出力ストリーム|
|-|--------------|--------------|
|バイトストリーム|InputStream|OutputStream|
|文字ストリーム|Reader|Writer|

* ストリームは、使い終わったらクローズする必要がある。クローズ忘れはバグ（リーク）
* finally節を使ってクローズするイディオムに従う
* closeメソッド呼び出しでも例外が発生する。ファイルに対するclose処理で起きる例外の大半は、ディスクフルのための書き込み失敗。
* writeメソッドでの書き込みが全て成功していても、closeメソッドの失敗でファイルへの書き込みができていないことがあることに注意する。ファイルへの書き込みが遅延されることがあるため。
* 読み込みファイルでのclose失敗はほとんど起きないが、起きた場合はディスクの物理的な故障がありえる。
* ストリームクラスは、典型的なテンプレートメソッドパターンの好例となっている。
    * java.io.InputStream クラスを参照。

### バイトストリーム処理

* readメソッドの戻り値がbyteでなくintである理由は、ストリームの終端に達した時に-1を返す定義になっており、byte型より大きな型を返す必要があるので、intになっている。shortでもいいが、shortでもintでもいい場合はintを使う原則に従っている。
* writeメソッドの戻り値がintなのは、readメソッドとの対称性のため。byte型の値の範囲（-128から127の間でint型に型変換すると0から255になる）を越える値は単に上位ビットを無視して書き込みする。
* FileOutputStreamクラスは、既存ファイルを上書きして出力するか、もしくは末尾へ追記するかをオブジェクト生成時に制御できる。

### 標準入出力

* Java6以降には、 java.io.Console クラスがある。唯一のオブジェクトを System クラスの console メソッドで取得する。コンソールがあるか否かはプラットフォームに依存するので、consoleメソッドがnullを返す場合があることに注意する。

* [コード例](../../commits/f963f0e316492758b25172fd63cb02fa2d781451)

### 文字ストリーム処理

* readメソッドの戻り値の型がcharではなくintである理由は InputStream と同様。
    * 読み込んだ文字の値を返す。戻り値の範囲は0から0xffffの間。ストリームの終端に達すると-1を返す。
* バイトの読み書きがただの8ビット単位の読み書きにすぎないのに対し、文字の読み書きには文字コードの問題がつきまとう。 FileReader クラスと FileWriter クラスは暗黙にデフォルトロケールを仮定する。明示的にロケールを指定するには InputStreamReader クラスと OutputStreamWriter クラスを使う。

* [コード例](../../commits/48c33f23d1b5d113d6489b72329c325230824a67)

### バイトストリームから文字ストリームへの変換

InputStreamReader と OutputStreamWriter は文字ストリーム。コンストラクタにはバイトストリームオブジェクト（InputStream, OutputStream）を与える。
InputStreamReader と OutputStreamWriter を使う主な目的は次の通り。

* ソケットなど直接にはバイトストリームしか取得できないクラスの場合、バイトストリームから文字ストリームを得るため。
* 文字コード（ロケール）を指定した文字ストリームを得るため。

ファイルを読む場合、バイトストリームの FileInputStream オブジェクトをコンストラクタの引数に渡して InputStreamReader オブジェクトを生成する。なお、 InputStreamReader と OutputStreamWriter をクローズすると、引数で与えたバイトストリームも同時にクローズする。

* [コード例](../../commits/a619e7b5263ecd3b7d533d9e922e46529cbc1933)

### バッファリング

ディスクへの読み書きは一般にメモリに比べて低速である。ファイルストリームに対して1バイトずつもしくは1文字ずつ読み書きをすると動作が非常に遅くなる。1バイトや1文字単位でディスクへのアクセスが発生するため。
この課題に対して「バッファリング」という技法を使って、動作を高速化する。
読み込みの場合、裏でまとめてディスクからメモリに読み込み、ディスクへのアクセスを減らす。読み込むメモリ領域をバッファという。readメソッドはバッファからデータを返す。読み込み済みのデータがなくなると、次のreadメソッドの時に、再びまとめてディスクからバッファに読み込む。
書き込みの場合、writeメソッドでデータを一旦バッファに書き込み、writeメソッドを繰り返し呼び、用意したバッファ領域がいっぱいになると、まとめてデータをディスクに書き出す。（バッファリングしてもストリームの実装クラスが最終的に使うメソッドが1バイト単位のreadメソッドでは遅いままなので、FileInputStream はreadを使わない readBytes メソッドを用意している）
ネットワークへの読み書きもメモリに比べて低速なので、バッファリングが一般的。

### バッファリングストリーム

バッファリングを実装したストリームが標準クラスとして存在する。

| |入力ストリーム|出力ストリーム|
|-|--------------|--------------|
|バイトストリーム|BufferedInputStream|BufferedOutputStream|
|文字ストリーム|BufferedReader|BufferedWriter|

通常のストリームオブジェクトを引数に渡して、バッファリングストリームオブジェクトを生成する。内部的には非バッファリングストリームオブジェクトを包み込む形でバッファリングストリームオブジェクトが存在し、かつバッファリングストリームクラスは非バッファリングストリームクラスの継承クラス。
参照する変数の型を基底クラスにすることで、バッファリングストリームオブジェクトを通常のストリームオブジェクトと変わらず扱うことができる。FileBufferedByteバッファリングをするか否かの切り替えはただオブジェクト生成の部分だけ。他の部分は一切変更する必要がない。（このように機能拡張をしながら元のオブジェクトと同じように扱える実装技法を、デザインパターンでデコレータパターンと呼ぶ。）

* [コード例](../../commits/7efbc8f78100d0eb8d2536e09a97510d780d21a6)

### バッファリングの方針

出力ストリームをバッファリングした場合、writeメソッドを呼んでも実際の書き込みが行われている保証はない。実際の書き込みは将来のwriteメソッドのタイミングかもしれないし、最大では出力ストリームをクローズしたタイミングまで遅延する。ネットワーク送信などでは問題になることがあるため、その場合は BufferedOutputStream と BufferedReader のflushメソッドを呼ぶことで、出力バッファの中身を強制的に出力できる。
ファイルやネットワークに対するストリームではバッファリングはほぼ必須。常にまとまった量のデータを読み書きするなら、バッファリングは不要。なぜなら、バッファへデータをコピーする手間だけ少し遅くなるため。
ただ、バッファリングを使うか否かのような些細な事に気を紛らわすぐらいであれば、ファイルやネットワークのストリームでは常にバッファリングを行う、という方針を徹底するほうが簡単。

### ランダムアクセス

ファイルをストリームとして見立てると、ファイルを先頭から読む、先頭もしくは末尾からかくことしかできなくなる。これはストリーム抽象化の本質で、操作を限定することでファイル以外の様々な対象を等価に扱うことができるようになる。
一方で、ファイルそのものは、ファイルの任意の位置へ読み書きできるランダムアクセスの機能を持つ。この機能を扱えるクラスが RandomAccessFile クラス。RandomAccessFile クラスはストリームとは別の視点でのファイルの抽象化。
RandomAccessFile オブジェクトを生成するには、ファイル名とモードを指定。モードは文字列で、

* "r"
    * 読み込み専用。書き込んだ場合は実行時例外が発生。
* "rw"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。
* "rws"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。ファイルの内容とメタデータの書き込み処理を遅延しない（バッファリングしない）
* "rwd"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。ファイル内容の書き込み処理を遅延しない（バッファリングしない）

の4つ。

RandomAccessFile オブジェクトは読み書きしている位置を示すファイルポインタを持つ。ファイルポインタはファイルの先頭から数え始める0から始まるオフセット値。getFilePointerメソッドで取得して、seekメソッドでファイルポインタ値を変更できる。これは入力ストリームにはできない動作。

writeメソッドによる書き込みでもファイルポインタが自動的に移動する。seekを使うと、ファイルポインタ値を変更できる。現在のファイルサイズよりも大きな値をseekメソッドに指定して書き込みを行うと、ファイルサイズを拡張する。seekで飛んだ部分は0で埋められる。ファイルサイズを越えた部分のreadメソッドは、ただ-1（ファイルの終端）を返す。

* [コード例](../../commits/db082d31b52d64447e45081b9e5fcd7bbfc115de)

### ファイル操作

ファイル名を変更したり、ファイル自体を削除したりなどの、ファイル自体に対する操作が存在する。この機能を提供するクラスが、File クラス。 File クラスは、ファイルの中身ではなくファイル名（厳密にはファイルパス名）への操作を提供するクラス。
File クラスのオブジェクト生成は、（指定したファイルパスへの）ファイル作成を意味しない。実際にファイルを作成するには createNewFile メソッドを呼ぶ。同名のファイルが既に存在する場合は何もしない。 createNewFile メソッドはファイルを新規に作成した場合に true を返し、同名のファイルが存在した場合は false を返す。
作成、移動、削除が主な操作。作成、移動、削除があると、複製（コピー）も基本的操作に含めたいと考えるかもしれないが、File クラスに copyメソッドは存在しない。複製は元のファイルを読み込んで、複製先のファイルに書き込むことで実現する。

### ディレクトリ操作

ディレクトリに対する操作も File クラスで行える。 File クラスの isFile メソッドと isDirectory メソッドで File オブジェクトに対応するファイルがファイルかディレクトリかを判定できる。

* [コード例](../../commits/f9333ac9eb965fdf74f01c3a8bf5c3f2e3a92720)

### ディレクトリのファイル一覧

File オブジェクトの list メソッドを呼ぶと、File オブジェクトが参照するディレクトリ以下のファイルパス名の配列を返す。
listFiles メソッドを使うと、ディレクトリ以下のファイルの File オブジェクトの配列を返す。

* [コード例](../../commits/ee2c380d34bb5b8188350f894d53fde3aa55ef73)

list メソッドには次のように FilenameFilter オブジェクトを引数に取るメソッドが存在する。FilenameFilter は accept メソッドだけを持つインタフェース。
list メソッドで得られるファイル一覧に対して、それぞれのファイルパス名毎に accept メソッドが呼ばれる。accept メソッドが true を返したファイルだけが list メソッドの戻り値の配列の要素になる。フィルタ用のファンクタを渡す技法はコールバックパターンの一種。

次の例では、ルートディレクトリ直下のファイルの家、ディレクトリ名がtmpで始まらないディレクトリのみを列挙する。FilenameFilter オブジェクトを匿名クラスで生成している。

* [コード例](../../commits/0075cd4f47c24edaa4e0cb1e67dd1a1634624dbc)

以下は、ファイルを再帰的に表示する例。listFiles メソッドを再帰的に呼ぶ。

* [コード例](../../commits/38da34fbff8c3019475c46898ab8a2b264e55439)

### バイト列ストリーム

文字列の場合は、不変な文字列としてStringクラス、変更可能な文字列としてStringBuilderクラスがある。バイト列の場合は、byteの配列を使うことで変更可能なバイト列を得られるが、配列の長さは変更できない。メモリ上で可変長のバイト列を扱うために ByteArrayOutputStream クラスを使うことができる。長さを気にせずバイト列を書き足す処理をしたい時に利用できる。
可変長の文字列を扱う CharArrayOutputStream クラスもあるが、文字列に関しては通常StringBuilderで事足りる。

* [コード例](../../commits/c8b41bea6328eb84a6572d8e654cd147e063ae24)

### ネットワーク（ソケット）

ネットワークでのデータの入出力にはソケットと呼ぶ抽象化層を使う。ソケットは通信先の相手と1対1に繋がる仮想的な線を考えその端点にデータを読み書きする機能。Javaでは、ソケットへのデータの読み書きをストリームで扱う。

ソケットには、サーバとクライアントという区分けはなく、接続を待ち受けるソケット（受動的なソケット）と、自分から接続しに行くソケット（能動的なソケット）の2つがあるだけ。通常、サーバプログラムは受動的ソケットを使い、クライアントプログラムは能動的ソケットを使う。

受動的ソケットはクライアント（能動的ソケット）からの接続があったら新しく待ち受けソケットを生成することで、複数のクライアントからの接続を受け入れることができる。

ソケットは、

* 自分自身（ローカル）のIPアドレスとポート番号、接続相手（リモート）のIPアドレスとポート番号の4つ組からなる

接続開始までの動作は非対称だが、接続を確立すると2つの通信プロセスの関係は対称になる。通信を終了するにはソケットをクローズするが、どちらからでも行える。
ソケットに対するデータの中身、またどちらからデータを送り始めるかなどを規定するのはTCP/IPより上位の通信プロトコルの責務。WebであればHTTPなどが相当する。

### クライアント処理

接続を開始する側のソケット（能動的ソケット）を使うネットワーク処理をクライアント処理と呼ぶことにする。
クライアント処理は最初にソケットオブジェクトを生成する。
ソケットオブジェクトは java.net.Socket クラスのオブジェクト。
処理の流れとしては、

1. リモート（接続相手）のホスト名もしくはIPアドレスとポート番号を指定して、能動的ソケットオブジェクトを生成する。
    * ローカル（自分自身）のIPアドレスとポート番号を明示的に指定することもできる。指定しない場合はローカルのIPアドレスはシステム（OS）のデフォルトのIPアドレスを使い、ローカルのポート番号は空いている番号を自動で選ぶ。多くの場合ローカルのIPアドレスとポートは指定する必要はない
    * ホスト名を渡した場合、オブジェクト生成時に名前解決を暗黙に行い、名前解決ができない場合は UnknownHostException 例外が発生する
2. サーバと接続が確立すると Socket オブジェクトが生成される。データの送受信を行うには Socket オブジェクトから入出力ストリームを取得する。入力ストリームは getInputStream メソッド、 出力ストリームは getOutputStream メソッドで取得する
3. ストリーム取得後は、ファイル入出力と同様の方法でデータ入出力を行える
4. ソケットをクローズすると、暗黙に対応するストリームもクローズする。一般に、ストリームではなくソケットの close メソッドを呼ぶ。ソケットは finally 節イディオムでクローズすることを推奨する。

[コード例](../../commits/d16961ec9810c66f6c66fd5afdbb3d8a2c833781)

### サーバ処理

受動的な待ち受けソケットを作成し、能動的なソケットからの接続を受け入れるネットワーク処理をサーバ処理と呼ぶことにする。
サーバ処理は最初に待ち受けソケット用のソケットオブジェクトを生成する。
待ち受けソケットオブジェクトは java.net.ServerSocket クラスのオブジェクト。
処理の流れとしては、

1. ServerSocket クラスのオブジェクトの生成時に待ち受けポート番号を指定するか、オブジェクト生成後に bind メソッドでポートを指定する方法がある。通常は生成時にポート番号を指定する
2. ServerSocket オブジェクトの accept メソッドで待ち受けメソッドは接続待ち状態になる。接続があるまで accept メソッドは待機する。つまり accept メソッドを呼び出したスレッドは処理を停止する（専門的にはブロックするという）プログラムが1スレッドであれば、事実上プログラムは何もせずに止まったままとなる。
3. リモートの能動的なソケット（クライアントプログラム）から接続を受け付けると、accept メソッドは新たな Socket オブジェクトを返す。この Socket オブジェクトは受け入れソケットのオブジェクト。このソケットオブジェクトから入出力ストリームを取得することで、接続相手と通信が可能。
    * 上記でも述べたが、受け入れソケットはクライアント側の能動的ソケットと完全に対象な関係なので、どちらからでもデータを送信可能であるし、どちらからでもソケットをクローズ可能。これらの順序を決定するのは上位のプロトコルの決まりで、ネットワークプログラムを作成する開発者の責任。

[コード例](../../commits/4b74ae367cc9b2affe7a5496460d39017815dc79)

accept メソッドの戻り値で受け入れソケットオブジェクトを取得する。受け入れソケット取得後の処理はクライアント側コードと区別がないことに注目。ただし読み書きの順序は対称的になる。MyClientが送信してから受信しているのに対し、MyServerは受信してから送信している。お互いの順序を逆にしても動作する。

### タイムアウト処理

ソケットストリームのデフォルト動作では、ServerSocket オブジェクトの accept メソッドの呼び出し、能動的ソケットオブジェクトの Socket オブジェクト生成、およびソケットストリームへの送受信処理で、相手側が反応しない限りは待ち続ける（ブロックする）。現実的なネットワークプログラムでは相手がいるかどうかは不明。相手の都合でプログラムが止まるのは困るので、タイムアウト処理が必要となる。

タイムアウト処理は次のように行う。

* ServerSocket の accept メソッドのタイムアウト処理は ServerSocket の setSoTimeout メソッドを呼ぶ。acceptメソッドの呼び出し前に設定する必要がある。設定値の単位はミリ秒。
* クライアント側の能動的メソッドの接続開始処理のタイムアウト設定を行うには、まず Socket オブジェクトを引数なしで生成する。コンストラクタの引数に接続先情報を渡すと Socket オブジェクト生成時に接続を開始するが、引数なしで生成すると接続を開始しない。Socket オブジェクトの connect メソッドを明示的に呼ぶことで接続を開始する。connect メソッドの引数にタイムアウト値を設定する。
* サーバ側の受け入れソケット及びクライアント側の能動的ソケットは setSoTimeout メソッド値を設定できない。 write メソッドは内部でバッファリングしているため、相手側の受信のいかんにかかわらず一定量のデータはブロックしない。別の見方をすると write メソッドが正常に終了しても相手側にデータが届いている保証はない。バッファリングのサイズを越えた write メソッドはブロックする。相手側が受信しなければ永遠に停止する。ただし、相手側がソケットをクローズすると write は IOException 例外で停止から抜ける。

* [コード例１](../../commits/d67b8aa3d0b19f82df7f6db15d2766bffda293aa)
* [コード例２](../../commits/cc84e72617c422633ba9c7717ff10f20a9a86d7d)

### ノンブロッキングモード（NIO）

write処理まで含めてタイムアウト値を制御するには、ノンブロッキングモードのソケットを使う必要がある。ノンブロッキングモードのソケットは java.nio パッケージにある。ノンブロッキングモードでは Socket の代わりに SocketChannel、ServerSocket の代わりに ServerSocketChannel を使う。
チャネルオブジェクトを java.nio.channels.Selector オブジェクトに登録すると、Selector オブジェクトの select メソッドでチャネルの状態を確認できる。チャネルの状態は以下の4種類がある。

* 受動的ソケットが受け入れ可能（accept）
* 能動的ソケットが接続完了（connect）
* データ受信可能（read）
* データ送信可能（write）

ノンブロッキングモードのソケットストリームのreadやwriteは、ブロックすることがない。ノンブロッキングモードのソケットを使うコードは、Selector の select メソッドで状態を確認してから、可能な操作だけを行う。結果的にブロックしない動作を実現できる。
ノンブロッキングモードのソケットと Selector を組み合わせると、スレッドを使わずに並行処理を行うことができる。 Selector で複数のソケットオブジェクトの状態を同時に走査できるため。適切にコードを書くとネットワークプログラミングをイベントドリブンで記述できる。

select メソッドにはタイムアウト値の設定が可能。なお、データ送信可能の意味は内部的な送信バッファに空きがあることを示しているだけなので、通信相手がデータ受信可能かを示しているわけではない。ブロッキングモード同様、write メソッドによる書き込みは相手側にデータが届いた保証はしない。

[コード例](../../commits/3d8d07896fc5cfe44e47af7d11bb36c39c68a276)

### HTTPクライアント

HTTPは自分でソケットプログラミングをする必要がない。標準クラスの java.net.HttpURLConnection がHTTPクライアントの機能を提供する。

[コード例](../../commits/8b376db69e157e721620fdcfab3ec6c11385e605)

HTTPの実装に関して、HTTP1.1をまじめに実装するとContent-Lengthヘッダを解釈してデータ長を知る必要がある。ファイルと違い、TCP/IPのデータ受信には終端という概念がないため。読み取るデータがない時、全てを受信し終わったのか、次のデータが届いていないのかを区別できないため。
データの終端を定義するのはTCP/IPより上のアプリプロトコルの責任。一般に終端定義には3つの手法が存在する。

* データ長を送る手法
    * Content-Lengthでデータ長を送るHTTPなどが代表的
* 終端を示す文字や文字列を定義する手法
    * SMTPなどがこれに相当する
* データを受信し終わるとソケットをクローズして終端を示す手法
    * HTTP1.0で使う手法

### 並行処理

ServerSocket オブジェクトの accept メソッドは、接続を確立すると受け入れソケットを生成して返す。受け入れソケット生成後も待ち受けソケットオブジェクトは残る。
ServerSocket オブジェクトに対して accept メソッドを再び呼ぶと、次の新しい通信相手からの接続を受け入れることができる。次のような構成のサーバプログラムを作ると、次々に新しいクライアントからの接続を受け入れることができる。

```
#!java

// 逐次処理のサーバ
ServerSocket ss = new ServerSocket(LISTEN_PORT); // 待ち受けソケット
while (true) {
	// 新しい接続を開始
	Socket s = ss.accept(); // 受け入れソケット取得
	// 受け入れソケットを使い、クライアントと通信
	s.close(); // 受け入れソケットをクローズ
}
```

逐次処理のサーバでは、1つのクライアントプログラムと通信している間、新しい接続を受け入れることができない。次の接続を受け入れるには accept メソッドを呼ぶ必要があるため。
一般的なサーバプログラムでは、複数のクライアントからの接続を受けつけ、かつ複数のクライアントと通信を同時処理する必要がある。このような並行処理を行う1つの方法がスレッドを使う手法。
スレッドを使う並行処理のサーバの構造は次のようになる。

```
#!java

// 並行処理のサーバ
ServerSocket ss = new ServerSocket(LISTEN_PORT); // 待ち受けソケット
while (true) {
	// 新しい接続を開始
	Socket s = ss.accept(); // 受け入れソケット取得
	// クライアントと通信する別スレッドを生成（受け入れソケットを渡す）
}
```

### ネットワークインターフェース

自分自身（ローカル）のIPアドレスを取得するには java.net.NetworkInterface クラスを使う。
複数のローカルIPアドレスがあるのが普通なので、IPアドレスの取得メソッドはコレクションを返す。

[コード例](../../commits/3cfbe2ed59a46fd385ce1ceddf0cdb4cffa54853)

## スレッド

### スレッドとは

* 1つのプログラムの実行状態。マルチスレッド化したプログラムは、このような実行状態を複数持つ。
* 各スレッドは他スレッドと独立した実行状態。
    * すべてのスレッドはそれぞれに独自のコールチェインを持つ。
* スレッドはタイムスライスでスレッドの実行を切り替えられる。
    * OSレベルで複数のプロセスの実行を短時間で切り替えて、同時に走るように見えることと同じ話。
* スレッドの実行の切り替わりは強制的に働く。実行中のスレッドから見ると、実行中に突然割りこまれて実行が停止し、かつ突然実行が再開する。これを専門的にはプリエンプション（横取り）と呼ぶ。しかし、停止中にコールチェインが変化することはない。再開後も同じコード箇所から実行を再開する。

### スレッドと排他制御

* 複数のスレッド間で、何が共有されて何が共有されないのかを知ることが重要。
    * 共有されたデータに思わぬ不整合が生じることがあるから
* スレッドの横取りはどこでも起きると考えること。
    * 横取りが起きないことが保証されている操作を専門的には「アトミックな操作」と呼ぶ。Javaでアトミックな操作は僅かしかない。
* int型のフィールドを複数のスレッドが共有（同じフィールドを参照）しているとき、インクリメント演算子（++）を同時に実行すると、最悪のタイミングでは正しくインクリメントされないことがある。この最悪のタイミングはいつか必ず起きる。

以下のものは個々のスレッドが独立して保持する。つまりスレッド間で共有されることがない。

* メソッドのコールチェイン
    * お互いのスレッドは、相手のスレッドがどんなコールチェインかを知ることはない。（調べようと思えば可能）
* メソッドのパラメータ変数の「**値**」
* メソッドのローカル変数の「**値**」
    * ローカル変数やパラメータ変数がどんな値かを知る手段はない。
    * 変数が参照型変数の場合、変数が参照するオブジェクトはスレッド間で共有される可能性がある。
	    * ローカル変数とパラメータ変数の「**値の独立性**」は変わらないが、メソッド内でフィールド変数を参照するときに、複数のスレッドが同じオブジェクトを参照している場合、スレッド横取りで値が不正になる問題が起こりうる。
* これを防ぐために、Javaはロックという仕組みを用意している。
    * 共有するモノの不整合を防ぐことを同期処理や排他制御と呼ぶ。

### スレッド作成

* java.lang.Thread クラスでスレッドを作成できる。
    * start メソッドを呼ぶと新しいスレッドが作られる。
    * Thread オブジェクトは start メソッドを呼ぶと、内部で run メソッドを呼ぶようになっており、Thread クラスの run メソッドは（ほぼ）空。通常は、Thread クラスを拡張したクラスを自作して、run メソッドを独自に定義する。

```
#!java

class MyThread extends Thread {
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(i);
		}
	}
	public static void main(String[] args) {
		Thread thread = new MyThread();
		thread.start();
	}
}
```

[コード例](../../commits/8d2385d7bbd5358acdd642139fac719afcab502b)

* 便宜上、最初から存在して main メソッドから実行開始するスレッドをメインメソッドと呼ぶ。最初に存在する以外の特別さはなく、メインスレッドが main メソッドを抜けても、サブスレッドが残っていればプログラムはそのまま走り続ける。
* OSから見ると、メインスレッドが残っているプログラムもサブスレッドが残っているプログラムも区別はない。
    * run メソッドのようなスレッドが最初に実行をはじめるメソッドを「**エントリポイント**」と呼ぶ。
        * メインスレッドは単にエントリポイントが main メソッドであるだけのスレッド。

### スレッドと Runnable インタフェース

Thread クラスの run メソッドのデフォルト実装は「*ほぼ空*」と表現したが、実際は空ではなく、Thread クラスのコンストラクタに渡された Runnable オブジェクトの run メソッドを実行する。この実装の意味するところは、 Runnable インタフェースを実装した独自クラスを定義して、 Thread オブジェクト作成時に Runnable オブジェクトとして渡すと、 Runnable オブジェクトの run メソッドを呼んでくれるということ。
いわゆるデザインパターンでのストラテジパターン相当。

[コード例](../../commits/d743c8590482bfe6ef7787bb5cd30dd40676a566)

### Thread クラスの拡張と Runnable インタフェースの実装のどちらを使うべきか

よく問われる質問で、

* 拡張による継承と移譲のどちらがいいか
* テンプレートメソッドパターンとストラテジパターンのどちらがいいか

に置き換えてもいいが、最終的には宗教論争で、どちらか一方が決定的に間違っているとは言えない。しかし、多少の私見も交えるなら、Runnable インタフェースを実装したクラスへの移譲スタイルに軍配を上げる。理由は以下で、

* 継承よりも移譲のほうがクラス間の依存性が弱まるから（独立性が高まる）
* エントリポイントとしての機能（Runnable インタフェースの責務）とスレッド生成の機能（Thread クラスの責務）を分離できるから

Javaの中で、スレッド生成に関わるクラスは Thread クラスだけであり、 Runnable インタフェースおよび Runnable インタフェースを実装したクラスは、本質的にはスレッドとは無関係。
Runnable インタフェースはエントリポイントを提供する機能のインタフェース。Thread クラスと一緒に使うと、エントリポイントはスレッドのエントリポイントになるが、エントリポイントとしての機能はスレッドと独立したもの。その証拠に、 Runnable インタフェースが提供するエントリポイントは、マルチスレッドではない独自のマルチタスク処理（非同期のイベントディスパッチ処理）のエントリポイントにも使える。

### スレッドプール

多数のスレッドを作成するプログラムでは、スレッド生成の時間が実行性能に影響を与えることがある。性能を上げるために、スレッドを毎回作成せずに1度作成したスレッドを使いまわす手法がある。作成したスレッドを待機させて（プールして）、必要に応じてスレッドを取り出してタスク（Runnable オブジェクト）を割り当てる。タスクが終わったスレッドを再びプールに戻す。このようなプログラミングモデルを「**スレッドプール**」と呼ぶ。
スレッドプールを自分で実装することもできるが、標準ライブラリにスレッドプールのための仕組みがある。 java.util.concurrent パッケージにある。
スレッドプールは java.util.concurrent.Executors のクラスメソッドで作成できる。

|メソッド名|説明|
|----------|----|
|newFixedThreadPool|指定した数のスレッドを常時保持するスレッドプールを作成。タスクは空いているスレッドに割り当てられる。|
|newCachedThreadPool|タスクを割り当てるたびに新しいスレッドを作成して、しばらくスレッドを使いまわす。一定期間使われないスレッドは消滅する。|
|newScheduledThreadPool|タスクを一定時間ごとに実行するスレッドを持つスレッドプールを作成|
|newSingleThreadExecutor|1つのスレッドを使いまわすスレッドプールを作成。スレッドに割り当てたタスクは順々に処理される|

これらのクラスメソッドは、ExecutorService オブジェクトを返す。ExecutorService オブジェクトはスレッドプールを管理するオブジェクト。ExecutorService は様々なモードのスレッドプールに対して統一的なインタフェース。

[コード例](../../commits/67abffd5e1298eb71586b6a36be157f6b27753a8)

スレッド作成はスレッドプール内に隠蔽されるので気にする必要がなくなる。自分でスレッドを作成するコードと殆ど変わらない手間でスレッドプールを使うコードが書ける。多くの場合、スレッドと Runnable オブジェクトの対応を正確に管理する必要はない。スレッドとタスクの割り当てを隠蔽できる。

### Callable インタフェース

Runnable オブジェクトの run メソッドは値を返せない。すまりスレッドは実行後に値を返すことができないが、代わりに Callble インタフェースを使うと、スレッドは値を返すことができる。

[コード例](../../commits/5258883e1a55ac7699e231fa4eccfc2372cda6c7)

### 並行処理のサーバ

ストリームの章で実装した並行処理サーバをスレッドプールで書いた例は以下になる。

[コード例](../../commits/248c8746a17ca538975d412c13cba3d870bd01f3)

ワーカースレッドの間に共有するリソースがない場合、コードが単純になり見通しの良い構造になる。

### 同期処理（排他制御）

Java の同期処理の基本は synchronized メソッドと synchronized 文。同じ予約語 synchronized を使う。構文は異なるが原理は同じ。
次の前提がある。

* すべての Java のオブジェクトはそれぞれが独立したロックを持つ
* 全てのクラスには対応する Class オブジェクトがあり、Class オブジェクトもそれぞれに独立したロックを持つ

### モニタロック

すべての Java オブジェクトと Java のクラスには、それぞれに1対1に対応したロックが存在する。このロックを便宜上モニタロックと呼ぶ。synchronized 構文はモニタロックの1つを獲得する。モニタロック獲得には次の3つのパターンがある。

* インスタンスメソッドを synchronized メソッドにすると、対象オブジェクト（レシーバオブジェクト）のモニタロックを獲得
* クラスメソッドを synchronized メソッドにすると、対象クラスのモニタロックを獲得
* synchronized 文は指定したオブジェクトもしくはクラスのモニタロックを獲得

### synchronized メソッド

synchronzied メソッドは次のようにメソッドの修飾子に synchronized を書く。

```
#!java

// synchronized メソッドの例
public synchronized void increment() {
	count++;
}

// 呼び出し側
obj.increment();
```

synchronized メソッド呼び出し時に自動的にレシーバオブジェクト（例ではobj変数が参照するオブジェクト）のモニタロックを獲得する。synchronized メソッド内から別のメソッドを呼び出してもモニタロックを獲得したまま。synchronized メソッドを抜けるときに自動的にモニタロックを解放する。メソッドを例外で抜けた場合もモニタロックを解放する。
クラスメソッドの synchronized メソッドも同じ構文。

```
#!java

// synchronized クラスメソッドの例
public static synchronized void increment() {
	count++;
}

// 呼び出し側
MyClass.increment();
```

synchronized クラスメソッドの場合の獲得するモニタロックはクラスのモニタロック。メソッド呼び出し時に自動で獲得して、メソッドを抜けると自動で解放する原則はインスタンスメソッドと同じで、例外で抜けた場合もモニタロックを解放する。

### synchronized 文

synchronized 文は次のように括弧内にモニタロックを獲得するオブジェクト参照を書き、ブロックを続ける。

```
#!java

// synchronized 文の例
public void increment() {
	synchronized(this) {
		count++;
	}
}
```

synchronized のブロックに入った時にモニタロックを獲得して、抜けるときに解放する。例外でブロックを抜けた場合もモニタロックを解放する。
this変数はレシーバオブジェクトを参照するので、synchronized(this)で獲得するモニタロックはsynchronized メソッド（インスタンスメソッド）で獲得するモニタロックと同じ。synchronized 文の方がsynchronized メソッドよりも小さな範囲で排他制御ができる。一般論として、ロックの範囲は可能な限り小さくしたほうが効率的。synchronized 文には任意のオブジェクト参照を指定できるので、synchronized メソッドよりも自由度が高い記述ができる。
synchronized クラスメソッドで獲得するモニタロックはクラスと1対1に対応するClassオブジェクトのモニタロックだった。synchronized クラスメソッドと等価なコードをsynchronized 文で書くには次のようにクラスリテラルを使う。

```
#!java

// クラスのモニタロックを使うsynchronized 文の例
public static void increment() {
	synchronized(MyClass.class) {
		count++;
	}
}
```

synchronized メソッドと synchronized 文の違いは、synchronized 文がモニタロックの対象オブジェクトを明示することだけ。
同じモニタロックを使う synchronized メソッド及び synchronized 文は、他のスレッドがそのモニタロックを獲得中はモニタロックが開放されるまで待機する。同じスレッドは同じモニタロックを繰り返し獲得可能。つまりモニタロックを獲得した synchronized ブロック内で同じモニタロックを獲得する際に待機しないので、 synchronized メソッドの再帰呼び出しは問題なく動作する。

### synchronized 命令がない場合の問題

[コード例](../../commits/41553a3e8e5daabb289eb65d85331b50cfa24329)

2つのスレッド（MyWorkerオブジェクト）が1つの MyCounter オブジェクトを共有していて、2つのスレッドが同時に increment メソッドを呼ぶと、countフィールド変数に対して同時に++演算子を呼ぶ。
++演算子は一見アトミックに見えるがアトミックではない。加算するために次の3つのステップが必要で、１と３の間に別のスレッドに割り込まれる可能性がある。

1. 現在の値の読み出し
2. 加算
3. 加算結果への代入（書き出し）

int型変数への読み書きはアトミックであることが保証されているが、これは１や３のそれぞれの操作がアトミックであることを意味するだけで、１と３の間に割り込まれないことは意味しない。結局、このコードの変数 count は排他制御できていない。

MyCounter に適切な synchronized 命令を追加する方法は様々ある。もっとも素直な方法は次のように increment メソッドを synchronized メソッドにする方法。increment メソッド内に synchronized 文を書く方法もある。

```
#!java

// synchronized メソッドの例
public synchronized void increment() {
	count++;
}
// synchronized 文の例
public void increment() {
	synchronized(this) {
		count++;
	}
}
```

### モニタロックの選択

synchronized 文のモニタロック対象オブジェクトは色々と選択可能。レシーバオブジェクト（thisの参照オブジェクト）を使うこともできる。レシーバオブジェクトのモニタロックを使うなら synchronized メソッドのほうが素直。
任意のオブジェクトのモニタロックを使うこともできるので、次のようにモニタロック専用のオブジェクトを使う方法も可能。モニタロック専用のオブジェクトのクラスはなんでも使えるが、通常は Object クラスを使う。（ロック専用オブジェクトを参照する変数名には lock や mutex を使う。mutex は mutual exclusion の略で相互排他という意味）

```
#!java

private Object lock = new Object();
public void increment() {
	synchronized(lock) {
		count++;
	}
}
```

クラスのモニタロックを使うことも可能。

```
#!java

public void increment() {
	synchronized(MyCounter.class) {
		count++;
	}
}
```

MyCounter の場合、クラスのモニタロックの利用は推奨しない。なぜならクラスのモニタロックはオブジェクトのモニタロックよりも共有の範囲が広いため。
MyCounter クラスに synchronized クラスメソッドがあると、そのメソッドとモニタロックを共有することになる。モニタロックを共有する synchronized 命令が多ければ多いほど、モニタロック獲得街の待機時間が長くなる可能性がある。モニタロック獲得待ち時間はプログラムのパフォーマンスに影響する。

### コレクションの同期処理

操作対象のオブジェクトを synchronized 文に指定する方法もよく使う。通常のコレクションオブジェクトは内部に同期処理を持たないため、もし複数スレッドで同時にコレクションオブジェクトを変更するのであれば同期処理が必要。更新処理と読み取り処理が同時に走る可能性があれば、読み取り処理（イテレータによる読み取りも含む）にも同期処理が必要。

```
#!java

// 対象オブジェクトをモニタロックに使う書き方
// List<String> list; を複数スレッドで変更する場合のコード
synchronized(list) {
	list.add("foo");
}

// 更新以外の処理にも同期が必要（更新処理が同時に走る可能性があれば）
String s;
synchronized(list) {
	s = list.get(0);
}
```

コレクションオブジェクトは、Collections クラスで同期オブジェクトに変換できる。同期コレクションオブジェクトは内部で同期処理をするので、外部での同期処理は不要。
```
#!java

// List<String> list を同期リストオブジェクトに変換
List<String> slist = Collections.synchronizedList(list);
```

同期コレクションオブジェクトで外部の同期を完全になくせると考えるのは間違い。たとえば次のコードの List オブジェクトが同期コレクションオブジェクトだとする。

```
#!java

// 同期コレクションオブジェクトでも外部同期が必要な例
// List<String> list
// String s
if (!list.contains(s)) {
	list.add(s);
}
```

contains メソッドと add メソッドのそれぞれは、別のスレッドに割り込まれない。しかし、contains メソッドの呼び出し後、add メソッドを呼び出す前に別のスレッドに割り込まれる可能性はある。コードの意図が List オブジェクトに重複要素を許可しないことであれば、処理全体を synchronized 領域に入れて同期する必要がある。

### 同期処理の注意点

MyCounter に話を戻して、仮に MyCounter クラスの count フィールドの型が Integer だとする。
対象オブジェクトをモニタロックに使ったとする。残念ながら、次のコードは致命的なバグ。

```
#!java

// 致命的なバグ（ Integer が不変クラスであることに注意）
public class MyCounter {
	private Integer count = 0;
	public void increment() {
		synchronized(count) {
			count++;
		}
	}
	// 省略
}
```

Integer クラスが不変クラスであることを思い出すこと。count++ は Integer オブジェクト自体の持つ値の変更ではなく、新しい Integer オブジェクトを生成する。このため、synchronized 文が異なるモニタロックを使うことになる。
呼び出し側で同期処理することも1つの解。

```
#!java

// synchronized メソッドの例
class MyWorker implements Runnable {
	// 省略
	@Override
	public void run() {
		synchronized(counter) {
			for (int i = 0; i < LOOP_NUM; i++) {
				counter.increment();
			}
		}
	}
}
```

synchronized 文をループ内に書くとループ回数が多い場合に実行性能が悪くなることに注意すること。ロックの範囲（ロックの粒度ともいう）を小さくすることは、一般的に効率を高める。なぜならロックしている時間が短ければ、それだけロックを待つスレッドの待機時間が短くなるため。
しかし、ロックの粒度を小さくするとロック処理（獲得と解放）の回数が増える傾向にある。ロック処理の回数が増えると相対的に実行速度が遅くなる。ロックの粒度に関するこのバランスは難しい問題で、明確な解はない。

呼び出し側での同期の例だが、次のコードは致命的なバグ。

```
#!java

// 致命的なバグ（呼び出し側で同期）
class MyWorker implements Runnable {
	// 省略
	@Override
	public void run() {
		synchronized(this) {
			for (int i = 0; i < LOOP_NUM; i++) {
				counter.increment();
			}
		}
	}
}
```

this変数が参照するのは MyWorker オブジェクト。 MyWorker オブジェクトはスレッドごとに存在するオブジェクト。2つのスレッドで同期をとっているつもりが、お互いが異なるモニタロックを使うことになる。このコードは何も守れていない。
なお呼び出し側で使うモニタロックとして MyWorker.class を指定すると正しく動作するが、MyCounter.class と同じ理由で推奨しない。
synchronized 命令を使う時は、何を同期しているかに気を払うこと。形式的に synchronized 命令を使い、何も守れていないバグはしばしば見られる。

### 構文による利点

最後に同期処理を構文で行うことの利点と弱点を記述する。

* 構文による利点
    * ロック解放忘れが原理上起こらない
    * 利用が簡単
* 構文による弱点
    * メソッドやクラスをまたがるロックができない
    * ロック可能かを事前チェックできない
    * 何をロックしているかわかっていない開発者でも使えてしまう

### Java のメモリモデル

Java は、スレッドがオブジェクトを参照する時、オブジェクトのフィールドの値を個々のスレッドが独自に保持（キャッシュ）することを認めている。これは、スレッドごとにコールチェインを持ち、ローカル変数やパラメータ変数を独立して持つこととはまったく異なる話。コールチェインは本質的にスレッドごとに独立している。
一方、オブジェクトのフィールド値を独立して保持できるのは単なる効率のため。
効率のために個々のスレッドがフィールド値をキャッシュすることで次のような問題が起きることもある。あるスレッドがオブジェクトのフィールド値を変更したとする。他のスレッドで同じオブジェクトの同じフィールド値を読みだした時、古い値を読み出す可能性がある。本物のフィールド値と個々のスレッドが独自にキャッシュする値がずれている限り、この危険はいつでも存在する。
危険を回避するためには、個々のスレッドのキャッシュの変更を本物のフィールド値に書き戻すタイミングと、本物のフィールド値をキャッシュに読み込むタイミングを制御する必要がある。この制御は2つの方法で行う。

* synchronized 命令
* volatile 修飾子

### synchronized 命令

1つめの方法は既に説明した synchronized 命令。
synchronized 領域の中でアクセスするフィールド値は、本物の値をキャッシュに読み込むことが保証されている。そして synchronized 領域の中で書き換えたフィールド値は、synchronized 領域を抜けた時にキャッシュから本物の値へ書き戻すことを保証している。
synchronized 命令とキャッシュの動作は巧妙で、共有オブジェクトのフィールドを変更する場合、同期処理が必須。synchronized 命令の同期処理のついでにキャッシュの誤動作の回避も行えない。一見、悩ましく見えるフィールド値キャッシュの問題は、ほとんどの場合、synchronized 命令で自動的に解決する。
しかし、単にフィールドに値を代入する1行だけの処理であれば、通常 synchronized 命令は不要。このような場合は、synchronized 命令の代わりに volatile 修飾子を使うことで効率的にキャッシュの問題を解消できる。

### volatile 修飾子

2つ目の方法は volatile 修飾子を使う。次のようにフィールド変数の修飾子に使う。

```
#!java

// volatile 修飾子の例
private volatile String s;
private static volatile String s;
```

volatile 修飾子をつけたフィールド変数の値の変更は本物の値に書き戻されることが保証される。また volatile 修飾子のフィールド値の読み込みは本物の値を読むことを保証する。
volatile 修飾子のもう1つの効用に、long 型と double 型の変数の読み書きをアトミックにする作用がある。Java の言語仕様は、long と double 以外の型の変数の代入がアトミックであることを保証している。つまり int 型変数や参照型変数への代入操作はアトミック。代入がアトミックであるとは次のような意味。
例えば int 型変数であれば代入で右辺から左辺に32ビット分のデータの移動がある。この32ビットのデータの移動の最中に他のスレッドに割り込まれることはないという意味。
一方、long 型と double 型の代入操作のアトミック性は保証している。これら64ビットのデータを移動する間に他のスレッドに割り込まれ、前半32ビットと後半32ビットがそれぞれ別のスレッドの代入結果になることがありえる。この64ビットデータは当然むちゃくちゃな値。
synchronized 命令で排他制御するのも1つの回避策だが、代入1つに大げさすぎる。この場合、volatile 修飾子をつけるとアトミックな代入が可能になる。
volatile 修飾子が synchronized 命令の代用になると誤解しないこと。後述する「 *アトミック処理* 」の中で volatile 修飾子が同期処理の大体にならない具体例を説明する。

### 明示的なロック

synchronized 命令を使う方法は Java の言語仕様で文法的に決まった同期手法。簡易な記法で同期処理をサポートした利点の反面、自由度の点で失った部分がある。これを補完するために java.util. concurrent.locks パッケージがロック用のクラスとインタフェースを提供する。
Lock はロック用のインタフェース。実装クラスには ReentrantLock がある。ロック用クラスの利点は次の通り。

* メソッドやクラスをまたがるロックが可能
* ロック可能かを事前チェック可能

Lock オブジェクトは lock メソッドでロックを獲得して、 unlock メソッドでロックを解放する。あるスレッドがロックを獲得中は、他のスレッドがロックを獲得しようとしても待機する。unlock 忘れは致命的なバグなので、次のように finally 節に書くことを推奨する。

```
#!java

// Lock lock;
try {
	lock.lock();
	// 動機が必要な処理
} finally {
	lock.unlock();
}
```

ReadWriteLock は2つのモードを持つロック用インタフェース。writeLock メソッドは書き込み用ロックで、他のスレッドの同時実行を許さない。
readLock は読み込み用ロックで、他のスレッドの読み込みの同時実行を許すが、書き込みは締めだす。
ReadWriteLockは、書き込みを1つのスレッドだけ同時書き込みを複数スレッドに許す、という用途に使える。読み込み処理が多い場合、スレッドの待機が減り、実行性能が上がる。

### アトミック処理

int 型変数 count を複数スレッドで同時に++演算子で加算したとする。
既に説明したように++演算子はアトミックではない。

[コード例](../../commits/82f6e5a72119bda0b46034e2faa35d53b9e4db28)

count変数にvolatile修飾子をつけても排他制御はできない。volatile修飾子により、片方のスレッドでのcount変数の変更を別スレッドが読むことを保証する。しかし、++演算子の読み出しと書き出しの間に別スレッドが割り込む問題は解消していないため。
正しく排他制御するには++式を synchronized ブロックで囲む。synchronzied 命令をループの中に置くか外に置くかで実行速度に有意な差が生じる。
ループの回る回数が多い場合、ループ内に synchronized 命令を書くと非常に遅くなる。下記に示す結果だけを見ると synchronized 命令を常にループの外に書きたくなるかもしれない。しかし、ループ中ずっと同じモニタロックを使う他スレッドを待たせるのでプログラム全体の並行性を落とす危険がある。

* [コード例](../../commits/9efc496553f1f9bb496b54e8f0a8f3e6a6ff5891)
* [コード例](../../commits/37853c99d6dd6a1eebe1303494da25637fd0ef3c)

java.util.concurrent.atomic パッケージはロックを使わない排他制御機能を提供する。この機能をアトミック処理と呼ぶ。アトミック処理の基本はCAS（Compare And Swap : キャス）と呼ぶ操作で、CASは変数の値の比較と代入をアトミック（別スレッドに途中で割り込まれない）に行う。（CPUのハードウェア命令レベルでアトミックにCASを実行する。CPUがCAS命令をサポートしていない場合、ソフトウェア的にロックを使ってエミュレートする）
CASをアトミックにするだけで、変数の加算や減算をアトミック減算にできる。
atomicパッケージを使って書き換えた例を以下に示す。

[コード例](../../commits/b90e83324e1dd678037cd1bf15ab2dfd0a67ad18)

アトミック処理を使うコードは速度劣化が殆ど無い。

### 通知

排他制御以外の同期処理に通知処理がある。通知処理は、ある条件が成立するまでスレッド群を待機させ、条件成立後に待機スレッド群を起こす機能。通知処理はスレッドの実行順序を制御するために活用できる。
複数のスレッドを使うプログラムでは、あるスレッドが別のスレッドの仕事の完了を待つ局面がよくある。synchronized 命令による同期処理だけでは、ある条件が成立するまでスレッドを停止する処理が書きづらいが、通知を使うと簡易に記述できる。
通知処理では、条件が成立するまで待つスレッドと、条件を成立させ起こすスレッドが存在する。待機に使うメソッドは Object クラスの wait メソッド。起こすために使うメソッドは Object クラスの notify および notifyAll メソッド。 notifyAll メソッドは待機中スレッド全てを起こす。 notify メソッドは待機中スレッドのうち1つだけを起こす。どのスレッドを起こすかを制御する手段はない。wait にはタイムアウト値を設定できるメソッドもある。

### 通知処理の構造

通知処理は内部的にモニタロックを使う。以下の例ではモニタロックの対象オブジェクトを targetObj で示す。待つ側の処理と起こす側の処理の構造は明確に決まっている。
wait 及び notify が同じモニタロックを獲得できるのであれば、synchronized 文の代わりにsynchronized メソッドでも構わない。

```
#!java

// 待つ側の処理
synchronized(targetObj) {
	while (!条件) {
		targetObj.wait();
	}
	// 条件が成立した時の処理
}

// 起こす側の処理
synchronized(targetObj) {
	// 条件を成立させる処理
	targetObj.notifyAll();
}
```

待つ側の処理に入ったスレッドは wait メソッドの呼び出しで停止する。別のスレッドが同じオブジェクト（targetObj）に対して notify メソッドもしくは notifyAll メソッドを呼ぶまで停止する。タイムアウト値の指定がある場合、タイムアウト値の時間が経過すると wait メソッドから返る。wait メソッド呼び出しを while ループで囲むことは必須。条件が成立しなくても wait メソッドが返ることがあるため。
条件が成立しない限り回り続けるループと wait メソッド呼び出しの組み合わせで、ループを抜けた後に条件成立時にすべき処理を行うことができる。もし、wait メソッドがなければ、条件判定のループが回り続け、CPUが動きっぱなしになる。wait メソッドで待機していれば、このスレッドはCPUを使わない。待機して起こされるのを待つだけ。
一見、2つの処理は同じモニタロックを獲得するコードなので、2つのコードは同時に実行できないように見える。からくりは wait メソッドが内部で暗黙にモニタロックを解放することにある。
待つ側のスレッドが先に synchronized 領域に入ったとする。待つ側のスレッドが targetObj のモニタロックを獲得するので、別スレッドが起こす側の処理に入ってもモニタロック獲得待ちで停止する。待つ側のスレッドが targetObj の wait メソッドを呼ぶと、内部で targetObj のモニタロックを解放する。
別の見方をすると、これが wait メソッド呼び出しを synchronized 領域内で行う必要性の理由である。wait メソッド内部でモニタロックが開放されたので、起こす側のスレッドはsynchronized 領域に入ることができる。起こす側のスレッドがtargetObj の notifyALl メソッドを呼ぶと、待機スレッドが起こされる。待機スレッドは wait メソッド内で暗黙に targetObj のモニタロックを獲得しようとする。しかし、起こす側のスレッドがモニタロック獲得中なのですぐには獲得できずにブロックする。起こす側のスレッドが synchronized 領域を抜けてモニタロックを開放すると、大気スレッドがモニタロックを獲得して wait メソッドから返る。
起こす側のスレッドが先に synchronized 領域に入ると、待機中のスレッドがない状態で notifyAll メソッドを呼ぶだけ。notify した状態は記憶されない。別のスレッドが wait すると、新たに起こす処理をするスレッドが現れるまで待機する。

### 通知処理の具体例

待つ側のスレッド（群）が必要なデータを持ち、起こす側が必要なデータを揃える、というのがシナリオ。しばしば待つ側を消費者（consumer）、起こす側を生産者（producer）としてモデル化する。

[コード例](../../commits/5b75d0a990867ba448f74c8f4be22557942e8fa1)

Producer クラスと Consumer クラスのオブジェクトを生成して別々のスレッドで実行する。2つのスレッドはキュー（Queueオブジェクト）を共有する。Producer スレッドはコンソールでユーザ入力を待つ。ユーザ入力があると入力文字列があると入力文字列をキューに追加して、Consumer スレッドを起こす。起こされるまで Consumer スレッドは wait メソッドで待機する。起こされるとキューから文字列を取り出す。

### ディスパッチモデルとタスクキューモデル

MyProduceConsume では待機スレッドが1つだが、複数の待機スレッドで並行処理を行う場合がある。ネットワーク系のサーバプログラムでは、接続を受け付ける1つのマスタースレッドと、実際にデータ送受信をする多数のワーカースレッドで構成することがある。接続を受け入れたマスタースレッドがワーカースレッドに順々にタスクをアサインする。このような構成を「**ディスパッチモデル**」と呼ぶ。
一方、1つのタスクキューを用意して、ワーカースレッドをキューに対して待機させる。マスタースレッドは接続を受け入れるとタスクキューにタスクを押しこんでワーカースレッドを起こす。ワーカースレッドのどれか1つがタスクをキューから取得して、残りのワーカースレッドは再び待機状態に戻る。このようなモデルを「**タスクキューモデル**」と呼ぶ。
ディスパッチモデルよりも細かな制御ができないが、その分コードが簡易になる。タスクキューモデルは、並列処理に有効なモデル。

### デッドロックと検出

2つのスレッドがお互いにロックを待ち合う現象を「**デッドロック**」と呼ぶ。

[コード例](../../commits/f2591e1240dca1a971e8ab0e705f04238ad883fe)

2つのスレッドが2つのリストオブジェクト（list1とlist2）を独立にソートするコード。Collections クラスの synchronizedList クラスメソッドは使わず、ここでは synchronized 文で明示的にロックする。
スレッド t1 は list1 に対する synchronized 文の中で list2 に対する synchronized 文を書いている。スレッド t2 は list2 に対する synchronized 文の中に list1 に対する synchronized 文を書いている。このようにお互いのロックの順序が逆転しているとデッドロックが起きる。逆に言うと、以下の規則を守るとデッドロックを防ぐことができる。

* ロックを入れ子にしない
* 入れ子のロックをする時、ロックの順序が逆にならないようにする

### デッドロックが起きる時

デッドロックは次のように起きる。
スレッド t1 が list1 のモニタロックを獲得した後、list2 のモニタロックを獲得する前にスレッド t2 に切り替わったとする。スレッド t2 が list2 のモニタロックを獲得して list1 のモニタロックを獲得しようとする。
スレッド t1 が list1 のモニタロックを獲得中なので、スレッド t2 はスレッド t1 によるモニタロック解放を待つ。一方、スレッド t1 は list2 のモニタロックを獲得するためにスレッド t2 が解放するのを待つ。お互いが相手のモニタロック解放を待つ。解放待ちは永遠に解決しない。プログラム実行の観点で見ると、2つのスレッドは永遠に停止する。
スレッド切り替えのタイミングに依存するので、デッドロックの発生は確率的（発生が確率的なことは、スレッドの同期に関係する問題に共通する）。MyDeadLock を実行するとデッドロックは起きるかもしれないし、起きないかもしれない。

### デッドロックの監視

デッドロックが発生したことを告げる標準的な仕組みはない。スレッドごとに見ると、待ち状態のロックがデッドロックで永遠に待つロックなのか、待てばいつか解放されるロックなのか区別がつかないため。しかし、デッドロックが発生した時、どのスレッド同士がデッドロック状態かを外部から知ることは可能。
このために標準ツール jconsole コマンドを使う。Java5では、次のように監視対象プログラムの実行時に特別なコマンドラインオプションが必要。Java6以降では必要ありません。

```
// jconsole で監視するための実行方法
Java5
$ java -Dcom.sun.management.jmxremote. MyDeadlock

Java6以降
$ java MyDeadlock
```

デッドロックの疑いがある場合、次のように jconsole コマンドを実行する。監視対象プロセスのプロセスIDがわかる場合、コマンドライン引数で指定できる。プロセスIDを指定しない場合、GUIで監視対象プロセスを選択する。

```
// 引数なしで実行して GUI で対象プロセスを選択もしくはプロセスIDをコマンドライン引数で指定
$ jconsole
```

"Threads"タブを選択して画面下部の"Detect Deadlock"ボタンをクリックします。デッドロックを起こしているスレッドそれぞれのコールチェインを見ることができる。MyDeadlock では Thread オブジェクト生成時の第2引数で"my-thread1"と"my-thread2"としてスレッドに名前をつけている。
スレッド名はプログラム実行に影響はないが、監視時にスレッドを見分けるのに役立つ。

### 同期処理の技法

現場のプログラミングでは、スレッド生成のコードを書く場面は減ってきている。しかし、マルチスレッドで動くプログラムは増えている。どういうことかというと、スレッド生成がフレームワーク内に隠蔽され、フレームワークの上に載ったコードを書く場面が増えてきているから。現場のプログラミングで求められる技術は、スレッドをいかに生成するかではなく、多数のスレッド（マルチスレッド）から呼ばれても問題のないコードを書く技術。
複数のスレッドから呼ばれて問題のないオブジェクトの筆頭は、フィールドを一切持たないクラスのオブジェクト（定数フィールドを除く）。オブジェクトが状態を持たない限り、排他制御は不要。状態を持つクラスと状態を持たないクラスを峻別することは規模の大きなプログラミングでは一般的。
排他制御をなくせる別の策が、状態を持つオブジェクトをスレッドごとに持たせて、スレッド間で共有させない手法。
サーブレットアプリを例にすると、 HttpServletRequest オブジェクトと HttpServerResponse オブジェクトはスレッド間で共有しないことを前提にしている。スレッド間で共有しない方針にすれば、これらのオブジェクトに同期処理は不要。マルチスレッドプログラミングで最も重要なことが、どのオブジェクトが共有されて、どのオブジェクトが共有されないかを知ること。共有されるオブジェクトに同期処理がないことは致命的なバグ。
スレッド間の共有物を減らすことは鉄則だが、完全になくせることは稀。同期処理をする場合、何を守るかを明確にする必要がある。共有物を守るために、スレッドは同じロックを使う必要がある。

[コード例](../../commits/627ad3831a8f8b37652a4ed5c4ffac1e396ef3c9)

MyWrongSync は誤った同期処理。共有物は Worker クラスのクラスフィールド count 。インスタンスメソッド increment を synchronized メソッドにすると、2つのスレッド（Workerオブジェクト）はそれぞれに異なるモニタロックを確保する。
正しく同期処理をするには、Worker.class で Worker クラスの Class オブジェクトのモニタロックを使うこと。これで2つのスレッドは同じロックを獲得する。2つのスレッドが共有するオブジェクトのモニタロックを使うのも手。

最後に、不変オブジェクト。不変オブジェクトは状態が不変なため、そもそも同期処理が不要。

## リフレクション

### リフレクションとは

リフレクションとは、実行中に型情報を取得でき、型そのものを操作対象に出来る仕組みのこと。この文脈での型は、

* クラス（enum型含む）
* インタフェース
* 配列型
* プリミティブ型
* void
* パッケージ
* アノテーション

が対象になる。

型をオブジェクトのように扱うことで次のようなことができる。

* クラスのロード
* クラスの型階層の列挙
* ひな形（クラスや配列）からオブジェクト生成
* 型（クラス、インタフェース）のメンバ（フィールド定義やメソッド定義など）の型や名前の取得
* レシーバオブジェクトを指定したフィールド値参照、フィールド値変更、メソッド呼び出し

### リフレクションを実現するには

リフレクションを実現する仕掛けは、Class クラス。名前が紛らわしいが、 java.lang.Class という名前のクラス。Class クラスは型情報を保持する。具体的には、特定の型（クラス、インタフェース、配列）についてフィールドの一覧やメソッド一覧を問い合わせることができる。

### Class クラスの役割

Class クラスは、他のクラス同様、型定義とひな形としての役割を持つ。Class クラスをひな形として Class オブジェクトを生成できる。ただし、 new 式で Class オブジェクトは生成できない。 Class オブジェクトはクラスをロードすると自動的に生成される。多くの Class オブジェクトの生成は暗黙に行われる。

ソースコードの中で使われる型（クラスやインタフェース）それぞれに、対応する Class オブジェクトが存在する。型それぞれに個別に Class オブジェクトが存在することの意味は、Stringクラスに対応する Class オブジェクト、StringBuilder クラスに対応する Class オブジェクト、Integer クラスに対応する Class オブジェクトのように、Class オブジェクトが存在することとを意味する。
String クラスをひな形として複数の String オブジェクトが存在するように、 Class クラスをひな形に複数の Class オブジェクトが存在する。Class<String> オブジェクトや Class<StringBuilder> オブジェクトなど。Class クラスはジェネリクス。いくつかの例外を除いて、それぞれの型に対応する Class オブジェクトは1つのみ。Class クラスにも、対応する Class<Class> オブジェクトが存在する。

Java プログラムがあるクラス Foo を使うと、そのプロセスは実行中に自動で Class<Foo> オブジェクトを生成する。Class<Foo> オブジェクトは、クラス Foo のフィールド一覧やメソッド一覧を取得する手段を提供する。

型ごとに Class オブジェクトが1つだけ存在することの例外はクラスローダに関係する。クラスローダとは名前の通りクラスをロードする役目を担うオブジェクトで、Java プロセスは複数のクラスローダを持つことが可能。
Class オブジェクトの参照を取得する手段はいくつか存在する。 Class オブジェクトの参照を得る時、内部的にはクラスローダが保持する Class オブジェクトから検索する。存在すればその Class オブジェクトの参照を返す。存在しない場合、クラスローダが対象クラスをロードして Class オブジェクトを生成する。
クラスローダを明示的に複数保つ方法は後述する。当面、Java プログラムのプロセスにクラスローダは1つと考えておく。（実は起動時点でブートストラップクラスローダとシステムクラスロードの2つのクラスローダが存在するが、通常、気にする必要はない） Class オブジェクトは型ごとに1つずつ存在すると考える。

### Class オブジェクト

Class オブジェクトの参照を取得する方法をいかに示す。

* クラスリテラル
    * 型名に .class を後置する記法。1つのリテラル値として評価され、評価値の型が Class クラス
* Object クラスの getClass メソッド
    * Object クラスのインスタンスメソッド。全てのオブジェクトに対して呼ぶことができ、final修飾子のついたメソッドなのでオーバーライドできない
* Class クラスの forName クラスメソッド
    * 型名を文字列で渡して Class オブジェクトを返す。forName メソッドにクラスローダオブジェクト（java.lang.ClassLoader オブジェクト）を渡すメソッドも存在する。クラスローダを渡さない場合、現在のクラスローダを使う
* その他（Class クラスや ClassLoader クラスのメソッド経由）

[コード例](../../commits/923afb7ca8a48446af5a8ba1c5f1d77916b3b632)

Class 型の変数名には伝統的に clazz をよく使う。class は予約語のため変数名に使えないため。

上記で述べたように、Class クラスはジェネリクス型なので、正しくは

[コード例](../../commits/3a4672e9ce3fb388ec99614d049c17216b78ec0a)

の様に書く。

基本型にも対応する Class オブジェクトが存在する。

[コード例](../../commits/6f8bebf9be54857c6ee89acd1300781d4d60de44)

int 型に対応するオブジェクトの型は概念上は Class<int> だが、ジェネリック型の制約から Class<Integer> になる。
Revision r117 からもわかるように、int に対応する Class<Integer> オブジェクトと、Integer クラスに対応する Class<Integer> オブジェクトは異なるオブジェクト。int に対応する Class<Integer> オブジェクトを Class クラスの forName メソッドで取得する手段は存在しない。

配列型に対応する Class オブジェクトの参照を取得する例は以下。

[コード例](../../commits/aefae742f5a7dd868ba0d465b700ccd228063a66)

配列の要素ごとに異なる Class オブジェクトになる。 forName メソッドに渡す文字列は特殊な規則がある。 forName に渡せる文字列は Class オブジェクトの getName メソッドを呼ぶことで得られる。
int 型配列であれば、int[].class.getName() が "[I" の文字列を返す。この文字列を forName メソッドに渡すと int型配列に対応する Class オブジェクトの参照が得られる。

ジェネリック型はイレイジャにより、要素型が消えるので要素型が異なっても同じ Class オブジェクトになる。 ArrayList を使う例を以下に示す。

[コード例](../../commits/af6117b3871f2a2e0567460065d385843636505b)

クラスリテラルを使う場合、そもそも型名がソースコードに記述されている。 Object クラスの getClass メソッドでは、対象オブジェクトを生成する時点で具象クラスのことを知っている。
この2者と比較すると、Class クラスの forName メソッドは異色。文字列なので、実行時にプロセスの外部から与えることができる。例えば、クラス名をファイルから読んだりユーザに入力させたりできる。これによりソースコード中に記述がないクラスを実行時にロードできる。具体例は後述。

### 型情報の取得

Class オブジェクトから型（クラス、インタフェース、配列型）の情報を取得できる。主なメソッドを分類する。
Class オブジェクトの対象型の種別を判定する代表的なメソッドを示す。

```
#!java

// インタフェース型であれば真を返す
boolean isInterface()

// 配列型であれば真を返す
boolean isArray()

// 基本型であれば真を返す
boolean isPrimitive()

// enum型であれば真を返す
boolean isEnum()
```

クラスやインタフェースのメンバ（構成要素）を取得する代表的なメソッドを示す。Method クラス、 Field クラス、 Constructor クラスの使い方は後述。

```
#!java

// 全ての public フィールド情報を返す（継承したフィールドも含む）
Field[] getFields() throws SecurityException

// 指定した名前の public フィールドを返す（継承したフィールドも含む）
Field[] getField(String name) throws NoSuchFieldException, SecurityException

// 全てのフィールド情報を返す（継承したフィールドを含まない）
Field[] getDeclaredFields() throws SecurityException

// 指定した名前のフィールドを返す（継承したフィールドも含まない）
Field[] getDeclaredField(String name)

// 全ての public メソッド情報を返す（継承したメソッドも含む）
Method[] getMethods() throws SecurityException

// 指定したシグネチャの public メソッド情報を返す（継承したメソッドも含む）
Method getMethod(String name, Class<?>… parameterTypes) throws NoSuchMethodException, SecurityException

// 全てのメソッド情報を返す（継承したメソッドを含まない）
Method[] getDeclaredMethods() throws SecurityException

// 指定したシグネチャのメソッド情報を返す（継承したメソッドを含まない）
Method getDeclaredMethod(String name, Class<?>… parameterTypes) throws NoSuchMethodException, SecurityException

// すべての public コンストラクタ情報を返す
Constructor<?>[] getConstructors() throws SecurityException

// 指定したシグネチャの public コンストラクタを返す
Constructor<T> getConstructor(Class<?>… parameterTypes) throws NoSuchMethodException, SecurityException

// すべてのコンストラクタ情報を返す
Constructor<?>[] getDeclaredConstructors() throws SecurityException

// 指定したシグネチャのコンストラクタを返す
Constructor<T> getDeclaredConstructor(Class<?>… parameterTypes) throws NoSuchMethodException, SecurityException

// ネストした public クラスおよび public インタフェースを返す（継承したクラス、インタフェースも含む）
Class<?>[] getClasses()

// ネストしたクラスおよびインタフェースを返す（継承したクラス、インタフェースを含まない）
Class<?>[] getDeclaredClasses() throws SecurityException
```

インスタンスメンバ（インスタンスフィールドとインスタンスメソッド）とクラスメンバ（クラスフィールドとクラスメソッド）の違いは、Method クラスや Field クラスの getModifiers メソッドの返り値で判定できる。getModifiers メソッドの返り値は java.lang.reflect.Modifier の定数のビット和となる。getModifiers メソッドの返り値に Modifier.STATIC のビットが立っていれば、そのメンバはクラスメンバ。

型階層に関係する情報を取得するメソッドを示す。Object クラス、インタフェース型、基本型に対応する Class オブジェクトは getSuperClass メソッドが null を返す。配列型に対応する Class オブジェクトは getSuperClass が Class<Object> オブジェクトを返す。

```
#!java

// 拡張継承の継承元クラスの Class オブジェクトを返す
Class<? super T> getSuperClass()

// 実装しているインタフェースの Class オブジェクトを返す
Class<?>[] getInterfaces()
```

型階層を表示するコード例を以下に示す。

[コード例](../../commmits/b8ac41c67a2a8575f64f3b4a1fb9e23912902a22)

### オブジェクト生成

リフレクションによるオブジェクト生成には、次の2つの手段がある。

* Class クラスの newInstance メソッド呼び出し
    * 引数なしのコンストラクタを呼び出す
    * 対象クラスが引数なしのコンストラクタを持たない場合、InstantiationException 例外が発生する
* Constructor クラスの newInstance メソッド呼び出し
* 配列オブジェクトの生成は、java.lang.reflect.Array クラスの newInstance クラスメソッドを使う

Class クラスの forName メソッドと組み合わせると、ソースコードに全く記述がない具象クラスのオブジェクトを生成できる。以下は、Constructor クラスの newInstance メソッドを使って、StringBuilder オブジェクトを生成する例。

[コード例](../../commits/cf31ea7faf2ab5721aa729c48714022bc9f07f85)

### メソッド呼び出し

リフレクションによりメソッド呼び出しを行うことができる。java.lang.reflect.Method クラスを使う。
Method オブジェクトに対して invoke メソッドを呼ぶことでメソッド呼び出しができる。
クラスメソッドの場合は、invoke の第1引数は無視される。通常は null を渡す。
以下は、invoke メソッドによるメソッド呼び出しの例。ソースコード中に識別子としての StringBuilder が存在しないことに注意する。StringBuilder に関する情報はすべて文字列なので、実行中にユーザに入力させることもできる。

[コード例](../../commits/a503329dc0c6ffb86b6d24abeffe426b8aa892ac)

### フィールド操作

リフレクションによりフィールドを参照したりフィールドに値を設定できる。java.lang.reflect.Field クラスを使う。
Field クラスの代表的なメソッドの定義は以下。

```
#!java

// フィールドの型を返す
Class<?> getType()

// フィールドの値を返す。第1引数はレシーバオブジェクト
Object get(Object obj) throws IllegalArgumentException, IllegalAccessException

// フィールドに値を設定する。第1引数はレシーバオブジェクト、第2引数は設定値
void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException
```

Method クラス同様、クラスフィールドを操作する場合、レシーバオブジェクトは無視される。
以下は、Field オブジェクトを使ってフィールドを書き換える例。

[コード例](../../commits/bf1198ac7699abdeba0116c6acc6a24207897bbc)

### Java Beans

Java Beans は元々、GUIの部品（コンポーネント）をツールの支援のもとに容易に作成できることを目的とした技術。GUI部品の作成の手間を軽減する技術は Java 以前に先行技術が多数ある。静的な型付け言語では、オブジェクト指向の継承を活用する技術が主流で、動的な型付け言語の中には実行中に型（クラス）を生成する技術もある。
Java は静的型付け言語だが、Beans はリフレクションを前提に動的な型付け言語に近い方向性の技術。Beans は特定のクラスの継承を前提としない。Beans はメソッド名の命名規約を前提にする。
Java の利用用途がGUIプログラムからサーバ用途に広がる中で、Beans は当初の想定（GUIの部品）より広く使われるようになった。当初の Beans を特徴付ける技術要素は以下のようだった。

* リフレクションによる実行時オブジェクト生成を想定した設計
* カスタマイズ機能を想定した設計
* イベント処理
* プロパティ
* 永続化機能

すべての Beans がこの特徴を備えるわけではないが、Beans が最低限持つ特徴は、リフレクションによる実行時オブジェクト生成を想定した設計。
あるクラスが Beans クラスか否かを決定づける要因はクラス自身にはなく、Bean クラスをインスタンス化して、Bean オブジェクトを操作するツールやフレームワークの要請で決まる。一般にこのようなツールやフレームワークを「**Beanコンテナ**」と呼ぶ。
Bean コンテナが Bean オブジェクトの生成を Class クラスの newInstance メソッド（あるいは java.beans.Beans.instantiate）で行う場合、 Bean クラスは引数なしコンストラクタを持つ必要がある。
Beans ではフィールドの代わりにプロパティを持つ。
Beans のプロパティアクセスには次の規則が決まっている。

* プロパティ名が foo の時、プロパティ値を取得するメソッド名は getFoo
* プロパティ名が foo の時、プロパティ値を設定するメソッド名は setFoo

現実の Beans のほとんどはプロパティと1対1に対応するフィールドを持つ（通常、フィールドのアクセス制御は private にする）。しかし、 Beans のプロパティ foo にとっての本質は、 foo という名前のフィールドが存在することではなく、setFoo や getFoo のメソッドが存在すること。

```
#!java

// Bean クラスの例
class MyBean {
	private String name;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
```

### DI（Dependency Injection）

次のクラスを考えてみる。

```
#!java

class StringList {
	private List<String> list;

	public StringList(List<String> list) {
		this.list = list;
	}

	public void append(String s) {
		list.add(s);
	}
	public void dump() {
		for (String s : list) {
			System.out.println(s);
		}
	}
}
```

この StringList クラスを使うにはどこかに次のようなコードが必要。

```
#!java

List<String> list = new ArrayList<String>();
StringList sl = new StringList(list);
```

オブジェクト指向は、機能や役割をクラスに分割する。クラスの分割を進めた先に複雑さが残るのはクラス間の関係性。結果として、オブジェクト指向で作成したプログラムには、上記のようなオブジェクト生成の処理が相対的に増えていく。必要な処理を行うために、オブジェクトの生成が不可欠だから。オブジェクト生成には依存するオブジェクトを事前に生成する必要がある。（上記の例では StringList オブジェクトの前に ArrayList オブジェクトが必要なように）
このように依存関係のあるオブジェクト群の生成処理を総称して、オブジェクト構築処理と呼ぶ。
オブジェクト構築処理は面倒で複雑な作業。このため、オブジェクト構築にまつわる技法が生まれている。デザインパターンの世界で、ファクトリパターンやビルダーパターンなどが有名。

### DIの役割

面倒で複雑な作業は、独立した役割として分離してみる。オブジェクト構築処理を分離する技法の1つがDI（Dependency Injection：依存性注入）。DIエンジンは、オブジェクト構築処理を役割として引き受ける。オブジェクト構築は結果としてオブジェクト間の依存性の解決を行う。このことを外部から依存性を注入（解決）すると称する。
従来のファクトリパターンが個々のクラスごとにオブジェクト生成を隠蔽したのに対し、DIエンジンは依存関係のあるオブジェクト群の構築を一括して隠蔽する。いわば、巨大な汎用ファクトリエンジンになる。オブジェクト構築を引き受けたDIエンジンは同時にオブジェクトのライフサイクル管理を担うこともある。
上記の StringList クラスの依存性を解決する簡易なDIエンジンは以下。

* [コード例](../../commits/b7482b5b3bb53334eaade6cfb31fc1fce34623ea)
* [コード例](../../commits/3e50e26dc186ab6018e70d85f1ec943914c5fde2)

MyDI には"StringList"や"java.util.List"を文字列としてハードコードしている。本物のDIエンジンは特定のクラスのために書かれるものではない。構築すべきオブジェクトの情報を外部ファイルやアノテーションで指定したり、あるいは命名規約で確定したりする。

### クラスローダとホットデプロイ

リフレクションを使うと、実行時に指定したクラスをロードすることができる。1度ロードしたクラスはクラスローダが保持し続ける。このため、繰り返し Class クラスの forName メソッドを呼んでもクラスを再ロードはしない。しかし時には、クラスファイルを書き換え再ロードしたい時がある。たとえば、Webアプリの世界でホットデプロイとして知られる機能などに必要。

Javaのクラスをロードするのはクラスローダ（java.lang.ClassLoader）の役割。普通にJavaプログラムを起動した場合、クラスローダオブジェクトは自動的に作成され、開発者がその存在を気にする必要はない。
独自にクラスローダを作ったり、プログラム起動中に新しいクラスローダオブジェクトを生成することが可能。明示的にクラスローダオブジェクトを生成した場合、生成したクラスローダにクラスをロードさせることができる。クラスのロードはクラスローダごとに行える。クラスローダオブジェクトを明示的に生成することで、クラスの再ロードを実現することができる。

以下に、クラスローダの具体例のコードを示す。

[コード例](../../commits/107b2ebcadf17e7422a4c0e2620e5151d390dd3f)

javax.tools.JavaCompiler を使って、コードの中からソースファイルのコンパイルを行い、クラスローダオブジェクトを作成。
作成したクラスローダを指定してクラスを再ロードする。
コンソールが入力待ちの時に、My.javaを書き換えて再度実行すると、クラスが再ロードされて実行結果が変わる様を確認できるはず。

## アノテーション

### アノテーションとは

アノテーションは、プログラムの構成要素に付与するメタ情報。アノテーションの具体例の1つは、@Overrideなど。文法上、アノテーションは修飾子の1つとして働くが、他の修飾子（publicやfinalなど）と異なり、アノテーションは予約語ではない。クラスやインタフェースのように、開発者自身がアノテーション型を定義する。

アノテーションを修飾子として記述することを「**アノテーションの適用**」と呼ぶ。Overrideアノテーションであればメソッドに適用する。
アノテーションを適用できるプログラム要素をいかに示す。

* 型宣言（クラス、インタフェース、enum、アノテーション）
* フィールド宣言
* メソッド宣言
* パラメータ変数宣言
* コンストラクタ宣言
* ローカル変数宣言
* パッケージ宣言

ソースコード上、修飾子を書ける場所にはアノテーションを書けると理解して問題ない。慣例として、アノテーションを最初の修飾子として書く。

アノテーションには、そのアノテーションを処理するプログラムが必要。誰も処理をしないアノテーションは意味が無い。例えば@Overrideアノテーションなら、コンパイラが読み取ることで意味を持つ。アノテーションは、アノテーションを読み取るツールやフレームワークとセットで存在する。

### アノテーションの応用例

アノテーションの応用例を示す。

* 構文補助
* 宣言的プログラミング

###. 構文補助

構文補助を目的としたアノテーションの代表例は@Override。構文補助のためのアノテーションで、Javaの文法規則の独自拡張に近いことができる。この目的のアノテーションは開発者の自己満足になる傾向が強いため、新規開発は慎重に行うべき。

### 宣言的プログラミング

プログラムを機能や役割で分割するのはプログラミングの王道。部品の独立性が高まっても解決しない問題がある。
部品がどう動くかはコードを見ればわかるが、それを誰が何のために使うのかは部品を見るだけではわからない。皮肉なことに部品の独立性が高まるほど（つまり良いコードになればなるほど）この傾向が強まることもある。
部品自身にその存在理由を陽に記述できる工夫として、アノテーションを活用可能。アノテーションを部品に適用することで、誰にどう使って欲しいかを宣言できる。

プログラミングの歴史の中で、手続きを記述する手続き型プログラミングと別に、「**宣言型プログラミング**」という流れがある。宣言的プログラミングでは、手順ではなく目的を記述する。アノテーションで目的を記述することは、Javaによる宣言型プログラミングの道を開く。Java自体は宣言型言語ではないので、アノテーションを読み取り目的から手順に落としこむフレームワークの存在が不可欠。

### 標準アノテーション

|アノテーション名|説明|
|----------------|----|
|Override|オーバーライドしたメソッドであることを明示|
|Deprecated|非推奨であることを明示|
|SuppressWarnings|コンパイラの警告メッセージを抑制|

### Override

Overrideアノテーションを書く癖をつけておくと、いつか助かる時が来る。騙されたと思って付けておくこと。

### Deprecated

推奨しない対象要素を明示する。メソッドやコンストラクタにつけるのが主だが、型宣言やフィールドにも適用可能。
警告の詳細を表示するには、 `-Xlint:deprecation` オプションをつける。

コンパイルエラーではなく警告なので、クラスファイルは生成される。しかし、よほどの理由がない限り、コードを修正すべき。クラス提供者はメソッドなどを非推奨に変更した場合、修正方法を示す義務がある。
一般に修正方法をjavadocコメントに明記する。

### SuppressWarnings

コンパイラの警告を抑制する。SuppressWarningsに指定できる文字列はjavaコンパイラに依存するので、確認するには `javac -X` の出力の `-Xlint` の行の説明文字列を見るのが汎用度の高い調べ方。

### アノテーション定義

アノテーションは型の1種なので型定義の泉源を持つ。 Override.java や SuppressWarnings.java といったソースファイルが存在する。クラス同様、アノテーション型宣言のファイルもjavacでコンパイルする。

アノテーション型定義に付く**メタアノテーション**として、

* Target
* Retention

の2つがある。

アノテーション型の宣言の構文は次のようになる

```
#!java

[アクセス制御修飾子] @interface アノテーション名 {
	アノテーション要素
}
```

アクセス修飾子はインタフェース宣言に対するアクセス制御と同じ。現実的には多くのアノテーションはpublicになる。

アノテーション名は開発者が自由に付けられる名前。クラス名およびインタフェース名と同じ名前空有間に属する。完全修飾名が一致するクラスやインタフェースが存在する場合、コンパイルエラーになる。

Overrideアノテーションの型宣言には、アノテーション要素がない。アノテーション要素のないアノテーションを**マーカアノテーション**と呼ぶ。

アノテーション要素は、文法上、本体のないメソッド定義。つまりインタフェース宣言の中に書くメソッド定義と同じ。しかし、適用の観点ではアノテーション要素はメソッドよりもフィールドに近い存在。

アノテーション要素名は開発者が自由に付けられる名前。valueという名前には特別な省略記法が用意されており、アノテーション要素が1つの時はvalueという名前にすることを推奨する。

```
#!java

public @interface MyAnnotation {
	String foo();
	int bar();
	Class baz();
}
```

アノテーション要素の型（文法上はメソッドの返り値の型）は次に限定される。

* 基本データ型
* String型
* enum型
* アノテーション型
* Class型
* 上記を要素型とする配列型（配列の配列は不可）

アノテーション要素には次の制約がある。

* パラメータ引数は禁止
* throws節は禁止
* ジェネリックメソッドは禁止

```
#!java

public @interface MyAnnotation {
	Integer foo();	// 返り値の型は決まった型しか許可されない
	int bar(int i);	// パラメータ引数は禁止
	Class baz() throws java.io.IOException;	// 例外のthrows節は禁止
	<T> String foobar();	// ジェネリックメソッドは禁止
```

### アノテーションの適用

構文上、アノテーションの適用は修飾子になる。
マーカアノテーションの適用には次のように括弧をつけることも可能。一般的にはマーカアノテーションの場合、括弧を省略する。

```
#!java

// マーカアノテーションの適用例
@Override() -> 通常は @Override のみ
public String doJob(String in) {}
```

```
#!java

// アノテーションの適用例
@MyAnnotation(foo = "abc", bar = 42, baz = String.class)
public String doJob(String in) {}
```

指定する値の型は、アノテーション要素の型（見かけ上はメソッドの返り値の型）と一致させる。直感的には、アノテーションを適用することでアノテーション型のインスタンスを生成することになる。上記の例で言えば、値が"abc"や42やString.classのフィールド値を持つアノテーションオブジェクトを生成したことに相当する。アノテーションのインスタンスはオブジェクトではないので、厳密にはこの説明は正しくないが、直感的な理解には問題ない。

アノテーション要素の名前がvalueの時のみ、value = を省略可能。アノテーション要素valueのある具体例としてSuppressWarningがある。省略記法と省略しない記法の両方を示す。要素型が配列型の場合、次のように中括弧で値を指定する。

```
#!java

// value=を省略した記法
@SuppressWarnings({"deprecation", "divzero"})
public static void main(String[] args) {}

// value=を省略しない記法
@SuppressWarnings(value = {"deprecation", "divzero"})
public static void main(String[] args) {}
```

アノテーション要素の型が配列型でも、指定する値が1つであれば中括弧を省略可能。

```
#!java

// value=と中括弧を省略した記法
@SuppressWarnings("deprecation")
public static void main(String[] args) {}
```

アノテーション適用時にすべてのアノテーション要素の値を指定する必要がある。

アノテーション型宣言時に、アノテーション要素のデフォルト値の指定が可能。MyAnnotationのアノテーション型にデフォルト値を指定する例を示す。

```
#!java

// デフォルト値を指定したアノテーション宣言
public @interface MyAnnotation {
	String foo() default "012";
	int bar() default 42;
	Class baz() default String.class;
}
```

アノテーション適用時に値を指定しなければデフォルト値になる。すべてのアノテーション要素がデフォルト値を持っていれば、マーカアノテーション同様、括弧を省略して記述可能。

アノテーション適用時の値指定の必要性を減らすために、可能な限り、適切なデフォルト値を設定することを推奨する。

### メタアノテーション

クラスやインタフェースの型宣言にアノテーションを適用可能であるのと同様に、アノテーション型宣言にもアノテーションを適用可能。アノテーション型自体を修飾するアノテーションをメタアノテーションと呼ぶ。

|アノテーション名|説明|
|----------------|----|
|Documented|アノテーションを文書化対象するjavadocへの指示|
|inherited|アノテーションが自動的に継承されることの指示|
|Retention|アノテーションの存在期間を指示|
|Target|アノテーションの対象要素を指示|

### Retentionアノテーション

Retentionアノテーションの要素にはRetentionPolicyのenum値のいずれか1つを指定する。

```
#!java

// RetentionPolicy.javaから抜粋
public enum RetentionPolicy {
	SOURCE,
	CLASS,
	RUNTIME
}
```

RetentionPolicyのenum値は以下に示す意味を持つ。

|値|説明|
|--|----|
|SOURCE|アノテーションはソースファイルにのみ残る|
|CLASS|アノテーションはソースファイルとクラスファイルにのみ残る|
|RUNTIME|アノテーションはソースファイルとクラスファイルに残り、かつ実行時にも残る|

デフォルト動作はRetentionPolicy.CLASS。現実的によく使うのはSOURCEもしくはRUNTIME。
RUNTIMEを指定したアノテーションは実行時にリフレクションで読み取ることができる。コンパイル時に読み取るだけで十分なアノテーションは無駄を防ぐためにSOURCEを指定する。例えばOverrideアノテーションはコンパイル時には使うだけなのでSOURCEの指定になっている。

```
#!java

// Override.javaから抜粋
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {}
```

### Targetアノテーション

Targetアノテーションの要素にはElementTypeのenum値の配列を指定する。

```
#!java

// ElementType.javaから抜粋
public enum ElementType {
	TYPE,
	FIELD,
	METHOD,
	PARAMETER,
	CONSTRUCTOR,
	LOCAL_VARIABLE,
	ANNOTATION_TYPE,
	PACKAGE
}
```

Targetアノテーションは、アノテーションは適用可能なプログラムの構成要素を指示する。ElementTypeの各値は、アノテーションを適用可能なプログラム構成要素の一覧に対応する。

Overrideアノテーションの宣言を見ると、@Target(ElementType.METHOD)となっている。これはOverrideアノテーションをメソッドだけに適用可能であることを指示している。
SuppressWarningsアノテーションは次のように多くの要素に適用可能。

```
#!java

// SuppressWarnings.javaから抜粋
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
	String[] value();
}
```

DeprecatedアノテーションにはTargetアノテーションがない。Targetアノテーションのデフォルトは、すべての構成要素に適用可能。このため、Deprecatedアノテーションは適用可能なすべての構成要素につけられる。

```
#!java

// Deprecated.javaから抜粋
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Deprecated {}
```

### アノテーションの応用

アノテーションのついたメソッドをコールバックパターンで呼び出してみる。外部から任意のコードを与えることからプラグインアーキテクチャとも呼ぶ。プログラムの構造は「インタフェース」の章の「コールバックパターン」と全く同じ。インタフェースを定義する代わりにアノテーションを使う。

以下、コード例。

* [コード例](../../commits/028f8b3cbce9fde0e9f4662045c793c97f50c03d)
* [コード例](../../commits/b38909e1ddaccf3808733b1719665dd56dfd10b6)
* [コード例](../../commits/233664f925c7afef7bd309b149ecce9411373029)

### アノテーションとPOJO

インタフェースを使わず、アノテーションでも同じような仕組みを構築できることがわかる。今回の例に限ると、アノテーション版は片安全性に劣る。なぜならメソッドの型を一切考慮していないから。これはリフレクションでメソッドの引数や返り値の方を検証することで解消できる。

インタフェース版の優れているところは、コンパイル時に振舞いを強制できること。文字列を受け取り文字列を返すメソッドをインタフェースで定義すれば、実装クラウはこの振る舞いに従わざるをえない。同時に、インタフェースでを実装することを宣言したクラスは、その目的が明瞭。

アノテーション版はインタフェース版よりも緩いコード。意図した動作をしないことがわかるのは実行時。実行時よりもコンパイル時に間違いを発見すべき、のプログラミングの原則からすれば劣ったアプローチ。

しかし、アノテーション版には１つ利点がある。プラグインするコードから他への依存性を完全に排除できる点。変わりやすい部分への依存はコードを脆弱にする。この視点を究極的に進めると、何も依存しないコードが最も堅牢である、という結論になる。他の一歳のクラスやインタフェースに依存しないクラスのオブジェクトをPOJOと呼ぶ。アノテーション版の Capitalize クラスはPOJOクラス。POJOクラスは単体テストが容易であったり、実行環境への配置が簡易であるという利点を持つ。

アノテーション版がインタフェース版の進化版だという主張はしない。現時点ではインタフェース版が本流の技法。たださい、新しい技法の可能性としてアノテーション版を考える価値はある。

# Javaサーバプログラミング

## Java EE概論

## サーブレット

## JSP

## JSP（EL&JSTL）

## データベース

# Java GUI

## Java GUI概論

## コンポーネント

## イベント

## スレッド

## レイアウト

## ペイント

## ルックアンドフィール
