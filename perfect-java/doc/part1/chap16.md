# スレッド

## スレッドとは

* 1つのプログラムの実行状態。マルチスレッド化したプログラムは、このような実行状態を複数持つ。
* 各スレッドは他スレッドと独立した実行状態。
    * すべてのスレッドはそれぞれに独自のコールチェインを持つ。
* スレッドはタイムスライスでスレッドの実行を切り替えられる。
    * OSレベルで複数のプロセスの実行を短時間で切り替えて、同時に走るように見えることと同じ話。
* スレッドの実行の切り替わりは強制的に働く。実行中のスレッドから見ると、実行中に突然割りこまれて実行が停止し、かつ突然実行が再開する。これを専門的にはプリエンプション（横取り）と呼ぶ。しかし、停止中にコールチェインが変化することはない。再開後も同じコード箇所から実行を再開する。

## スレッドと排他制御

* 複数のスレッド間で、何が共有されて何が共有されないのかを知ることが重要。
    * 共有されたデータに思わぬ不整合が生じることがあるから
* スレッドの横取りはどこでも起きると考えること。
    * 横取りが起きないことが保証されている操作を専門的には「アトミックな操作」と呼ぶ。Javaでアトミックな操作は僅かしかない。
* int型のフィールドを複数のスレッドが共有（同じフィールドを参照）しているとき、インクリメント演算子（++）を同時に実行すると、最悪のタイミングでは正しくインクリメントされないことがある。この最悪のタイミングはいつか必ず起きる。

以下のものは個々のスレッドが独立して保持する。つまりスレッド間で共有されることがない。

* メソッドのコールチェイン
    * お互いのスレッドは、相手のスレッドがどんなコールチェインかを知ることはない。（調べようと思えば可能）
* メソッドのパラメータ変数の「**値**」
* メソッドのローカル変数の「**値**」
    * ローカル変数やパラメータ変数がどんな値かを知る手段はない。
    * 変数が参照型変数の場合、変数が参照するオブジェクトはスレッド間で共有される可能性がある。
	    * ローカル変数とパラメータ変数の「**値の独立性**」は変わらないが、メソッド内でフィールド変数を参照するときに、複数のスレッドが同じオブジェクトを参照している場合、スレッド横取りで値が不正になる問題が起こりうる。
* これを防ぐために、Javaはロックという仕組みを用意している。
    * 共有するモノの不整合を防ぐことを同期処理や排他制御と呼ぶ。

## スレッド作成

* java.lang.Thread クラスでスレッドを作成できる。
    * start メソッドを呼ぶと新しいスレッドが作られる。
    * Thread オブジェクトは start メソッドを呼ぶと、内部で run メソッドを呼ぶようになっており、Thread クラスの run メソッドは（ほぼ）空。通常は、Thread クラスを拡張したクラスを自作して、run メソッドを独自に定義する。

```
#!java

class MyThread extends Thread {
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(i);
		}
	}
	public static void main(String[] args) {
		Thread thread = new MyThread();
		thread.start();
	}
}
```

[コード例](../../../../../commits/8d2385d7bbd5358acdd642139fac719afcab502b)

* 便宜上、最初から存在して main メソッドから実行開始するスレッドをメインメソッドと呼ぶ。最初に存在する以外の特別さはなく、メインスレッドが main メソッドを抜けても、サブスレッドが残っていればプログラムはそのまま走り続ける。
* OSから見ると、メインスレッドが残っているプログラムもサブスレッドが残っているプログラムも区別はない。
    * run メソッドのようなスレッドが最初に実行をはじめるメソッドを「**エントリポイント**」と呼ぶ。
        * メインスレッドは単にエントリポイントが main メソッドであるだけのスレッド。

## スレッドと Runnable インタフェース

Thread クラスの run メソッドのデフォルト実装は「*ほぼ空*」と表現したが、実際は空ではなく、Thread クラスのコンストラクタに渡された Runnable オブジェクトの run メソッドを実行する。この実装の意味するところは、 Runnable インタフェースを実装した独自クラスを定義して、 Thread オブジェクト作成時に Runnable オブジェクトとして渡すと、 Runnable オブジェクトの run メソッドを呼んでくれるということ。

いわゆるデザインパターンでのストラテジパターン相当。

[コード例](../../../../../commits/d743c8590482bfe6ef7787bb5cd30dd40676a566)

## Thread クラスの拡張と Runnable インタフェースの実装のどちらを使うべきか

よく問われる質問で、

* 拡張による継承と移譲のどちらがいいか
* テンプレートメソッドパターンとストラテジパターンのどちらがいいか

に置き換えてもいいが、最終的には宗教論争で、どちらか一方が決定的に間違っているとは言えない。しかし、多少の私見も交えるなら、Runnable インタフェースを実装したクラスへの移譲スタイルに軍配を上げる。理由は以下で、

* 継承よりも移譲のほうがクラス間の依存性が弱まるから（独立性が高まる）
* エントリポイントとしての機能（Runnable インタフェースの責務）とスレッド生成の機能（Thread クラスの責務）を分離できるから

Javaの中で、スレッド生成に関わるクラスは Thread クラスだけであり、 Runnable インタフェースおよび Runnable インタフェースを実装したクラスは、本質的にはスレッドとは無関係。

Runnable インタフェースはエントリポイントを提供する機能のインタフェース。Thread クラスと一緒に使うと、エントリポイントはスレッドのエントリポイントになるが、エントリポイントとしての機能はスレッドと独立したもの。その証拠に、 Runnable インタフェースが提供するエントリポイントは、マルチスレッドではない独自のマルチタスク処理（非同期のイベントディスパッチ処理）のエントリポイントにも使える。

## スレッドプール

多数のスレッドを作成するプログラムでは、スレッド生成の時間が実行性能に影響を与えることがある。性能を上げるために、スレッドを毎回作成せずに1度作成したスレッドを使いまわす手法がある。作成したスレッドを待機させて（プールして）、必要に応じてスレッドを取り出してタスク（Runnable オブジェクト）を割り当てる。タスクが終わったスレッドを再びプールに戻す。このようなプログラミングモデルを「**スレッドプール**」と呼ぶ。

スレッドプールを自分で実装することもできるが、標準ライブラリにスレッドプールのための仕組みがある。 java.util.concurrent パッケージにある。

スレッドプールは java.util.concurrent.Executors のクラスメソッドで作成できる。

|メソッド名|説明|
|----------|----|
|newFixedThreadPool|指定した数のスレッドを常時保持するスレッドプールを作成。タスクは空いているスレッドに割り当てられる。|
|newCachedThreadPool|タスクを割り当てるたびに新しいスレッドを作成して、しばらくスレッドを使いまわす。一定期間使われないスレッドは消滅する。|
|newScheduledThreadPool|タスクを一定時間ごとに実行するスレッドを持つスレッドプールを作成|
|newSingleThreadExecutor|1つのスレッドを使いまわすスレッドプールを作成。スレッドに割り当てたタスクは順々に処理される|

これらのクラスメソッドは、ExecutorService オブジェクトを返す。ExecutorService オブジェクトはスレッドプールを管理するオブジェクト。ExecutorService は様々なモードのスレッドプールに対して統一的なインタフェース。

[コード例](../../../../../commits/67abffd5e1298eb71586b6a36be157f6b27753a8)

スレッド作成はスレッドプール内に隠蔽されるので気にする必要がなくなる。自分でスレッドを作成するコードと殆ど変わらない手間でスレッドプールを使うコードが書ける。多くの場合、スレッドと Runnable オブジェクトの対応を正確に管理する必要はない。スレッドとタスクの割り当てを隠蔽できる。

## Callable インタフェース

Runnable オブジェクトの run メソッドは値を返せない。すまりスレッドは実行後に値を返すことができないが、代わりに Callble インタフェースを使うと、スレッドは値を返すことができる。

[コード例](../../../../../commits/5258883e1a55ac7699e231fa4eccfc2372cda6c7)

## 並行処理のサーバ

ストリームの章で実装した並行処理サーバをスレッドプールで書いた例は以下になる。

[コード例](../../../../../commits/248c8746a17ca538975d412c13cba3d870bd01f3)

ワーカースレッドの間に共有するリソースがない場合、コードが単純になり見通しの良い構造になる。

## 同期処理（排他制御）

Java の同期処理の基本は synchronized メソッドと synchronized 文。同じ予約語 synchronized を使う。構文は異なるが原理は同じ。
次の前提がある。

* すべての Java のオブジェクトはそれぞれが独立したロックを持つ
* 全てのクラスには対応する Class オブジェクトがあり、Class オブジェクトもそれぞれに独立したロックを持つ

## モニタロック

すべての Java オブジェクトと Java のクラスには、それぞれに1対1に対応したロックが存在する。このロックを便宜上モニタロックと呼ぶ。synchronized 構文はモニタロックの1つを獲得する。モニタロック獲得には次の3つのパターンがある。

* インスタンスメソッドを synchronized メソッドにすると、対象オブジェクト（レシーバオブジェクト）のモニタロックを獲得
* クラスメソッドを synchronized メソッドにすると、対象クラスのモニタロックを獲得
* synchronized 文は指定したオブジェクトもしくはクラスのモニタロックを獲得

## synchronized メソッド

synchronzied メソッドは次のようにメソッドの修飾子に synchronized を書く。

```
#!java

// synchronized メソッドの例
public synchronized void increment() {
	count++;
}

// 呼び出し側
obj.increment();
```

synchronized メソッド呼び出し時に自動的にレシーバオブジェクト（例ではobj変数が参照するオブジェクト）のモニタロックを獲得する。synchronized メソッド内から別のメソッドを呼び出してもモニタロックを獲得したまま。synchronized メソッドを抜けるときに自動的にモニタロックを解放する。メソッドを例外で抜けた場合もモニタロックを解放する。
クラスメソッドの synchronized メソッドも同じ構文。

```
#!java

// synchronized クラスメソッドの例
public static synchronized void increment() {
	count++;
}

// 呼び出し側
MyClass.increment();
```

synchronized クラスメソッドの場合の獲得するモニタロックはクラスのモニタロック。メソッド呼び出し時に自動で獲得して、メソッドを抜けると自動で解放する原則はインスタンスメソッドと同じで、例外で抜けた場合もモニタロックを解放する。

## synchronized 文

synchronized 文は次のように括弧内にモニタロックを獲得するオブジェクト参照を書き、ブロックを続ける。

```
#!java

// synchronized 文の例
public void increment() {
	synchronized(this) {
		count++;
	}
}
```

synchronized のブロックに入った時にモニタロックを獲得して、抜けるときに解放する。例外でブロックを抜けた場合もモニタロックを解放する。

this変数はレシーバオブジェクトを参照するので、synchronized(this)で獲得するモニタロックはsynchronized メソッド（インスタンスメソッド）で獲得するモニタロックと同じ。synchronized 文の方がsynchronized メソッドよりも小さな範囲で排他制御ができる。一般論として、ロックの範囲は可能な限り小さくしたほうが効率的。synchronized 文には任意のオブジェクト参照を指定できるので、synchronized メソッドよりも自由度が高い記述ができる。

synchronized クラスメソッドで獲得するモニタロックはクラスと1対1に対応するClassオブジェクトのモニタロックだった。synchronized クラスメソッドと等価なコードをsynchronized 文で書くには次のようにクラスリテラルを使う。

```
#!java

// クラスのモニタロックを使うsynchronized 文の例
public static void increment() {
	synchronized(MyClass.class) {
		count++;
	}
}
```

synchronized メソッドと synchronized 文の違いは、synchronized 文がモニタロックの対象オブジェクトを明示することだけ。

同じモニタロックを使う synchronized メソッド及び synchronized 文は、他のスレッドがそのモニタロックを獲得中はモニタロックが開放されるまで待機する。同じスレッドは同じモニタロックを繰り返し獲得可能。つまりモニタロックを獲得した synchronized ブロック内で同じモニタロックを獲得する際に待機しないので、 synchronized メソッドの再帰呼び出しは問題なく動作する。

## synchronized 命令がない場合の問題

[コード例](../../../../../commits/41553a3e8e5daabb289eb65d85331b50cfa24329)

2つのスレッド（MyWorkerオブジェクト）が1つの MyCounter オブジェクトを共有していて、2つのスレッドが同時に increment メソッドを呼ぶと、countフィールド変数に対して同時に++演算子を呼ぶ。

++演算子は一見アトミックに見えるがアトミックではない。加算するために次の3つのステップが必要で、１と３の間に別のスレッドに割り込まれる可能性がある。

1. 現在の値の読み出し
2. 加算
3. 加算結果への代入（書き出し）

int型変数への読み書きはアトミックであることが保証されているが、これは１や３のそれぞれの操作がアトミックであることを意味するだけで、１と３の間に割り込まれないことは意味しない。結局、このコードの変数 count は排他制御できていない。

MyCounter に適切な synchronized 命令を追加する方法は様々ある。もっとも素直な方法は次のように increment メソッドを synchronized メソッドにする方法。increment メソッド内に synchronized 文を書く方法もある。

```
#!java

// synchronized メソッドの例
public synchronized void increment() {
	count++;
}
// synchronized 文の例
public void increment() {
	synchronized(this) {
		count++;
	}
}
```

## モニタロックの選択

synchronized 文のモニタロック対象オブジェクトは色々と選択可能。レシーバオブジェクト（thisの参照オブジェクト）を使うこともできる。レシーバオブジェクトのモニタロックを使うなら synchronized メソッドのほうが素直。

任意のオブジェクトのモニタロックを使うこともできるので、次のようにモニタロック専用のオブジェクトを使う方法も可能。モニタロック専用のオブジェクトのクラスはなんでも使えるが、通常は Object クラスを使う。（ロック専用オブジェクトを参照する変数名には lock や mutex を使う。mutex は mutual exclusion の略で相互排他という意味）

```
#!java

private Object lock = new Object();
public void increment() {
	synchronized(lock) {
		count++;
	}
}
```

クラスのモニタロックを使うことも可能。

```
#!java

public void increment() {
	synchronized(MyCounter.class) {
		count++;
	}
}
```

MyCounter の場合、クラスのモニタロックの利用は推奨しない。なぜならクラスのモニタロックはオブジェクトのモニタロックよりも共有の範囲が広いため。

MyCounter クラスに synchronized クラスメソッドがあると、そのメソッドとモニタロックを共有することになる。モニタロックを共有する synchronized 命令が多ければ多いほど、モニタロック獲得街の待機時間が長くなる可能性がある。モニタロック獲得待ち時間はプログラムのパフォーマンスに影響する。

## コレクションの同期処理

操作対象のオブジェクトを synchronized 文に指定する方法もよく使う。通常のコレクションオブジェクトは内部に同期処理を持たないため、もし複数スレッドで同時にコレクションオブジェクトを変更するのであれば同期処理が必要。更新処理と読み取り処理が同時に走る可能性があれば、読み取り処理（イテレータによる読み取りも含む）にも同期処理が必要。

```
#!java

// 対象オブジェクトをモニタロックに使う書き方
// List<String> list; を複数スレッドで変更する場合のコード
synchronized(list) {
	list.add("foo");
}

// 更新以外の処理にも同期が必要（更新処理が同時に走る可能性があれば）
String s;
synchronized(list) {
	s = list.get(0);
}
```

コレクションオブジェクトは、Collections クラスで同期オブジェクトに変換できる。同期コレクションオブジェクトは内部で同期処理をするので、外部での同期処理は不要。

```
#!java

// List<String> list を同期リストオブジェクトに変換
List<String> slist = Collections.synchronizedList(list);
```

同期コレクションオブジェクトで外部の同期を完全になくせると考えるのは間違い。たとえば次のコードの List オブジェクトが同期コレクションオブジェクトだとする。

```
#!java

// 同期コレクションオブジェクトでも外部同期が必要な例
// List<String> list
// String s
if (!list.contains(s)) {
	list.add(s);
}
```

contains メソッドと add メソッドのそれぞれは、別のスレッドに割り込まれない。しかし、contains メソッドの呼び出し後、add メソッドを呼び出す前に別のスレッドに割り込まれる可能性はある。コードの意図が List オブジェクトに重複要素を許可しないことであれば、処理全体を synchronized 領域に入れて同期する必要がある。

## 同期処理の注意点

MyCounter に話を戻して、仮に MyCounter クラスの count フィールドの型が Integer だとする。
対象オブジェクトをモニタロックに使ったとする。残念ながら、次のコードは致命的なバグ。

```
#!java

// 致命的なバグ（ Integer が不変クラスであることに注意）
public class MyCounter {
	private Integer count = 0;
	public void increment() {
		synchronized(count) {
			count++;
		}
	}
	// 省略
}
```

Integer クラスが不変クラスであることを思い出すこと。count++ は Integer オブジェクト自体の持つ値の変更ではなく、新しい Integer オブジェクトを生成する。このため、synchronized 文が異なるモニタロックを使うことになる。
呼び出し側で同期処理することも1つの解。

```
#!java

// synchronized メソッドの例
class MyWorker implements Runnable {
	// 省略
	@Override
	public void run() {
		synchronized(counter) {
			for (int i = 0; i < LOOP_NUM; i++) {
				counter.increment();
			}
		}
	}
}
```

synchronized 文をループ内に書くとループ回数が多い場合に実行性能が悪くなることに注意すること。ロックの範囲（ロックの粒度ともいう）を小さくすることは、一般的に効率を高める。なぜならロックしている時間が短ければ、それだけロックを待つスレッドの待機時間が短くなるため。

しかし、ロックの粒度を小さくするとロック処理（獲得と解放）の回数が増える傾向にある。ロック処理の回数が増えると相対的に実行速度が遅くなる。ロックの粒度に関するこのバランスは難しい問題で、明確な解はない。

呼び出し側での同期の例だが、次のコードは致命的なバグ。

```
#!java

// 致命的なバグ（呼び出し側で同期）
class MyWorker implements Runnable {
	// 省略
	@Override
	public void run() {
		synchronized(this) {
			for (int i = 0; i < LOOP_NUM; i++) {
				counter.increment();
			}
		}
	}
}
```

this変数が参照するのは MyWorker オブジェクト。 MyWorker オブジェクトはスレッドごとに存在するオブジェクト。2つのスレッドで同期をとっているつもりが、お互いが異なるモニタロックを使うことになる。このコードは何も守れていない。

なお呼び出し側で使うモニタロックとして MyWorker.class を指定すると正しく動作するが、MyCounter.class と同じ理由で推奨しない。
synchronized 命令を使う時は、何を同期しているかに気を払うこと。形式的に synchronized 命令を使い、何も守れていないバグはしばしば見られる。

## 構文による利点

最後に同期処理を構文で行うことの利点と弱点を記述する。

* 構文による利点
    * ロック解放忘れが原理上起こらない
    * 利用が簡単
* 構文による弱点
    * メソッドやクラスをまたがるロックができない
    * ロック可能かを事前チェックできない
    * 何をロックしているかわかっていない開発者でも使えてしまう

## Java のメモリモデル

Java は、スレッドがオブジェクトを参照する時、オブジェクトのフィールドの値を個々のスレッドが独自に保持（キャッシュ）することを認めている。これは、スレッドごとにコールチェインを持ち、ローカル変数やパラメータ変数を独立して持つこととはまったく異なる話。コールチェインは本質的にスレッドごとに独立している。

一方、オブジェクトのフィールド値を独立して保持できるのは単なる効率のため。
効率のために個々のスレッドがフィールド値をキャッシュすることで次のような問題が起きることもある。あるスレッドがオブジェクトのフィールド値を変更したとする。他のスレッドで同じオブジェクトの同じフィールド値を読みだした時、古い値を読み出す可能性がある。本物のフィールド値と個々のスレッドが独自にキャッシュする値がずれている限り、この危険はいつでも存在する。

危険を回避するためには、個々のスレッドのキャッシュの変更を本物のフィールド値に書き戻すタイミングと、本物のフィールド値をキャッシュに読み込むタイミングを制御する必要がある。この制御は2つの方法で行う。

* synchronized 命令
* volatile 修飾子

## synchronized 命令

1つめの方法は既に説明した synchronized 命令。

synchronized 領域の中でアクセスするフィールド値は、本物の値をキャッシュに読み込むことが保証されている。そして synchronized 領域の中で書き換えたフィールド値は、synchronized 領域を抜けた時にキャッシュから本物の値へ書き戻すことを保証している。

synchronized 命令とキャッシュの動作は巧妙で、共有オブジェクトのフィールドを変更する場合、同期処理が必須。synchronized 命令の同期処理のついでにキャッシュの誤動作の回避も行えない。一見、悩ましく見えるフィールド値キャッシュの問題は、ほとんどの場合、synchronized 命令で自動的に解決する。

しかし、単にフィールドに値を代入する1行だけの処理であれば、通常 synchronized 命令は不要。このような場合は、synchronized 命令の代わりに volatile 修飾子を使うことで効率的にキャッシュの問題を解消できる。

## volatile 修飾子

2つ目の方法は volatile 修飾子を使う。次のようにフィールド変数の修飾子に使う。

```
#!java

// volatile 修飾子の例
private volatile String s;
private static volatile String s;
```

volatile 修飾子をつけたフィールド変数の値の変更は本物の値に書き戻されることが保証される。また volatile 修飾子のフィールド値の読み込みは本物の値を読むことを保証する。

volatile 修飾子のもう1つの効用に、long 型と double 型の変数の読み書きをアトミックにする作用がある。Java の言語仕様は、long と double 以外の型の変数の代入がアトミックであることを保証している。つまり int 型変数や参照型変数への代入操作はアトミック。代入がアトミックであるとは次のような意味。

例えば int 型変数であれば代入で右辺から左辺に32ビット分のデータの移動がある。この32ビットのデータの移動の最中に他のスレッドに割り込まれることはないという意味。

一方、long 型と double 型の代入操作のアトミック性は保証している。これら64ビットのデータを移動する間に他のスレッドに割り込まれ、前半32ビットと後半32ビットがそれぞれ別のスレッドの代入結果になることがありえる。この64ビットデータは当然むちゃくちゃな値。

synchronized 命令で排他制御するのも1つの回避策だが、代入1つに大げさすぎる。この場合、volatile 修飾子をつけるとアトミックな代入が可能になる。

volatile 修飾子が synchronized 命令の代用になると誤解しないこと。後述する「 **アトミック処理** 」の中で volatile 修飾子が同期処理の大体にならない具体例を説明する。

## 明示的なロック

synchronized 命令を使う方法は Java の言語仕様で文法的に決まった同期手法。簡易な記法で同期処理をサポートした利点の反面、自由度の点で失った部分がある。これを補完するために java.util. concurrent.locks パッケージがロック用のクラスとインタフェースを提供する。

Lock はロック用のインタフェース。実装クラスには ReentrantLock がある。ロック用クラスの利点は次の通り。

* メソッドやクラスをまたがるロックが可能
* ロック可能かを事前チェック可能

Lock オブジェクトは lock メソッドでロックを獲得して、 unlock メソッドでロックを解放する。あるスレッドがロックを獲得中は、他のスレッドがロックを獲得しようとしても待機する。unlock 忘れは致命的なバグなので、次のように finally 節に書くことを推奨する。

```
#!java

// Lock lock;
try {
	lock.lock();
	// 動機が必要な処理
} finally {
	lock.unlock();
}
```

ReadWriteLock は2つのモードを持つロック用インタフェース。writeLock メソッドは書き込み用ロックで、他のスレッドの同時実行を許さない。
readLock は読み込み用ロックで、他のスレッドの読み込みの同時実行を許すが、書き込みは締めだす。

ReadWriteLockは、書き込みを1つのスレッドだけ同時書き込みを複数スレッドに許す、という用途に使える。読み込み処理が多い場合、スレッドの待機が減り、実行性能が上がる。

## アトミック処理

int 型変数 count を複数スレッドで同時に++演算子で加算したとする。
既に説明したように++演算子はアトミックではない。

[コード例](../../../../../commits/82f6e5a72119bda0b46034e2faa35d53b9e4db28)

count変数にvolatile修飾子をつけても排他制御はできない。volatile修飾子により、片方のスレッドでのcount変数の変更を別スレッドが読むことを保証する。しかし、++演算子の読み出しと書き出しの間に別スレッドが割り込む問題は解消していないため。

正しく排他制御するには++式を synchronized ブロックで囲む。synchronzied 命令をループの中に置くか外に置くかで実行速度に有意な差が生じる。
ループの回る回数が多い場合、ループ内に synchronized 命令を書くと非常に遅くなる。下記に示す結果だけを見ると synchronized 命令を常にループの外に書きたくなるかもしれない。しかし、ループ中ずっと同じモニタロックを使う他スレッドを待たせるのでプログラム全体の並行性を落とす危険がある。

* [コード例](../../../../../commits/9efc496553f1f9bb496b54e8f0a8f3e6a6ff5891)
* [コード例](../../../../../commits/37853c99d6dd6a1eebe1303494da25637fd0ef3c)

java.util.concurrent.atomic パッケージはロックを使わない排他制御機能を提供する。この機能をアトミック処理と呼ぶ。アトミック処理の基本はCAS（Compare And Swap : キャス）と呼ぶ操作で、CASは変数の値の比較と代入をアトミック（別スレッドに途中で割り込まれない）に行う。（CPUのハードウェア命令レベルでアトミックにCASを実行する。CPUがCAS命令をサポートしていない場合、ソフトウェア的にロックを使ってエミュレートする）
CASをアトミックにするだけで、変数の加算や減算をアトミック減算にできる。

atomicパッケージを使って書き換えた例を以下に示す。

[コード例](../../../../../commits/b90e83324e1dd678037cd1bf15ab2dfd0a67ad18)

アトミック処理を使うコードは速度劣化が殆ど無い。

## 通知

排他制御以外の同期処理に通知処理がある。通知処理は、ある条件が成立するまでスレッド群を待機させ、条件成立後に待機スレッド群を起こす機能。通知処理はスレッドの実行順序を制御するために活用できる。

複数のスレッドを使うプログラムでは、あるスレッドが別のスレッドの仕事の完了を待つ局面がよくある。synchronized 命令による同期処理だけでは、ある条件が成立するまでスレッドを停止する処理が書きづらいが、通知を使うと簡易に記述できる。

通知処理では、条件が成立するまで待つスレッドと、条件を成立させ起こすスレッドが存在する。待機に使うメソッドは Object クラスの wait メソッド。起こすために使うメソッドは Object クラスの notify および notifyAll メソッド。 notifyAll メソッドは待機中スレッド全てを起こす。 

notify メソッドは待機中スレッドのうち1つだけを起こす。どのスレッドを起こすかを制御する手段はない。wait にはタイムアウト値を設定できるメソッドもある。

## 通知処理の構造

通知処理は内部的にモニタロックを使う。以下の例ではモニタロックの対象オブジェクトを targetObj で示す。待つ側の処理と起こす側の処理の構造は明確に決まっている。

wait 及び notify が同じモニタロックを獲得できるのであれば、synchronized 文の代わりにsynchronized メソッドでも構わない。

```
#!java

// 待つ側の処理
synchronized(targetObj) {
	while (!条件) {
		targetObj.wait();
	}
	// 条件が成立した時の処理
}

// 起こす側の処理
synchronized(targetObj) {
	// 条件を成立させる処理
	targetObj.notifyAll();
}
```

待つ側の処理に入ったスレッドは wait メソッドの呼び出しで停止する。別のスレッドが同じオブジェクト（targetObj）に対して notify メソッドもしくは notifyAll メソッドを呼ぶまで停止する。タイムアウト値の指定がある場合、タイムアウト値の時間が経過すると wait メソッドから返る。

wait メソッド呼び出しを while ループで囲むことは必須。条件が成立しなくても wait メソッドが返ることがあるため。

条件が成立しない限り回り続けるループと wait メソッド呼び出しの組み合わせで、ループを抜けた後に条件成立時にすべき処理を行うことができる。もし、wait メソッドがなければ、条件判定のループが回り続け、CPUが動きっぱなしになる。wait メソッドで待機していれば、このスレッドはCPUを使わない。待機して起こされるのを待つだけ。

一見、2つの処理は同じモニタロックを獲得するコードなので、2つのコードは同時に実行できないように見える。からくりは wait メソッドが内部で暗黙にモニタロックを解放することにある。

待つ側のスレッドが先に synchronized 領域に入ったとする。待つ側のスレッドが targetObj のモニタロックを獲得するので、別スレッドが起こす側の処理に入ってもモニタロック獲得待ちで停止する。待つ側のスレッドが targetObj の wait メソッドを呼ぶと、内部で targetObj のモニタロックを解放する。

別の見方をすると、これが wait メソッド呼び出しを synchronized 領域内で行う必要性の理由である。wait メソッド内部でモニタロックが開放されたので、起こす側のスレッドはsynchronized 領域に入ることができる。起こす側のスレッドがtargetObj の notifyALl メソッドを呼ぶと、待機スレッドが起こされる。待機スレッドは wait メソッド内で暗黙に targetObj のモニタロックを獲得しようとする。しかし、起こす側のスレッドがモニタロック獲得中なのですぐには獲得できずにブロックする。起こす側のスレッドが synchronized 領域を抜けてモニタロックを開放すると、大気スレッドがモニタロックを獲得して wait メソッドから返る。

起こす側のスレッドが先に synchronized 領域に入ると、待機中のスレッドがない状態で notifyAll メソッドを呼ぶだけ。notify した状態は記憶されない。別のスレッドが wait すると、新たに起こす処理をするスレッドが現れるまで待機する。

## 通知処理の具体例

待つ側のスレッド（群）が必要なデータを持ち、起こす側が必要なデータを揃える、というのがシナリオ。しばしば待つ側を消費者（consumer）、起こす側を生産者（producer）としてモデル化する。

[コード例](../../../../../commits/5b75d0a990867ba448f74c8f4be22557942e8fa1)

Producer クラスと Consumer クラスのオブジェクトを生成して別々のスレッドで実行する。2つのスレッドはキュー（Queueオブジェクト）を共有する。Producer スレッドはコンソールでユーザ入力を待つ。ユーザ入力があると入力文字列があると入力文字列をキューに追加して、Consumer スレッドを起こす。起こされるまで Consumer スレッドは wait メソッドで待機する。起こされるとキューから文字列を取り出す。

## ディスパッチモデルとタスクキューモデル

MyProduceConsume では待機スレッドが1つだが、複数の待機スレッドで並行処理を行う場合がある。ネットワーク系のサーバプログラムでは、接続を受け付ける1つのマスタースレッドと、実際にデータ送受信をする多数のワーカースレッドで構成することがある。接続を受け入れたマスタースレッドがワーカースレッドに順々にタスクをアサインする。このような構成を「**ディスパッチモデル**」と呼ぶ。

一方、1つのタスクキューを用意して、ワーカースレッドをキューに対して待機させる。マスタースレッドは接続を受け入れるとタスクキューにタスクを押しこんでワーカースレッドを起こす。ワーカースレッドのどれか1つがタスクをキューから取得して、残りのワーカースレッドは再び待機状態に戻る。このようなモデルを「**タスクキューモデル**」と呼ぶ。

ディスパッチモデルよりも細かな制御ができないが、その分コードが簡易になる。タスクキューモデルは、並列処理に有効なモデル。

## デッドロックと検出

2つのスレッドがお互いにロックを待ち合う現象を「**デッドロック**」と呼ぶ。

[コード例](../../../../../commits/f2591e1240dca1a971e8ab0e705f04238ad883fe)

2つのスレッドが2つのリストオブジェクト（list1とlist2）を独立にソートするコード。Collections クラスの synchronizedList クラスメソッドは使わず、ここでは synchronized 文で明示的にロックする。

スレッド t1 は list1 に対する synchronized 文の中で list2 に対する synchronized 文を書いている。スレッド t2 は list2 に対する synchronized 文の中に list1 に対する synchronized 文を書いている。このようにお互いのロックの順序が逆転しているとデッドロックが起きる。逆に言うと、以下の規則を守るとデッドロックを防ぐことができる。

* ロックを入れ子にしない
* 入れ子のロックをする時、ロックの順序が逆にならないようにする

## デッドロックが起きる時

デッドロックは次のように起きる。

スレッド t1 が list1 のモニタロックを獲得した後、list2 のモニタロックを獲得する前にスレッド t2 に切り替わったとする。スレッド t2 が list2 のモニタロックを獲得して list1 のモニタロックを獲得しようとする。

スレッド t1 が list1 のモニタロックを獲得中なので、スレッド t2 はスレッド t1 によるモニタロック解放を待つ。一方、スレッド t1 は list2 のモニタロックを獲得するためにスレッド t2 が解放するのを待つ。お互いが相手のモニタロック解放を待つ。解放待ちは永遠に解決しない。プログラム実行の観点で見ると、2つのスレッドは永遠に停止する。

スレッド切り替えのタイミングに依存するので、デッドロックの発生は確率的（発生が確率的なことは、スレッドの同期に関係する問題に共通する）。MyDeadLock を実行するとデッドロックは起きるかもしれないし、起きないかもしれない。

## デッドロックの監視

デッドロックが発生したことを告げる標準的な仕組みはない。スレッドごとに見ると、待ち状態のロックがデッドロックで永遠に待つロックなのか、待てばいつか解放されるロックなのか区別がつかないため。しかし、デッドロックが発生した時、どのスレッド同士がデッドロック状態かを外部から知ることは可能。

このために標準ツール jconsole コマンドを使う。Java5では、次のように監視対象プログラムの実行時に特別なコマンドラインオプションが必要。Java6以降では必要ありません。

```
// jconsole で監視するための実行方法
Java5
$ java -Dcom.sun.management.jmxremote. MyDeadlock

Java6以降
$ java MyDeadlock
```

デッドロックの疑いがある場合、次のように jconsole コマンドを実行する。監視対象プロセスのプロセスIDがわかる場合、コマンドライン引数で指定できる。プロセスIDを指定しない場合、GUIで監視対象プロセスを選択する。

```
// 引数なしで実行して GUI で対象プロセスを選択もしくはプロセスIDをコマンドライン引数で指定
$ jconsole
```

"Threads"タブを選択して画面下部の"Detect Deadlock"ボタンをクリックします。デッドロックを起こしているスレッドそれぞれのコールチェインを見ることができる。MyDeadlock では Thread オブジェクト生成時の第2引数で"my-thread1"と"my-thread2"としてスレッドに名前をつけている。
スレッド名はプログラム実行に影響はないが、監視時にスレッドを見分けるのに役立つ。

## 同期処理の技法

現場のプログラミングでは、スレッド生成のコードを書く場面は減ってきている。しかし、マルチスレッドで動くプログラムは増えている。どういうことかというと、スレッド生成がフレームワーク内に隠蔽され、フレームワークの上に載ったコードを書く場面が増えてきているから。現場のプログラミングで求められる技術は、スレッドをいかに生成するかではなく、多数のスレッド（マルチスレッド）から呼ばれても問題のないコードを書く技術。

複数のスレッドから呼ばれて問題のないオブジェクトの筆頭は、フィールドを一切持たないクラスのオブジェクト（定数フィールドを除く）。オブジェクトが状態を持たない限り、排他制御は不要。状態を持つクラスと状態を持たないクラスを峻別することは規模の大きなプログラミングでは一般的。
排他制御をなくせる別の策が、状態を持つオブジェクトをスレッドごとに持たせて、スレッド間で共有させない手法。

サーブレットアプリを例にすると、 HttpServletRequest オブジェクトと HttpServerResponse オブジェクトはスレッド間で共有しないことを前提にしている。スレッド間で共有しない方針にすれば、これらのオブジェクトに同期処理は不要。マルチスレッドプログラミングで最も重要なことが、どのオブジェクトが共有されて、どのオブジェクトが共有されないかを知ること。共有されるオブジェクトに同期処理がないことは致命的なバグ。

スレッド間の共有物を減らすことは鉄則だが、完全になくせることは稀。同期処理をする場合、何を守るかを明確にする必要がある。共有物を守るために、スレッドは同じロックを使う必要がある。

[コード例](../../../../../commits/627ad3831a8f8b37652a4ed5c4ffac1e396ef3c9)

MyWrongSync は誤った同期処理。共有物は Worker クラスのクラスフィールド count 。インスタンスメソッド increment を synchronized メソッドにすると、2つのスレッド（Workerオブジェクト）はそれぞれに異なるモニタロックを確保する。

正しく同期処理をするには、Worker.class で Worker クラスの Class オブジェクトのモニタロックを使うこと。これで2つのスレッドは同じロックを獲得する。2つのスレッドが共有するオブジェクトのモニタロックを使うのも手。

最後に、不変オブジェクト。不変オブジェクトは状態が不変なため、そもそも同期処理が不要。
