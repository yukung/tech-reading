# 数値（2）

## 浮動小数点数

* 浮動小数点型は、同じビット長のint（32ビット）やlong（64ビット）よりも広い範囲の数値を表現できる
    * これは、絶対値が大きければ大きいほど飛び飛びの値で表現しているから
    * 逆に言うと、整数型数値から絶対値の大きな浮動小数点型に変換した時、正しい値になる保証がないことを示す

## どの浮動小数点型を使うべきか

* メモリに厳しい制約がない限り、doubleを使うのが一般的。わざわざ精度の低い浮動小数点数を使う意味があまりない

## 浮動小数点数の演算

* 整数との大きな違いは、桁あふれや0による除算
* 浮動小数点数の特別な値
    * POSITIVE_INFINITY
        * 正の無限大
    * NEGATIVE_INFINITY
        * 負の無限大
    * NaN
        * 非数（Not a Number）

浮動小数点数の特別値をもたらす演算をまとめると、以下のとおり。

|x|y|x/y|x%y|
|-|-|---|---|
|通常値|0.0|無限大|NaN|
|通常値|無限大|0.0|x|
|0.0|0.0|NaN|NaN|
|無限大|通常値|無限大|NaN|
|無限大|無限大|NaN|NaN|

これらは、 Double.java の中で次のように定義されている。

```
#!java

public static final POSITIVE_INFINITY = 1.0 / 0.0;
public static final NEGATIVE_INFINITY = -1.0 / 0.0;
public static final NaN = 0.0d / 0.0;
```

## strictfp

strictfp修飾子は、インタフェース、メソッドに適用でき、ハードウェアに依存しない浮動小数点演算を指定する。Javaの思想はプラットフォーム依存を排除することなので、これに反するが、浮動小数点演算は重い処理である。
そのため、以下の様な使い分けができる。

|修飾子|意味|
|------|----|
|strictfp|プラットフォーム非依存の浮動小数点演算を行う|
|非strictfp|高速化のためプラットフォーム依存の浮動小数点演算を行なってもよい。ハードウェア命令を使うかは実装次第|

## 浮動小数点数の内部表現

浮動小数点の内部形式はIEEE754と呼ばれる標準規格。

[コード例](../../../../../commits/0232be1f22af672c5306af2f275d4b5b1d8fc16f)

## 浮動小数点のリテラル値

* fまたはFで終わる浮動小数点リテラルの型はfloat
* dまたはDで終わる浮動小数点リテラルの方はdouble
* その他の浮動小数点リテラルの型はdouble
* 指数部を指定するリテラル表記
    * eもしくはEの後に指数を表記
        * 例えば 1.8e1 // 1.8 x 10の1乗 = 18
        * 1.8e-1 // 1.8 x 10の-1乗 = 0.18
* 16進数で指数表記する場合は
    * pもしくはPの後に指数を表記
        * 0x1.1p0 // (1 + 1 x (1/16)) x 2の0乗 => 1.0625
        * 0x1.1p4 // (1 + 1 x (1/16)) x 2の4乗 => 17.0

## 数値クラス（ラッパークラス）

数値のラッパークラスを使う場面は次の場合。

* 数値をオブジェクトとして扱いたい場合
* 特に、コレクションの要素に数値を使う場合

数値ラッパークラスは、new演算子による直接的なオブジェクト化はせずに、valueOfクラスメソッドを使う。これは、valueOfメソッドを使うと、同じ値に対して同じオブジェクトを再利用できる可能性があるため。[数値クラスは不変クラス（イミュータブル）。]
現実では、ボクシング変換で暗黙に数値クラスをオブジェクト化することもよく行われる。

## Booleanクラスの注意点

Boolean型変数はnullになる可能性があるので、事実上、3状態値である。例えば次のコードは、NullPointerException実行時例外が発生する。

```
#!java

void cond(Boolean b) {
    if (b) {
        System.out.println("true");
    } else {
        System.out.println("false");
    }

// 呼び出し側
Boolean b = null;
cond(b);
```

そのため、Booleanオブジェクトには次の2つの定数のいずれかが確実に代入されることを保証すべき。

* Boolean.TRUE
* Boolean.FALSE

## ボクシング変換

ボクシング変換は、基本型数値と数値ラッパークラスのオブジェクトを自動的に変換する仕組み。

```
#!java

// ボクシング変換の例
Integer i = 0;
```

内部的にはInteger.valueOf(0)が自動的に実行され、Integerオブジェクトを生成する。
逆に数値オブジェクトから基本型数値への変換をアンボクシング変換と言う。

```
#!java

int i = list.get(0);
```

ボクシング変換とアンボクシング変換は便利だが、裏側で暗黙にオブジェクト生成が起きることを忘れないこと。特に、ループ内でインクリメント演算するようなコードは、都度オブジェクト生成がなされるため、パフォーマンス影響することがある。

```
#!java

// 暗黙のボクシング変換（見た目以上に非効率）
Integer i = 0;  // ここでボクシング変換
i++;  //ここではアンボクシング変換とボクシング変換
```

また、アンボクシング変換により、NullPointerException実行時例外が起こる可能性も注意すること。

## 数値オブジェクトの同値性

同値性の判定のためにはequalsメソッドを使う。しかし、数値オブジェクトは==演算子による同一性判定がたまたま同値判定になることがある。絶対値が小さい数値は、高速化のために同じ値の数値に同じ数字オブジェクトを使いまわす実装になっているため。

```
#!java

// たまたま==演算式で数値オブジェクトの同値性判定ができる例
Integer i0 = 1;
Integer i1 = 1;
if (i0 == i1) {
    System.out.println("equal");
}

// ==演算式でオブジェクトの同値性判定ができない例
Integer i0 = 65536;
Integer i1 = 65536;
if (i0 == i1) {
    System.out.println("equal");
}
```

```
#!java

// int → Integerへの変更で問題が見つかりづらい例
class My {
    private int val;
    public int getVal() {
        return val;
    }
}

// 使う側
if (my1.getVal() == my2.getVal()) {
    // 省略
}

// 変更後
class My {
    private Integer val;
    public Integer getVal() {
        return val;
    }
}

// 使う側
if (my1.getVal() == my2.getVal()) {  // Integer.equals() に変更しないと、コンパイルエラーになることなく、単に不正な動作（バグ）になる
    // 省略
}
```

## 型変換

* 拡大変換はキャストなしで変換できる
* 縮小変換にはキャストが必要
* 浮動小数点数から整数への変換では、小数点以下の情報が抜け落ちる

```
#!java

// 精度の損失の例
int i = 16777216; // (=2の24乗)
float fn = i;
System.out.println((int)fn);  // => 1677216
i++;
fn = i;
System.out.println((int)fn); // => 1677216
```

## ビット演算

ビット演算が有効に使える場面があるの事実だが、濫用はコードの可読性を落とすので、利用には注意を払う。
