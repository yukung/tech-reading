# 文、式、演算子

Javaのソースコードは文の集合。文は式と文から構成される。
Javaの文は、次の4つのカテゴリに分類できる。

* 制御文
* ブロック文
* 宣言文
* 式文（空文を含む）

## 制御文

* if文やfor文などの制御構造
* try-catch文
* synchronized文

文は、

* 予約語
* 式
* 記号

に分解でき、式は最終的に

* 識別子
* リテラル値
* 記号

に分解される。

識別子は、以下のような定義となる。

* 予約語以外の単語
* true, false, null以外の単語（リテラル値以外）
* Unicodeの（非空白）文字で始まり、その後にUnicodeの文字または数字が続く単語
* 単語の長さに特に制限はない

識別子は上記の定義の範囲であれば自由に作成可能だが、現実的なプログラミングでは、次の規則に従うべき。

* 英文字（大文字及び小文字の英文字およびアンダースコア。大文字と小文字は区別される）で始まり、英文字と数字（0から9）が続く単語

## ブロック文

* 文が並んだ集合を{}で囲むと、文の集合が文になる。
* ブロック文のなかにブロック文を並べることも可能。

```
#!java

// ブロック分の中のブロック文。文法的に正しいコード。
public static void main(String[] args) {
	{{{ {} }}}
}
```

## 宣言文

* クラス宣言
* インタフェース宣言
* パッケージ宣言
* インポート宣言
* フィールド宣言
* メソッド宣言

* 終端のセミコロンまで含めて宣言文。
    * ブロック文は、文ではあるが終端にセミコロンは不要。
    * このことから、「Javaの文は最後に必ずセミコロンを書く必要がある」ではなく「Javaの文の一部は終端としてセミコロンを必要とする」である。

## 式文

* 式とは、演算子とオペランドを演算子の規則に従って並べたもの。
    * 単項演算子、2項演算子、3項演算子
    ** 単項演算子は、前置演算子と後置演算子に分類できる
    * 3項演算子は条件演算子のみ。

式も再帰的に定義できるが、式は文よりずっと可読性が悪くなりがちなので、大きな式は適切に一時変数を使って分解する。

* 式の評価
    * 基本的にオペランド（の式）を先に評価してから、演算子を適用する。一部の演算子（||論理演算子、&&論理演算子、3項演算子）は、例外的にオペランドの評価を遅延する。（遅延の結果、評価しないこともある）

式の評価値（評価の結果得られた値）は以下の3つのパターンに分類できる。

|種類|説明|
|----|----|
|値|右辺値|
|変数（左辺値）|値を代入する先としての変数（いわゆる代入先）|
|空（void）|返り値の型がvoidのメソッドの呼び出し先の評価値|

代入式の評価値は代入値そのもの。

```
#!java

// 最初にiを評価して、iの参照場所を返す
// 次にオペランドを評価して、1を得る
// 最後に演算をして、iに1を代入する。
// 最終的に評価値は1。
// 代入式の左辺値に書くオペランドは変数もしくは配列参照式。
i = 1;
```

また、メソッド呼び出しの()も演算子。オペランドはメソッド名と引数式。

* 式文にできる式は以下の式。

```
#!java

i = 0; // 代入式
i++; // 前置、後置のインクリメント、デクリメント式（i++、++i、i--、--iなど）
System.out.println("foo"); // メソッド呼び出し式
new StringBuilder("foo"); // new演算子を使ったオブジェクト生成式。一般的には代入式の右オペランドになる。
```

## 空文

空文は、書かなくても意味的にも文法的にも問題はないが、敢えて式文を書くことで、ブロックの中の書き忘れではなく何もしないことを意図したコードであることを読み手に伝えることができる。

## 空白文字と改行文字

* 連続した空白文字と改行文字（CRおよびLFを含む）は1つの空白文字と同じ扱い
* // コメントを除いて、改行文字は構文的に意味を持たない
* 文字列リテラルの中に改行文字を直接記述できない（使う場合はエスケープシーケンスを使う）

## 式の評価順序

* &&演算子、||演算子、? :演算子の3つの演算子を除いて、すべてのオペランドを演算前に評価する
* オペランドは左のオペランドから評価する
* メソッド及びコンストラクタ呼び出し式では、呼び出し前に引数を左から評価する
* 括弧内は先に評価する
* オペランドの評価中に例外が発生すると、残りのオペランドは評価しない
* メソッド及びコンストラクタ呼び出し式の、途中の引数の評価で例外が発生すると、残りの引数は評価しない

## 演算子の優先順序と結合規則

* 同じ優先順の演算子の間では、演算子の結合規則により演算の順序が決まる

## インクリメント演算とデクリメント演算

* 前置演算子と後置演算子の違いは、評価値の違い
    * 前置演算子の評価値は加算と減算を行った後の値になる
    * 後置演算子の評価値は加算や減算を行う前の値になる

```
#!java

// 前置演算子と後置演算子の違い
int n = 10;
int m = n++; // nは11になる。n++の評価値は加算前の値なのでmの値は10

int n = 10;
int m = ++n; // nは11になる。++nの評価値は加算後の値なのでmの値は11
```

```
#!java

// 前置演算子を使ったループ
// 9回まわるループ
int n = 0;
while (++n < 10) {
	System.out.println("x");
}

// 後置演算子を使ったループ
// 10回まわるループ
n = 0;
while (n++ < 10) {
	System.out.println("x")
}
```

評価値を使う必要がない場合は、前置演算子と後置演算子どちらを使っても違いはない。どちらでもいい場合は後置演算子が多いが、C++では演算子のオーバーロード機能により、整数値以外に++演算子を定義でき、後置演算子は適用前の値を覚えておく必要があるため、前置演算子が好まれる。

## ビット演算

|演算子|意味|
|------|----|
|&|ビット積（AND）|
|||ビット和（OR）|
|^|排他的ビット和（XOR）|
|<<|左シフト|
|>>|右シフト（最左ビットは符号維持の値)|
|>>>|右シフト（最左ビットをゼロにする）|
|~|1の補数|

## 文字列の演算

|演算子|意味|
|------|----|
|+|文字列の結合|
|+=|文字列の結合と代入|

2つのオペランドの型が数値型の場合、+演算子は数値の加算式になる。両方もしくは片方のオペランドの方が文字列であれば、文字列結合式になる。非文字列型の方のオペランドをtoStringメソッドでString型に型変換する。

```
#!java

// 暗黙にlist.toString()が呼ばれて、文字列に型変換される
List<String> list = new ArrayList<String>();
list.add("bar");
list.add("baz");
String s = "foo" + list;
System.out.println(s); //=> "foo[bar, baz]"

// 暗黙に数値1がボクシング変換でInteger型に変換され、さらにInteger.toString()が呼ばれる
String s1 = "foo" + 1;
System.out.println(s1); //=> "foo1"

// nullと文字列の結合
String s2 = "foo" + null;
System.out.println(s2); //=> "foonull"

// +=演算子の例
String s3 = "foo";
s3 += "bar";
System.out.println(s3); //=> "foobar"

// 文字（char）型は数値の加算減算
System.out.println('a' + 'b'); //=> 195

// 文字列結合演算になる例
System.out.println("a" + 'b'); //=> "ab"
```

## 関係演算と等価演算

* 関係演算子のオペランドの型は数値型（整数型もしくは浮動小数点型、数値ラッパー型。boolean型を除く）
    * 評価値の型はboolean
    * 2つのオペランドの方が異なる場合、オペランドを型変換してから評価する
* 等価演算子のオペランドの型は数値型（整数型もしくは浮動小数点型。boolean型を含む）もしくは参照型。
    * 評価値の型はboolean

|演算子|意味|
|------|----|
|>|大なり|
|>=|以上|
|<|小なり|
|<=|以下|
|==|等しい|
|!=|等しくない|

## 同一性と同値性

* 同値性の比較基準はオブジェクトごとに異なる
    * Stringクラスのオブジェクトであれば、2つのオブジェクトの文字列の内容が一致していれば真になる
    * Stringクラスが同値性をそのように定義しているため
* 同値性の比較にはequalsメソッドを使う。equalsメソッドはObjectクラスのメソッドで、同値性を判定するために、派生クラスがそれぞれに実装を提供することを期待しているメソッド
    * デフォルトのequalsの実装は同一性を判定する
* 同一性が真であれば同値性は必ず真になる。逆は必ずしも成り立たない

* 基本型変数に対する==演算子及び!=演算子は、値が等しいかどうかを判定する
    * 言語仕様上は同一性の判定
    * 同一性を正確に定義すると、変数の値は一致を判定することで、参照型変数の場合も、同一性の判定は、同じ参照値を持つことの判定に他ならない
    * 基本型変数では同一性の判定が同値性の判定と等価の働きをする

## 論理演算

* 論理演算子のオペランドの型はboolean。演算の評価値の型もboolean
* &演算子及び|演算子と&&演算子及び||演算子の違いは、右オペランドを評価遅延すること
    * そのため、&&演算子及び||演算子の右オペランドに副作用のある式を書くと、遅延評価により評価されないことがあるため、この動作に依存するコードは書かないこと
* 否定演算子!は、使い過ぎるとコードの可読性を落とすので、避ける

## 代入演算

代入演算子=は、左オペランドは左辺値として評価される。左オペランドに書ける式は次の2つ。

* 変数（フィールドアクセス式を含む）
* 配列要素の参照式

代入演算子の結合規則は右結合。他のすべての演算子は全て左結合なので、例外的な結合規則。次のような代入式を成立させるための特別な文法規則。

```
#!java

int i, j, k;
i = j = k = 0;
// i = (j = (k = 0));と評価され、i, j, kのすべてに0を代入する
```

## new演算

new演算子は単項前置演算子。オペランドは型名（クラス名、インタフェース名、配列生成式の配列指定）。

## キャスト演算子

キャスト演算子は単項演算子。オペランドの型はキャストで指定する方に依存。

## instanceof演算

instanceof演算子はオブジェクトの型を判定する演算子。2項演算子で左オペランドがオブジェクト参照、右オペランドが参照型の型名（クラス名もしくはインタフェース名）。評価値の型はboolean。左オペランド式が右オペランドの方に代入可能な参照型の時、式の評価値が真になる。instanceof演算子は型比較演算子とも呼ぶ。左オペランドがnullの場合、評価値は常に偽になる。

instanceof演算子は、ダウンキャストと密接に関連する。instanceof演算子を使う目的は、ダウンキャストを安全に行えるかを事前にチェックするため。

```
#!java

void doit(Object obj) {
	if (obj instanceof String) {
		String s = (String)obj;
		System.out.println(s);
	}
}
```

ClassCastExceptionを補足することもできなくはないが、ClassCastExceptionは一般的にバグ。
以下のようなinstanceof演算はコンパイルエラーとなる。

```
#!java

void doit(String s) {
	if (s instanceof StringBuilder) {
		StringBuilder sb = (StringBuilder)s;
		System.out.println(sb);
	}
}
```
StringクラスからStringBuilderクラスへダウンキャストできないのはコンパイル時点でわかるため。

## 配列要素の参照演算

[]も演算子の1つ。[]の中のインデックス値が右オペランドでint型、左オペランドの型が配列参照型の2項演算子。

## フィールドまたはメソッドのアクセス演算

フィールドやメソッドにアクセスする.（ドット）も演算子。左オペランドの型はオブジェクト参照。右オペランドはフィールド名およびメソッド名。

## メソッド呼び出し演算

メソッド呼び出しの()も演算子。左オペランドがメソッド名で、右オペランドは引数式。
