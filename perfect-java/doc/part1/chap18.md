# アノテーション

## アノテーションとは

アノテーションは、プログラムの構成要素に付与するメタ情報。アノテーションの具体例の1つは、@Overrideなど。文法上、アノテーションは修飾子の1つとして働くが、他の修飾子（publicやfinalなど）と異なり、アノテーションは予約語ではない。クラスやインタフェースのように、開発者自身がアノテーション型を定義する。

アノテーションを修飾子として記述することを「**アノテーションの適用**」と呼ぶ。Overrideアノテーションであればメソッドに適用する。
アノテーションを適用できるプログラム要素をいかに示す。

* 型宣言（クラス、インタフェース、enum、アノテーション）
* フィールド宣言
* メソッド宣言
* パラメータ変数宣言
* コンストラクタ宣言
* ローカル変数宣言
* パッケージ宣言

ソースコード上、修飾子を書ける場所にはアノテーションを書けると理解して問題ない。慣例として、アノテーションを最初の修飾子として書く。

アノテーションには、そのアノテーションを処理するプログラムが必要。誰も処理をしないアノテーションは意味が無い。例えば@Overrideアノテーションなら、コンパイラが読み取ることで意味を持つ。アノテーションは、アノテーションを読み取るツールやフレームワークとセットで存在する。

## アノテーションの応用例

アノテーションの応用例を示す。

* 構文補助
* 宣言的プログラミング

## 構文補助

構文補助を目的としたアノテーションの代表例は@Override。構文補助のためのアノテーションで、Javaの文法規則の独自拡張に近いことができる。この目的のアノテーションは開発者の自己満足になる傾向が強いため、新規開発は慎重に行うべき。

## 宣言的プログラミング

プログラムを機能や役割で分割するのはプログラミングの王道。部品の独立性が高まっても解決しない問題がある。
部品がどう動くかはコードを見ればわかるが、それを誰が何のために使うのかは部品を見るだけではわからない。皮肉なことに部品の独立性が高まるほど（つまり良いコードになればなるほど）この傾向が強まることもある。

部品自身にその存在理由を陽に記述できる工夫として、アノテーションを活用可能。アノテーションを部品に適用することで、誰にどう使って欲しいかを宣言できる。

プログラミングの歴史の中で、手続きを記述する手続き型プログラミングと別に、「**宣言型プログラミング**」という流れがある。宣言的プログラミングでは、手順ではなく目的を記述する。アノテーションで目的を記述することは、Javaによる宣言型プログラミングの道を開く。Java自体は宣言型言語ではないので、アノテーションを読み取り目的から手順に落としこむフレームワークの存在が不可欠。

## 標準アノテーション

|アノテーション名|説明|
|----------------|----|
|Override|オーバーライドしたメソッドであることを明示|
|Deprecated|非推奨であることを明示|
|SuppressWarnings|コンパイラの警告メッセージを抑制|

## Override

Overrideアノテーションを書く癖をつけておくと、いつか助かる時が来る。騙されたと思って付けておくこと。

## Deprecated

推奨しない対象要素を明示する。メソッドやコンストラクタにつけるのが主だが、型宣言やフィールドにも適用可能。
警告の詳細を表示するには、 `-Xlint:deprecation` オプションをつける。

コンパイルエラーではなく警告なので、クラスファイルは生成される。しかし、よほどの理由がない限り、コードを修正すべき。クラス提供者はメソッドなどを非推奨に変更した場合、修正方法を示す義務がある。
一般に修正方法をjavadocコメントに明記する。

## SuppressWarnings

コンパイラの警告を抑制する。SuppressWarningsに指定できる文字列はjavaコンパイラに依存するので、確認するには `javac -X` の出力の `-Xlint` の行の説明文字列を見るのが汎用度の高い調べ方。

## アノテーション定義

アノテーションは型の1種なので型定義の泉源を持つ。 Override.java や SuppressWarnings.java といったソースファイルが存在する。クラス同様、アノテーション型宣言のファイルもjavacでコンパイルする。

アノテーション型定義に付く**メタアノテーション**として、

* Target
* Retention

の2つがある。

アノテーション型の宣言の構文は次のようになる。

```
#!java

[アクセス制御修飾子] @interface アノテーション名 {
	アノテーション要素
}
```

アクセス修飾子はインタフェース宣言に対するアクセス制御と同じ。現実的には多くのアノテーションはpublicになる。

アノテーション名は開発者が自由に付けられる名前。クラス名およびインタフェース名と同じ名前空有間に属する。完全修飾名が一致するクラスやインタフェースが存在する場合、コンパイルエラーになる。

Overrideアノテーションの型宣言には、アノテーション要素がない。アノテーション要素のないアノテーションを**マーカアノテーション**と呼ぶ。

アノテーション要素は、文法上、本体のないメソッド定義。つまりインタフェース宣言の中に書くメソッド定義と同じ。しかし、適用の観点ではアノテーション要素はメソッドよりもフィールドに近い存在。

アノテーション要素名は開発者が自由に付けられる名前。valueという名前には特別な省略記法が用意されており、アノテーション要素が1つの時はvalueという名前にすることを推奨する。

```
#!java

public @interface MyAnnotation {
	String foo();
	int bar();
	Class baz();
}
```

アノテーション要素の型（文法上はメソッドの返り値の型）は次に限定される。

* 基本データ型
* String型
* enum型
* アノテーション型
* Class型
* 上記を要素型とする配列型（配列の配列は不可）

アノテーション要素には次の制約がある。

* パラメータ引数は禁止
* throws節は禁止
* ジェネリックメソッドは禁止

```
#!java

public @interface MyAnnotation {
	Integer foo();	// 返り値の型は決まった型しか許可されない
	int bar(int i);	// パラメータ引数は禁止
	Class baz() throws java.io.IOException;	// 例外のthrows節は禁止
	<T> String foobar();	// ジェネリックメソッドは禁止
```

## アノテーションの適用

構文上、アノテーションの適用は修飾子になる。
マーカアノテーションの適用には次のように括弧をつけることも可能。一般的にはマーカアノテーションの場合、括弧を省略する。

```
#!java

// マーカアノテーションの適用例
@Override() -> 通常は @Override のみ
public String doJob(String in) {}
```

```
#!java

// アノテーションの適用例
@MyAnnotation(foo = "abc", bar = 42, baz = String.class)
public String doJob(String in) {}
```

指定する値の型は、アノテーション要素の型（見かけ上はメソッドの返り値の型）と一致させる。直感的には、アノテーションを適用することでアノテーション型のインスタンスを生成することになる。上記の例で言えば、値が"abc"や42やString.classのフィールド値を持つアノテーションオブジェクトを生成したことに相当する。アノテーションのインスタンスはオブジェクトではないので、厳密にはこの説明は正しくないが、直感的な理解には問題ない。

アノテーション要素の名前がvalueの時のみ、value = を省略可能。アノテーション要素valueのある具体例としてSuppressWarningがある。省略記法と省略しない記法の両方を示す。要素型が配列型の場合、次のように中括弧で値を指定する。

```
#!java

// value=を省略した記法
@SuppressWarnings({"deprecation", "divzero"})
public static void main(String[] args) {}

// value=を省略しない記法
@SuppressWarnings(value = {"deprecation", "divzero"})
public static void main(String[] args) {}
```

アノテーション要素の型が配列型でも、指定する値が1つであれば中括弧を省略可能。

```
#!java

// value=と中括弧を省略した記法
@SuppressWarnings("deprecation")
public static void main(String[] args) {}
```

アノテーション適用時にすべてのアノテーション要素の値を指定する必要がある。

アノテーション型宣言時に、アノテーション要素のデフォルト値の指定が可能。MyAnnotationのアノテーション型にデフォルト値を指定する例を示す。

```
#!java

// デフォルト値を指定したアノテーション宣言
public @interface MyAnnotation {
	String foo() default "012";
	int bar() default 42;
	Class baz() default String.class;
}
```

アノテーション適用時に値を指定しなければデフォルト値になる。すべてのアノテーション要素がデフォルト値を持っていれば、マーカアノテーション同様、括弧を省略して記述可能。

アノテーション適用時の値指定の必要性を減らすために、可能な限り、適切なデフォルト値を設定することを推奨する。

## メタアノテーション

クラスやインタフェースの型宣言にアノテーションを適用可能であるのと同様に、アノテーション型宣言にもアノテーションを適用可能。アノテーション型自体を修飾するアノテーションをメタアノテーションと呼ぶ。

|アノテーション名|説明|
|----------------|----|
|Documented|アノテーションを文書化対象するjavadocへの指示|
|inherited|アノテーションが自動的に継承されることの指示|
|Retention|アノテーションの存在期間を指示|
|Target|アノテーションの対象要素を指示|

## Retentionアノテーション

Retentionアノテーションの要素にはRetentionPolicyのenum値のいずれか1つを指定する。

```
#!java

// RetentionPolicy.javaから抜粋
public enum RetentionPolicy {
	SOURCE,
	CLASS,
	RUNTIME
}
```

RetentionPolicyのenum値は以下に示す意味を持つ。

|値|説明|
|--|----|
|SOURCE|アノテーションはソースファイルにのみ残る|
|CLASS|アノテーションはソースファイルとクラスファイルにのみ残る|
|RUNTIME|アノテーションはソースファイルとクラスファイルに残り、かつ実行時にも残る|

デフォルト動作はRetentionPolicy.CLASS。現実的によく使うのはSOURCEもしくはRUNTIME。

RUNTIMEを指定したアノテーションは実行時にリフレクションで読み取ることができる。コンパイル時に読み取るだけで十分なアノテーションは無駄を防ぐためにSOURCEを指定する。例えばOverrideアノテーションはコンパイル時には使うだけなのでSOURCEの指定になっている。

```
#!java

// Override.javaから抜粋
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {}
```

## Targetアノテーション

Targetアノテーションの要素にはElementTypeのenum値の配列を指定する。

```
#!java

// ElementType.javaから抜粋
public enum ElementType {
	TYPE,
	FIELD,
	METHOD,
	PARAMETER,
	CONSTRUCTOR,
	LOCAL_VARIABLE,
	ANNOTATION_TYPE,
	PACKAGE
}
```

Targetアノテーションは、アノテーションは適用可能なプログラムの構成要素を指示する。ElementTypeの各値は、アノテーションを適用可能なプログラム構成要素の一覧に対応する。

Overrideアノテーションの宣言を見ると、@Target(ElementType.METHOD)となっている。これはOverrideアノテーションをメソッドだけに適用可能であることを指示している。
SuppressWarningsアノテーションは次のように多くの要素に適用可能。

```
#!java

// SuppressWarnings.javaから抜粋
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
	String[] value();
}
```

DeprecatedアノテーションにはTargetアノテーションがない。Targetアノテーションのデフォルトは、すべての構成要素に適用可能。このため、Deprecatedアノテーションは適用可能なすべての構成要素につけられる。

```
#!java

// Deprecated.javaから抜粋
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Deprecated {}
```

## アノテーションの応用

アノテーションのついたメソッドをコールバックパターンで呼び出してみる。外部から任意のコードを与えることからプラグインアーキテクチャとも呼ぶ。プログラムの構造は「インタフェース」の章の「コールバックパターン」と全く同じ。インタフェースを定義する代わりにアノテーションを使う。

以下、コード例。

* [コード例](../../../../../commits/028f8b3cbce9fde0e9f4662045c793c97f50c03d)
* [コード例](../../../../../commits/b38909e1ddaccf3808733b1719665dd56dfd10b6)
* [コード例](../../../../../commits/233664f925c7afef7bd309b149ecce9411373029)

## アノテーションとPOJO

インタフェースを使わず、アノテーションでも同じような仕組みを構築できることがわかる。今回の例に限ると、アノテーション版は片安全性に劣る。なぜならメソッドの型を一切考慮していないから。これはリフレクションでメソッドの引数や返り値の方を検証することで解消できる。

インタフェース版の優れているところは、コンパイル時に振舞いを強制できること。文字列を受け取り文字列を返すメソッドをインタフェースで定義すれば、実装クラウはこの振る舞いに従わざるをえない。同時に、インタフェースでを実装することを宣言したクラスは、その目的が明瞭。

アノテーション版はインタフェース版よりも緩いコード。意図した動作をしないことがわかるのは実行時。実行時よりもコンパイル時に間違いを発見すべき、のプログラミングの原則からすれば劣ったアプローチ。

しかし、アノテーション版には１つ利点がある。プラグインするコードから他への依存性を完全に排除できる点。変わりやすい部分への依存はコードを脆弱にする。この視点を究極的に進めると、何も依存しないコードが最も堅牢である、という結論になる。他の一歳のクラスやインタフェースに依存しないクラスのオブジェクトをPOJOと呼ぶ。アノテーション版の Capitalize クラスはPOJOクラス。POJOクラスは単体テストが容易であったり、実行環境への配置が簡易であるという利点を持つ。

アノテーション版がインタフェース版の進化版だという主張はしない。現時点ではインタフェース版が本流の技法。ただし、新しい技法の可能性としてアノテーション版を考える価値はある。
