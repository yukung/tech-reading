# ストリーム

## Java のストリームクラスの概論

Javaのストリームクラスの抽象基底クラスは、
| |入力ストリーム|出力ストリーム|
|-|--------------|--------------|
|バイトストリーム|InputStream|OutputStream|
|文字ストリーム|Reader|Writer|

* ストリームは、使い終わったらクローズする必要がある。クローズ忘れはバグ（リーク）
* finally節を使ってクローズするイディオムに従う
* closeメソッド呼び出しでも例外が発生する。ファイルに対するclose処理で起きる例外の大半は、ディスクフルのための書き込み失敗。
* writeメソッドでの書き込みが全て成功していても、closeメソッドの失敗でファイルへの書き込みができていないことがあることに注意する。ファイルへの書き込みが遅延されることがあるため。
* 読み込みファイルでのclose失敗はほとんど起きないが、起きた場合はディスクの物理的な故障がありえる。
* ストリームクラスは、典型的なテンプレートメソッドパターンの好例となっている。
    * java.io.InputStream クラスを参照。

## バイトストリーム処理

* readメソッドの戻り値がbyteでなくintである理由は、ストリームの終端に達した時に-1を返す定義になっており、byte型より大きな型を返す必要があるので、intになっている。shortでもいいが、shortでもintでもいい場合はintを使う原則に従っている。
* writeメソッドの戻り値がintなのは、readメソッドとの対称性のため。byte型の値の範囲（-128から127の間でint型に型変換すると0から255になる）を越える値は単に上位ビットを無視して書き込みする。
* FileOutputStreamクラスは、既存ファイルを上書きして出力するか、もしくは末尾へ追記するかをオブジェクト生成時に制御できる。

## 標準入出力

* Java6以降には、 java.io.Console クラスがある。唯一のオブジェクトを System クラスの console メソッドで取得する。コンソールがあるか否かはプラットフォームに依存するので、consoleメソッドがnullを返す場合があることに注意する。

* [コード例](../../../../../commits/f963f0e316492758b25172fd63cb02fa2d781451)

## 文字ストリーム処理

* readメソッドの戻り値の型がcharではなくintである理由は InputStream と同様。
    * 読み込んだ文字の値を返す。戻り値の範囲は0から0xffffの間。ストリームの終端に達すると-1を返す。
* バイトの読み書きがただの8ビット単位の読み書きにすぎないのに対し、文字の読み書きには文字コードの問題がつきまとう。 FileReader クラスと FileWriter クラスは暗黙にデフォルトロケールを仮定する。明示的にロケールを指定するには InputStreamReader クラスと OutputStreamWriter クラスを使う。

* [コード例](../../../../../commits/48c33f23d1b5d113d6489b72329c325230824a67)

## バイトストリームから文字ストリームへの変換

InputStreamReader と OutputStreamWriter は文字ストリーム。コンストラクタにはバイトストリームオブジェクト（InputStream, OutputStream）を与える。
InputStreamReader と OutputStreamWriter を使う主な目的は次の通り。

* ソケットなど直接にはバイトストリームしか取得できないクラスの場合、バイトストリームから文字ストリームを得るため。
* 文字コード（ロケール）を指定した文字ストリームを得るため。

ファイルを読む場合、バイトストリームの FileInputStream オブジェクトをコンストラクタの引数に渡して InputStreamReader オブジェクトを生成する。なお、 InputStreamReader と OutputStreamWriter をクローズすると、引数で与えたバイトストリームも同時にクローズする。

* [コード例](../../../../../commits/a619e7b5263ecd3b7d533d9e922e46529cbc1933)

## バッファリング

ディスクへの読み書きは一般にメモリに比べて低速である。ファイルストリームに対して1バイトずつもしくは1文字ずつ読み書きをすると動作が非常に遅くなる。1バイトや1文字単位でディスクへのアクセスが発生するため。

この課題に対して「バッファリング」という技法を使って、動作を高速化する。

読み込みの場合、裏でまとめてディスクからメモリに読み込み、ディスクへのアクセスを減らす。読み込むメモリ領域をバッファという。readメソッドはバッファからデータを返す。読み込み済みのデータがなくなると、次のreadメソッドの時に、再びまとめてディスクからバッファに読み込む。

書き込みの場合、writeメソッドでデータを一旦バッファに書き込み、writeメソッドを繰り返し呼び、用意したバッファ領域がいっぱいになると、まとめてデータをディスクに書き出す。（バッファリングしてもストリームの実装クラスが最終的に使うメソッドが1バイト単位のreadメソッドでは遅いままなので、FileInputStream はreadを使わない readBytes メソッドを用意している）

ネットワークへの読み書きもメモリに比べて低速なので、バッファリングが一般的。

## バッファリングストリーム

バッファリングを実装したストリームが標準クラスとして存在する。

| |入力ストリーム|出力ストリーム|
|-|--------------|--------------|
|バイトストリーム|BufferedInputStream|BufferedOutputStream|
|文字ストリーム|BufferedReader|BufferedWriter|

通常のストリームオブジェクトを引数に渡して、バッファリングストリームオブジェクトを生成する。内部的には非バッファリングストリームオブジェクトを包み込む形でバッファリングストリームオブジェクトが存在し、かつバッファリングストリームクラスは非バッファリングストリームクラスの継承クラス。

参照する変数の型を基底クラスにすることで、バッファリングストリームオブジェクトを通常のストリームオブジェクトと変わらず扱うことができる。FileBufferedByteバッファリングをするか否かの切り替えはただオブジェクト生成の部分だけ。他の部分は一切変更する必要がない。（このように機能拡張をしながら元のオブジェクトと同じように扱える実装技法を、デザインパターンでデコレータパターンと呼ぶ。）

* [コード例](../../../../../commits/7efbc8f78100d0eb8d2536e09a97510d780d21a6)

## バッファリングの方針

出力ストリームをバッファリングした場合、writeメソッドを呼んでも実際の書き込みが行われている保証はない。実際の書き込みは将来のwriteメソッドのタイミングかもしれないし、最大では出力ストリームをクローズしたタイミングまで遅延する。ネットワーク送信などでは問題になることがあるため、その場合は BufferedOutputStream と BufferedReader のflushメソッドを呼ぶことで、出力バッファの中身を強制的に出力できる。

ファイルやネットワークに対するストリームではバッファリングはほぼ必須。常にまとまった量のデータを読み書きするなら、バッファリングは不要。なぜなら、バッファへデータをコピーする手間だけ少し遅くなるため。

ただ、バッファリングを使うか否かのような些細な事に気を紛らわすぐらいであれば、ファイルやネットワークのストリームでは常にバッファリングを行う、という方針を徹底するほうが簡単。

## ランダムアクセス

ファイルをストリームとして見立てると、ファイルを先頭から読む、先頭もしくは末尾からかくことしかできなくなる。これはストリーム抽象化の本質で、操作を限定することでファイル以外の様々な対象を等価に扱うことができるようになる。

一方で、ファイルそのものは、ファイルの任意の位置へ読み書きできるランダムアクセスの機能を持つ。この機能を扱えるクラスが RandomAccessFile クラス。RandomAccessFile クラスはストリームとは別の視点でのファイルの抽象化。

RandomAccessFile オブジェクトを生成するには、ファイル名とモードを指定。モードは文字列で、

* "r"
    * 読み込み専用。書き込んだ場合は実行時例外が発生。
* "rw"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。
* "rws"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。ファイルの内容とメタデータの書き込み処理を遅延しない（バッファリングしない）
* "rwd"
    * 読み書きモード。ファイルが存在しない場合は、新規作成。ファイル内容の書き込み処理を遅延しない（バッファリングしない）

の4つ。

RandomAccessFile オブジェクトは読み書きしている位置を示すファイルポインタを持つ。ファイルポインタはファイルの先頭から数え始める0から始まるオフセット値。getFilePointerメソッドで取得して、seekメソッドでファイルポインタ値を変更できる。これは入力ストリームにはできない動作。

writeメソッドによる書き込みでもファイルポインタが自動的に移動する。seekを使うと、ファイルポインタ値を変更できる。現在のファイルサイズよりも大きな値をseekメソッドに指定して書き込みを行うと、ファイルサイズを拡張する。seekで飛んだ部分は0で埋められる。ファイルサイズを越えた部分のreadメソッドは、ただ-1（ファイルの終端）を返す。

* [コード例](../../../../../commits/db082d31b52d64447e45081b9e5fcd7bbfc115de)

## ファイル操作

ファイル名を変更したり、ファイル自体を削除したりなどの、ファイル自体に対する操作が存在する。この機能を提供するクラスが、File クラス。 File クラスは、ファイルの中身ではなくファイル名（厳密にはファイルパス名）への操作を提供するクラス。

File クラスのオブジェクト生成は、（指定したファイルパスへの）ファイル作成を意味しない。実際にファイルを作成するには createNewFile メソッドを呼ぶ。同名のファイルが既に存在する場合は何もしない。 createNewFile メソッドはファイルを新規に作成した場合に true を返し、同名のファイルが存在した場合は false を返す。

作成、移動、削除が主な操作。作成、移動、削除があると、複製（コピー）も基本的操作に含めたいと考えるかもしれないが、File クラスに copyメソッドは存在しない。複製は元のファイルを読み込んで、複製先のファイルに書き込むことで実現する。

## ディレクトリ操作

ディレクトリに対する操作も File クラスで行える。 File クラスの isFile メソッドと isDirectory メソッドで File オブジェクトに対応するファイルがファイルかディレクトリかを判定できる。

* [コード例](../../../../../commits/f9333ac9eb965fdf74f01c3a8bf5c3f2e3a92720)

## ディレクトリのファイル一覧

File オブジェクトの list メソッドを呼ぶと、File オブジェクトが参照するディレクトリ以下のファイルパス名の配列を返す。
listFiles メソッドを使うと、ディレクトリ以下のファイルの File オブジェクトの配列を返す。

* [コード例](../../../../../commits/ee2c380d34bb5b8188350f894d53fde3aa55ef73)

list メソッドには次のように FilenameFilter オブジェクトを引数に取るメソッドが存在する。FilenameFilter は accept メソッドだけを持つインタフェース。
list メソッドで得られるファイル一覧に対して、それぞれのファイルパス名毎に accept メソッドが呼ばれる。accept メソッドが true を返したファイルだけが list メソッドの戻り値の配列の要素になる。フィルタ用のファンクタを渡す技法はコールバックパターンの一種。

次の例では、ルートディレクトリ直下のファイルの家、ディレクトリ名がtmpで始まらないディレクトリのみを列挙する。FilenameFilter オブジェクトを匿名クラスで生成している。

* [コード例](../../../../../commits/0075cd4f47c24edaa4e0cb1e67dd1a1634624dbc)

以下は、ファイルを再帰的に表示する例。listFiles メソッドを再帰的に呼ぶ。

* [コード例](../../../../../commits/38da34fbff8c3019475c46898ab8a2b264e55439)

## バイト列ストリーム

文字列の場合は、不変な文字列としてStringクラス、変更可能な文字列としてStringBuilderクラスがある。バイト列の場合は、byteの配列を使うことで変更可能なバイト列を得られるが、配列の長さは変更できない。メモリ上で可変長のバイト列を扱うために ByteArrayOutputStream クラスを使うことができる。長さを気にせずバイト列を書き足す処理をしたい時に利用できる。

可変長の文字列を扱う CharArrayOutputStream クラスもあるが、文字列に関しては通常StringBuilderで事足りる。

* [コード例](../../../../../commits/c8b41bea6328eb84a6572d8e654cd147e063ae24)

## ネットワーク（ソケット）

ネットワークでのデータの入出力にはソケットと呼ぶ抽象化層を使う。ソケットは通信先の相手と1対1に繋がる仮想的な線を考えその端点にデータを読み書きする機能。Javaでは、ソケットへのデータの読み書きをストリームで扱う。

ソケットには、サーバとクライアントという区分けはなく、接続を待ち受けるソケット（受動的なソケット）と、自分から接続しに行くソケット（能動的なソケット）の2つがあるだけ。通常、サーバプログラムは受動的ソケットを使い、クライアントプログラムは能動的ソケットを使う。

受動的ソケットはクライアント（能動的ソケット）からの接続があったら新しく待ち受けソケットを生成することで、複数のクライアントからの接続を受け入れることができる。

ソケットは、

* 自分自身（ローカル）のIPアドレスとポート番号、接続相手（リモート）のIPアドレスとポート番号の4つ組からなる

接続開始までの動作は非対称だが、接続を確立すると2つの通信プロセスの関係は対称になる。通信を終了するにはソケットをクローズするが、どちらからでも行える。

ソケットに対するデータの中身、またどちらからデータを送り始めるかなどを規定するのはTCP/IPより上位の通信プロトコルの責務。WebであればHTTPなどが相当する。

## クライアント処理

接続を開始する側のソケット（能動的ソケット）を使うネットワーク処理をクライアント処理と呼ぶことにする。
クライアント処理は最初にソケットオブジェクトを生成する。

ソケットオブジェクトは java.net.Socket クラスのオブジェクト。

処理の流れとしては、

1. リモート（接続相手）のホスト名もしくはIPアドレスとポート番号を指定して、能動的ソケットオブジェクトを生成する。
    * ローカル（自分自身）のIPアドレスとポート番号を明示的に指定することもできる。指定しない場合はローカルのIPアドレスはシステム（OS）のデフォルトのIPアドレスを使い、ローカルのポート番号は空いている番号を自動で選ぶ。多くの場合ローカルのIPアドレスとポートは指定する必要はない
    * ホスト名を渡した場合、オブジェクト生成時に名前解決を暗黙に行い、名前解決ができない場合は UnknownHostException 例外が発生する
2. サーバと接続が確立すると Socket オブジェクトが生成される。データの送受信を行うには Socket オブジェクトから入出力ストリームを取得する。入力ストリームは getInputStream メソッド、 出力ストリームは getOutputStream メソッドで取得する
3. ストリーム取得後は、ファイル入出力と同様の方法でデータ入出力を行える
4. ソケットをクローズすると、暗黙に対応するストリームもクローズする。一般に、ストリームではなくソケットの close メソッドを呼ぶ。ソケットは finally 節イディオムでクローズすることを推奨する。

[コード例](../../../../../commits/d16961ec9810c66f6c66fd5afdbb3d8a2c833781)

## サーバ処理

受動的な待ち受けソケットを作成し、能動的なソケットからの接続を受け入れるネットワーク処理をサーバ処理と呼ぶことにする。
サーバ処理は最初に待ち受けソケット用のソケットオブジェクトを生成する。

待ち受けソケットオブジェクトは java.net.ServerSocket クラスのオブジェクト。

処理の流れとしては、

1. ServerSocket クラスのオブジェクトの生成時に待ち受けポート番号を指定するか、オブジェクト生成後に bind メソッドでポートを指定する方法がある。通常は生成時にポート番号を指定する
2. ServerSocket オブジェクトの accept メソッドで待ち受けメソッドは接続待ち状態になる。接続があるまで accept メソッドは待機する。つまり accept メソッドを呼び出したスレッドは処理を停止する（専門的にはブロックするという）プログラムが1スレッドであれば、事実上プログラムは何もせずに止まったままとなる。
3. リモートの能動的なソケット（クライアントプログラム）から接続を受け付けると、accept メソッドは新たな Socket オブジェクトを返す。この Socket オブジェクトは受け入れソケットのオブジェクト。このソケットオブジェクトから入出力ストリームを取得することで、接続相手と通信が可能。
    * 上記でも述べたが、受け入れソケットはクライアント側の能動的ソケットと完全に対象な関係なので、どちらからでもデータを送信可能であるし、どちらからでもソケットをクローズ可能。これらの順序を決定するのは上位のプロトコルの決まりで、ネットワークプログラムを作成する開発者の責任。

[コード例](../../../../../commits/4b74ae367cc9b2affe7a5496460d39017815dc79)

accept メソッドの戻り値で受け入れソケットオブジェクトを取得する。受け入れソケット取得後の処理はクライアント側コードと区別がないことに注目。ただし読み書きの順序は対称的になる。MyClientが送信してから受信しているのに対し、MyServerは受信してから送信している。お互いの順序を逆にしても動作する。

## タイムアウト処理

ソケットストリームのデフォルト動作では、ServerSocket オブジェクトの accept メソッドの呼び出し、能動的ソケットオブジェクトの Socket オブジェクト生成、およびソケットストリームへの送受信処理で、相手側が反応しない限りは待ち続ける（ブロックする）。現実的なネットワークプログラムでは相手がいるかどうかは不明。相手の都合でプログラムが止まるのは困るので、タイムアウト処理が必要となる。

タイムアウト処理は次のように行う。

* ServerSocket の accept メソッドのタイムアウト処理は ServerSocket の setSoTimeout メソッドを呼ぶ。acceptメソッドの呼び出し前に設定する必要がある。設定値の単位はミリ秒。
* クライアント側の能動的メソッドの接続開始処理のタイムアウト設定を行うには、まず Socket オブジェクトを引数なしで生成する。コンストラクタの引数に接続先情報を渡すと Socket オブジェクト生成時に接続を開始するが、引数なしで生成すると接続を開始しない。Socket オブジェクトの connect メソッドを明示的に呼ぶことで接続を開始する。connect メソッドの引数にタイムアウト値を設定する。
* サーバ側の受け入れソケット及びクライアント側の能動的ソケットは setSoTimeout メソッド値を設定できない。 write メソッドは内部でバッファリングしているため、相手側の受信のいかんにかかわらず一定量のデータはブロックしない。別の見方をすると write メソッドが正常に終了しても相手側にデータが届いている保証はない。バッファリングのサイズを越えた write メソッドはブロックする。相手側が受信しなければ永遠に停止する。ただし、相手側がソケットをクローズすると write は IOException 例外で停止から抜ける。

* [コード例１](../../../../../commits/d67b8aa3d0b19f82df7f6db15d2766bffda293aa)
* [コード例２](../../../../../commits/cc84e72617c422633ba9c7717ff10f20a9a86d7d)

## ノンブロッキングモード（NIO）

write処理まで含めてタイムアウト値を制御するには、ノンブロッキングモードのソケットを使う必要がある。ノンブロッキングモードのソケットは java.nio パッケージにある。ノンブロッキングモードでは Socket の代わりに SocketChannel、ServerSocket の代わりに ServerSocketChannel を使う。

チャネルオブジェクトを java.nio.channels.Selector オブジェクトに登録すると、Selector オブジェクトの select メソッドでチャネルの状態を確認できる。チャネルの状態は以下の4種類がある。

* 受動的ソケットが受け入れ可能（accept）
* 能動的ソケットが接続完了（connect）
* データ受信可能（read）
* データ送信可能（write）

ノンブロッキングモードのソケットストリームのreadやwriteは、ブロックすることがない。ノンブロッキングモードのソケットを使うコードは、Selector の select メソッドで状態を確認してから、可能な操作だけを行う。結果的にブロックしない動作を実現できる。

ノンブロッキングモードのソケットと Selector を組み合わせると、スレッドを使わずに並行処理を行うことができる。 Selector で複数のソケットオブジェクトの状態を同時に走査できるため。適切にコードを書くとネットワークプログラミングをイベントドリブンで記述できる。

select メソッドにはタイムアウト値の設定が可能。なお、データ送信可能の意味は内部的な送信バッファに空きがあることを示しているだけなので、通信相手がデータ受信可能かを示しているわけではない。ブロッキングモード同様、write メソッドによる書き込みは相手側にデータが届いた保証はしない。

[コード例](../../../../../commits/3d8d07896fc5cfe44e47af7d11bb36c39c68a276)

## HTTPクライアント

HTTPは自分でソケットプログラミングをする必要がない。標準クラスの java.net.HttpURLConnection がHTTPクライアントの機能を提供する。

[コード例](../../../../../commits/8b376db69e157e721620fdcfab3ec6c11385e605)

HTTPの実装に関して、HTTP1.1をまじめに実装するとContent-Lengthヘッダを解釈してデータ長を知る必要がある。ファイルと違い、TCP/IPのデータ受信には終端という概念がないため。読み取るデータがない時、全てを受信し終わったのか、次のデータが届いていないのかを区別できないため。

データの終端を定義するのはTCP/IPより上のアプリプロトコルの責任。一般に終端定義には3つの手法が存在する。

* データ長を送る手法
    * Content-Lengthでデータ長を送るHTTPなどが代表的
* 終端を示す文字や文字列を定義する手法
    * SMTPなどがこれに相当する
* データを受信し終わるとソケットをクローズして終端を示す手法
    * HTTP1.0で使う手法

## 並行処理

ServerSocket オブジェクトの accept メソッドは、接続を確立すると受け入れソケットを生成して返す。受け入れソケット生成後も待ち受けソケットオブジェクトは残る。

ServerSocket オブジェクトに対して accept メソッドを再び呼ぶと、次の新しい通信相手からの接続を受け入れることができる。次のような構成のサーバプログラムを作ると、次々に新しいクライアントからの接続を受け入れることができる。

```
#!java

// 逐次処理のサーバ
ServerSocket ss = new ServerSocket(LISTEN_PORT); // 待ち受けソケット
while (true) {
	// 新しい接続を開始
	Socket s = ss.accept(); // 受け入れソケット取得
	// 受け入れソケットを使い、クライアントと通信
	s.close(); // 受け入れソケットをクローズ
}
```

逐次処理のサーバでは、1つのクライアントプログラムと通信している間、新しい接続を受け入れることができない。次の接続を受け入れるには accept メソッドを呼ぶ必要があるため。

一般的なサーバプログラムでは、複数のクライアントからの接続を受けつけ、かつ複数のクライアントと通信を同時処理する必要がある。このような並行処理を行う1つの方法がスレッドを使う手法。

スレッドを使う並行処理のサーバの構造は次のようになる。

```
#!java

// 並行処理のサーバ
ServerSocket ss = new ServerSocket(LISTEN_PORT); // 待ち受けソケット
while (true) {
	// 新しい接続を開始
	Socket s = ss.accept(); // 受け入れソケット取得
	// クライアントと通信する別スレッドを生成（受け入れソケットを渡す）
}
```

## ネットワークインターフェース

自分自身（ローカル）のIPアドレスを取得するには java.net.NetworkInterface クラスを使う。
複数のローカルIPアドレスがあるのが普通なので、IPアドレスの取得メソッドはコレクションを返す。

[コード例](../../../../../commits/3cfbe2ed59a46fd385ce1ceddf0cdb4cffa54853)
