# クラス

## Javaの型

* Javaでは、変数の型とオブジェクトの型と一致させないことにより多態性を実現できる

## オブジェクトを生成する手段

* new式による明示的な生成
* Stringリテラル表記および結合演算式による暗黙の生成
* オートボクシングによる暗黙の生成
* リフレクションによる生成
* Objectクラスのcloneメソッドによる複製

## オブジェクトのライフサイクル管理

* 変数のスコープに注意して、不要に長い寿命を持つオブジェクトをなくす
* オブジェクトの寿命を意識して、寿命の短いオブジェクトと寿命の長いオブジェクトを分離する
* ファクトリパターンやDIなど、オブジェクト生成に着目した技法を活用する
* オブジェクトのライフサイクル管理をフレームワークなどの階層に隠蔽する

などの技法がある。

## ファクトリパターン

基本的な考え方としては、オブジェクト生成を1つの役割とみなして、その機能を分離すること。

```
#!java

class My {
	private My {}
	static My getInstance() {
		My my = new My();
		return my;
	}
}
// 呼び出し側
My my = My.getInstance();
```

ファクトリメソッドには、次の利点がある。ファクトリメソッドを提供する場合、コンストラクタのアクセス制御をpublicにすべきではない。コンストラクタを外部から直接呼ぶ手段を禁止し、APIドキュメントに、オブジェクトの生成方法を明記する。

* コンストラクタと異なり、自由にメソッド名をつけられるので、生成のために意味のある名前を付けられる
* ファクトリメソッドは、必ずしも新規のオブジェクトを生成して返す実装にする必要はない
    * 生成済みオブジェクトをプーリング（キャッシュ）して、ファクトリメソッドがプール内のオブジェクトを返すオブジェクトプーリング（オブジェクトキャッシング）が可能
    * シングルトンパターン（オブジェクトの数を1つに制限する技法）が使える。ファクトリメソッドが常に同じオブジェクトを返す実装をする。
* ファクトリメソッドの戻り値の型を抽象型にできる
    * 具象クラスへの依存をファクトリクラスだけに限定でき、呼び出し側のクラスは依存を減らせるので堅牢なコードになる（変更に強い）

## ユーティリティクラス

オブジェクトを生成せずに直接使う。例えばjava.lang.Mathクラスのメソッドなどはユーティリティクラスのメソッド。
自分でユーティリティクラスを作成するときは、以下の方針を守る。

* コンストラクタをprivateにして、インスタンス化を禁止する。
* finalクラスにして、無用な継承を禁止する。
* すべてのメソッドとフィールドにstatic修飾子をつける

static修飾子をつけるのは、本質的に処理に状態を持つ必要がない場合で、これらはユーティリティクラスとして抽出できる。

## クラス

* クラスに使える修飾子

|修飾子|意味|
|------|----|
|public|publicにするとグローバルスコープ。書かないとパッケージスコープ。|
|final|継承による拡張を禁止|
|abstract|抽象クラス|
|strictfp|クラス内に記述した浮動小数点演算を厳密に評価|
|アノテーション|定義したアノテーションで挙動を制御する|

## フィールド

* フィールド宣言と同時にフィールド変数を初期化できる。明示的な初期化をしない場合、デフォルト初期値になる。

|型|デフォルト初期値|
|--|----------------|
|参照型|null|
|boolean|false|
|char|'\u0000|
|byte, short, int, long|0|
|float, double|+0.0|

* フィールド宣言と同時に変数を初期化するコードは、オブジェクト生成のタイミングで実行される。

```
#!java

public class My {
	public static void main(String[] args) throws Exception {
		My my1 = new My();
		System.out.println(my1.createdAt);
		Thread.sleep(1000);
		My my2 = new My();
		System.out.println(my2.createdAt);
	}
	long createdAt = System.currentTimeMillis(); // オブジェクト生成時に初期化される
}
```

## フィールド宣言の修飾子

|修飾子|意味|
|------|----|
|public|すべてのクラスから参照できる|
|protected|自身とサブクラスから参照できる|
|private|自身からしか参照できない|
|final|再代入を禁止|
|static|クラスフィールド|
|transient|シリアライズの対象外のフィールドとする|
|volatile|スレッド間で変数の値を同期する|

## 変数this

* ローカル変数とフィールド変数の名前が被る時は、フィールド変数にthisを付ける必要がある。変数のスコープの項を参照。

## メソッド

## メソッド宣言の修飾子

|修飾子|意味|
|------|----|
|public|すべてのクラスから呼び出せる|
|protected|自身とサブクラスから呼び出せる|
|private|自身のみ呼び出せる|
|abstract|抽象メソッド|
|final|オーバーライド不可|
|static|クラスメソッド|
|synchronized|同期のためのロック獲得|
|native|ネイティブメソッド|
|strictfp|浮動小数点演算を厳密に評価|

## メソッド引数（パラメータ変数）とローカル変数

* パラメータ変数とローカル変数は、メソッドが呼ばれた時にのみ変数として存在する。メソッドを抜けると、変数は消滅する。変数が存在することと、参照先のオブジェクトの存在は無関係であることに留意する。（独立して存在するのは変数）
* パラメータ変数とローカル変数がメソッド呼び出し毎に常に新規に存在し、メソッドを抜けると同時に消滅する動作を特に意識するのは、マルチスレッド動作と再帰呼び出しの時。

## メソッドのシグネチャ

あるクラスの中でメソッドを一意に区別するために必要な情報。

* メソッド名
* 引数の型の並び

引数名（仮引数名）はシグネチャに含まれない。

## 再帰呼び出し

* [コード例](../../../../../../../../commits/26d9803d2ffcd51fe533e2383b27d42a0311ad99)

再帰呼び出しとループ処理はどちらも本質的に繰り返し処理。

再帰処理は、入力値を列とみなして、先頭の要素と残りの要素に分けて考える。再帰メソッドは先頭要素があるかをチェックする。先頭要素がなければ何もしない。先頭要素があれば処理をする。残りの要素列（入力値から処理済み先頭要素を取り除いた列）を実引数として自分自身のメソッドを呼ぶ。

再帰呼び出しも停止するための条件判定が必要。これを停止条件と呼ぶ。無限な再帰呼び出しを書くと、StackOverflowError実行時例外が発生する。このバグは絶対に修正するバグ。

ループで書ける処理は必ず再帰処理で書ける。逆も真。多くの場合はループ処理で書くことを推奨するが、一部のアルゴリズムは再帰処理で書くとコードが簡潔になる。

## 可変長引数

内部的には配列として引数が渡る。可変長引数を使うコードのほうが記述が簡単になるケースがある。
原理上、可変長引数は最後の1つの引数にだけ使える。

```
#!java

void doit(int i, String... messages) // OK
void doit(int i, String... messages, String... m2) // コンパイルエラー
void doit(int i, String... messages, int i) // コンパイルエラー
```

## コンストラクタ

指定できる修飾子は以下。

* public
* protected
* private

コンストラクタ内から、フィールドアクセスやメソッド呼び出しができるが、これらは推奨しない。オブジェクト初期化処理の順序を意識しないと微妙なバグを生み出しやすいから。
コンストラクタには戻り値がない。厳密に言えば、new演算子を使った式の評価値がオブジェクトの参照値であって、コンストラクタ呼び出しの返り値が参照値というわけではない。

## コンストラクタの意義

コンストラクタを使うことで同じスタイルの初期化処理を強制できる。

```
#!java

// 悪い例
Book book = new Book();
book.initTitle("Peopleware");
book.initPrice(2310);
book.initAuthor("Demarco");
book.initTitle(DateFormat.getDateInstance(DateFormat.SHORT).parse("11/26/01"));
```

初期化に順序がある場合はさらに悪くなる。initとして分かるようにしていても未来の誰かにとってそれは自明ではなくなる。
順序があるなど暗黙の規則がある場合は、言語の機能やプログラミングの技法で強制すること。上記の例であればコンストラクタに順序も含めて初期化処理を隠蔽することで、クラスを使う側に初期化処理を強制できる。

また、オブジェクトの完全性を意識するプログラミングができることも利点。理想的なオブジェクトは生成時に完全な状態で生まれるべき。コンストラクタでオブジェクトを完全な状態に初期化できるように意識する。（ただし、初期化処理を遅延させることで有効な場合も存在する。SQLのリレーションがあるオブジェクトをO/Rマッピングする時など）

## this呼び出しとsuper呼び出し

コンストラクタのオーバーロードで、初期化するフィールドの値が違うコンストラクタを定義することができる。これを利用して、コンストラクタ内からほかのコンストラクタを呼び出すことで初期化の共通部分をまとめることができる。

* [コード例](../../../../../../../../commits/14fa2c4fd3e6e590539e5c1e45d734bda62554a3)

同様に、拡張継承したクラスの初期化の際に継承元のコンストラクタを呼び出し、拡張部分だけをサブクラスで初期化するようにして、初期化処理を共通化できる。

* [コード例](../../../../../../../../commits/1ccf5ccf39c12eb7acfb94d483e8d2c26f87dde0)

## デフォルトコンストラクタ

コンストラクタ宣言が1つもないクラスには、引数なしのコンストラクタが宣言されているとみなされる。暗黙にできる引数なしのコンストラクタをデフォルトコンストラクタと呼ぶ。
デフォルトコンストラクタのアクセス制御は、クラス自身のアクセス制御を引き継ぐ。暗黙のsuper呼び出しを含めると、次の3つのコードは同じになる。
```

#!java

// 以下の3つは同じ
class My { // デフォルトコンストラクタができる
}

class My {
    My() {}
}

class My {
    My() {
        super();
    }
}
```

デフォルトコンストラクタは、コンストラクタ宣言が1つもない場合のみに暗黙に作られる。1つでもコンストラクタを書き足すとデフォルトコンストラクタは消滅する。そのため、コンストラクタがなかったクラスに新しいコンストラクタを追加した途端、次のようなエラーを引き起こすことがある。

```
#!java

class My {

	private int num;
	// コンストラクタがなかったクラスに新しいコンストラクタを追加した途端...
	My(int num) {
		this.num = num;
	}

}

// 別の場所にある new My() の呼び出し箇所がコンパイルエラーもしくは実行時エラーになる
My my = new My();

// Myクラスを継承するクラスが引数のないコンストラクタに依存しているとコンパイルエラーもしくは実行時エラーになる
class Sub extends My {
	// デフォルトコンストラクタは暗黙に引数なしのMyのコンストラクタを呼ぶ
}

class Sub extends My {
	Sub() {}	// 暗黙に引数なしのMyのコンストラクタを呼ぶ
}

class Sub extends My {
	Sub(int num) {
		super();	// 明示的に引数なしのMyのコンストラクタを呼ぶ
	}
}
```

## 初期化ブロック（インスタンスイニシャライザ）

オブジェクトの初期化を行うための仕組みに初期化ブロックがある。
クラスの中に初期化ブロックを書くと、オブジェクトの初期化時に実行される。初期化ブロックはいくつでも書くことができる。複数の初期化ブロックはコードに書かれた順に実行される。

```
#!java

class My {
    int i;
    // 初期化ブロック
    {
        i = 5;
        System.out.println(i);
    }
}
```

初期化ブロックの役割はコンストラクタとほぼ同じ。初期化ブロックの用途は主に次の2つ。

* 全てのコンストラクタの共通処理を記述
* 匿名クラスの初期化のため（匿名クラスにはコンストラクタがないため）

## オブジェクト初期化処理の順序

オブジェクトの初期化時に走る処理は、次の順序で実行される。

1. フィールド変数にデフォルト値代入
2. フィールド宣言時の初期化および初期化ブロックをコードで上から書かれた順に実行
3. コンストラクタ呼び出し

```
#!java

// オブジェクト初期化時は、下記の数字の順に実行される。
class My {
    int i = 1;
    {
        System.out.println("2");
    }
    int j = 3;

    My() {
        System.out.println("6");
    }
    int k = 4;
    {
        System.out.println("5");
    }
}
```

## クラスフィールド、クラスメソッド

* クラスフィールドにオブジェクト参照を通じてアクセスするのではなく、クラス.フィールドのようにアクセスすること。
* クラスメソッドも同様だが、クラスフィールドよりも切実な理由として、クラスメソッドには多態性が機能しないことがある。

* インスタンスメンバ（インスタンスメソッド、フィールド変数の初期化子とインスタンスイニシャライザ）、コンストラクタ、クラスメソッドを除くと、クラスフィールド変数のスコープは宣言行以降。
* インスタンスフィールド変数とクラスフィールド変数は同じ名前空間に属するので、同名のフィールド変数は宣言できない。
* クラスメソッドはクラスに属するものでオブジェクトに属するものではないので、クラスメソッドの中からインスタンスフィールドにアクセスしたり、インスタンスメソッドを呼び出すことはできない。また、クラスメソッド内でthis変数は使えない。
    * ただし、引数で受け取ったオブジェクトに対して、インスタンスフィールドにアクセスしたりインスタンスメソッドを呼び出すことはできる。

## staticイニシャライザ

オブジェクト用の初期化ブロック（インスタンスイニシャライザ）と同様の仕組みとして、クラス用にstaticイニシャライザが存在する。
staticイニシャライザはいくつでも書くことができる。複数のstaticイニシャライザはコードに書かれた順に実行される。
staticイニシャライザの実行順序の規則と具体例としては、

1. クラスフィールド変数にデフォルト値代入
2. クラスフィールド変数宣言時の初期化およびstaticイニシャライザをコードで上から書かれた順に実行

```
#!java

// クラス初期化時は、下記の数字の順に実行される
class My {
    static int i = 1;
    static {
        System.out.println("2");
    }
    static int j = 3;
}
```

## クラスをオブジェクトとして扱う問題点

* クラスフィールドとクラスメソッドを使うと、クラス自身をオブジェクトのように扱えるように見えるが、実際はオブジェクトとして参照値でコレクションの要素に持たせたり、メソッドに引数として渡したりすることができないので、そういう使い方はしない。
* クラス自身を扱うと、グローバルスコープでどこからでも見える（参照できる）ので、コードの構造をわかりづらくする。また、継承による恩恵も受けられない。

## クラスフィールドとクラスメソッドの用途

クラスフィールドとクラスメソッドは次のような用途に限定すべき。

* ユーティリティクラスのメソッド
* クラスの役割（型定義とひな形）に関連する状態や操作

後者の例として、オブジェクトの生成数を数えるクラスを考える。現実のプログラミングでは、これを応用してシングルトンオブジェクトパターンやオブジェクトプーリングを行える。

```
#!java

class My {
    private My() {}
    static int instance_num;
    static My getInstance() {
        instance_num++;
        return new My();
    }
}
```

## クラスの共通処理

共通な処理をくくり出す方法として、以下の3つがある。

* 手続き（メソッド）として共通部をくくり出す
* 共通部をクラスとしてくくり出して、そのオブジェクト参照をフィールドに持ち、処理を受け渡す（**移譲**する）
    * 共通部分を横に追い出すイメージ
* 共通部を基底クラスとしてくくり出して、クラスを階層管理する（継承）
    * 共通部分を上に追い出すイメージ

クラスの継承は、実装の継承（オーバーライド）と振る舞いの継承（インタフェース）の2つの視点がある。
実装の継承（拡張継承）は、単なる共通処理のくくり出しではなく、**型定義の共通部のくくり出し**として捉える必要がある。

継承による依存関係は強い関係になるので、濫用はコードの柔軟性を落とす。
移譲で書くべき関係（**共通処理を単にくくり出す処理**）を拡張継承で書くのは避けるべき。

## 継承について

* 上位クラスの構成要素を下位クラスは受け継ぐが、単に引き継ぐのであればextendsは単なる省略記法でしかない。
* 継承の強みは、継承したメソッドをオーバーライドして、多態性を使えることにある。
* 引き継ぐ要素の削除は基本的には不可能。ただし、privateにしたり、メソッド内でUnsupportedOperationExceptionを投げるようにオーバーライドすれば使えなくはなる（削除と言うより変更）

## フィールド変数の隠蔽

* 継承したクラスで継承元と同じフィールド名で宣言すると、継承元のフィールド変数を隠蔽する。隠されるだけで存在はしているので、superなりキャストしたthisなりで呼び出せる。
* つまり、フィールドはメソッドと違ってオーバーライドされず、別々に存在する。

## オーバーライドで気をつけること

* 同じメソッド名
* 引数の数と型がすべて一致
* 戻り値の型が一致、もしくは戻り値の型が継承型（たとえば、CharSequenceを返すメソッドをStringを返すメソッドでオーバーライド可能）
* throws節の例外型が一致、もしくは継承した例外型（たとえば、throws IOExceptionのメソッドをthrows EOFExceptionでオーバーライド可能）
* アクセス制限が一致、もしくはより緩いアクセス制限（たとえば、protectedのメソッドをpublicでオーバーライド可能）

これらが満たされない場合、オーバーライドされない。（引数の型が継承型だったりした場合、同じ名前のオーバーロードされたメソッドとしてしか存在しない）
オーバーライドを意図するには、@Overrideアノテーションをつけること。

## 継承時のオブジェクト初期化処理の順序

1. 継承分も含めたすべてのフィールド変数にデフォルト値代入
2. 次のAとBを継承階層の最上位型（Objectクラス）から順に実行
    1. フィールド変数宣言時の初期化および初期化ブロックをコードで上から書かれた順に実行
    2. コンストラクタ呼び出し

## super呼び出し

* super呼び出しが明示的にない場合、コンストラクタは暗黙に継承元クラスの引数なしコンストラクタを呼び出す。

## 抽象クラスと抽象メソッド

抽象クラスになる条件は、

* 抽象メソッドを持つクラス
* interfaceを実装して、interfaceのすべてのメソッドの実装を持たないクラス
* 抽象クラスを継承して、すべての抽象メソッドの実装を持たないクラス

* 抽象クラスの存在意義は、ひな形としての役割（インタフェースとの違いでもある）と、テンプレートメソッドパターンにある。

## テンプレートメソッドパターン

* 抽象基底クラスは、骨格実装を提供する。骨格実装の中から内部メソッドを呼ぶことを決め、そのメソッドは抽象メソッドにする。
* オブジェクトを参照する変数の型を抽象基底クラスにすることによって、呼び出し側は特に意識せずに実装を切り替えることができる。
* テンプレートメソッドパターンには、変わりやすい部分を外に追い出す、というプログラミングの基本的な発想がある。複雑なものを外に追い出す感覚は、規模の大きなプログラミングでは必須の感覚。
* [コード例](../../../../../commits/ae22f1e560ea179956383011fd10dd119eab86f5)

## クラスメンバのアクセス制御の使い分けの指針

* フィールドは基本的にprivateにする。ただし、クラス自身がパッケージスコープやネストクラスでスコープが小さく、かつデータを運ぶ役割しか持たない場合などは限定的にpublicにする設計もありうる
* 特定のクラスの実装に依存した下請け処理メソッドはprivateにする
* 継承先のクラスでも使う下請け処理メソッドはprotectedにする
* パッケージ内で他から呼ぶメソッドはパッケージスコープにする
* パッケージ外から呼ぶメソッドはpublicにする

## ネストしたクラス

クラスの中に定義したクラスをネストしたクラスと呼ぶ。ネストしたクラスには次の4種類がある。

* static なネストしたクラス
* 非static なネストしたクラス
* ローカル内部クラス
* 匿名クラス

ネストしたクラスのことをメンバクラスとも呼ぶが、メンバクラスを含むクラスの方をエンクロージングクラスと呼ぶ。
ネストしたクラスにはstaticがついている。staticがつかない場合は、内部クラスと呼ばれ、特別な動作をする。

## ネストしたクラスの使い方

* ネストクラスした自身のアクセス制御
    * public,packageスコープの他に、private修飾子をクラス定義につけると、プライベートスコープにできる。（protectedも可能）
    * エンクロージングクラスから見れなくなる（ただし、見えなくなるのは型であって、オブジェクトの参照は見える。）
* ネストしたクラスとエンクロージングクラスとの親和性
    * ネストしたクラスは、エンクロージングクラスのメンバとして扱われるので、エンクロージングクラスのprivateメンバにアクセスできる。逆に、エンクロージングクラスはネストしたクラスのprivateメンバにアクセスできる。

ex). [コード例](../../../../../commits/3462d5ea03569dd32b4cc2ff2634bc44ca47aebb)

## ネストしたクラスの用途

* エンクロージングクラス内部だけでオブジェクトを使う場合
* ネストしたクラスの実装をエンクロージングクラス内に隠蔽したい場合
* トップレベルクラスの名前を節約する場合（非推奨）
    * この場合は、パッケージ活用してサブパッケージの中にクラス定義をして管理すべき

## 内部クラス

非staticなネストしたクラスを内部クラスと呼ぶ。内部クラスとエンクロージングオブジェクトは次の特別な関係を持つ。

* 内部クラスのオブジェクトは、エンクロージングオブジェクトへの参照を（暗黙に）持つ。
* （上記のために）エンクロージングクラスのクラスメソッド内では、内部クラスのオブジェクト生成ができない。

ex). [コード例](../../../../../commits/fb9cf18128b2e75616f2d78a546ecf101fe09a5e)

staticなネストしたクラスと比較した場合、doit()メソッド内で、引数でエンクロージングオブジェクトを貰っていたのに対し、内部クラスの場合は直接フィールドにアクセス可能。これは、内部クラスのオブジェクトがエンクロージングオブジェクトへの参照を暗黙に持っているために可能。
このため、内部クラスとエンクロージングクラスで同名のフィールドやメソッドがあれば、名前の隠蔽が起きるので、明示的にクラス名.this.フィールド名などでアクセスする。

## ローカル内部クラス

ローカル内部クラスは、

* メソッド内
* コンストラクタ内
* 初期化ブロック内
* if節のブロック内

などのブロック内で定義するクラス。

ex). [コード例](../../../../../commits/a48ab813f6accb65beab6253e8cdd36db289d646)

ローカル内部クラスはブロックの外からはアクセスできない。static修飾子は意味がないため、つけることができない。アクセス制御も意味がないため、アクセス制御用修飾子もつけることができない。
ローカル内部クラスを使う目的は、主に次の通り。

* ブロック内部だけでオブジェクトを使う場合（非推奨）
    * ローカル内部クラスを使う長いブロックは、その長さ自体が問題になるため、現実的には推奨しない。メソッドを分割するなどして、長いブロックをなくすことを考えるべき。
* クラスの実装をブロック内に隠蔽したい場合

ex). [コード例](../../../../../commits/8d5f49605f80955fc24524f03506f906cfbda1f4)

## 匿名クラス

* 匿名クラスの構文

```
#!java

// 匿名クラスの構文
new 基底クラス(実引数) {
    拡張実装(メソッド宣言とフィールド宣言)
}
```

上記のローカル内部クラスを匿名クラスで書き直すと、以下のようになる。

ex). [コード例](../../../../../commits/be4028e1b808703677722974c3de3c31a0ed9ccd)

以下はArrayListの初期化ととComparatorの実装を匿名クラスで表現する例。

```
#!java

import java.util.*;
class MyAnnon {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>() {
            {
                add("foo");
                add("bar");
                add("bazbazbazbaz");
                add("foofoo");
                add("barbarbar");
                add("baz");
            }
        };
        Collections.sort(list, new Comparator<String>() {
            @Override public int compare(String s1, String s2) {
                return s1.length() - s2.length();
            }
        });
        for (String s : list) {
            System.out.println(s);
        }
    }
}
```

## 匿名クラスを使う基準

* コンストラクタが不要（初期化ブロックだけで十分）
* オブジェクト作成が1つだけ

## アプリケーションのクラス分割の例

* データを運ぶクラス（VO,DTO）
* 外部とやり取りするクラス（ファイル、データベース（DAO）、ネットワーク（Web）、ユーザ（UI）)
* 内部ロジックの実装クラス
* 内部ロジッククラスを使いやすくするサービスクラス（API）
* 内部ロジックを下支えするフレームワーク的なクラス
* オブジェクトのライフサイクル管理
* イベントループ（骨格実装とイベント発火（コールバックの呼び出し））
* （個別に）下請け処理を行うヘルパークラス
* ユーティリティクラス

## クラス設計の指針

* オブジェクト指向の「クラスはデータと手続きを一体化したもの」という標題に無理に従う必要はなく、無理に手続きを書く必要はない。
* 外部との接点の役割を分離する。（DAOやUIとのインタフェース部分など）
* 上に向かってくくりだす役割は、他モジュールとの接点、サービス層やAPI層などと呼ばれる部分は、デザインパターンでファサードパターンと呼ばれたりもするが、この部分を変化しないクラスとして位置づけ、全体の中に変化しにくい層を作ることで、全体の堅牢性を高めることができる。建築に例えれば柱や梁に相当。絵画に例えれば、輪郭線や構図を決める線。
* 下に向かってくくり出す役割が、内部ロジックの実装クラスを下支えする機能。オブジェクトのライフサイクル管理やイベントループなどの役割を担う。フレームワークとして存在しているかもしれないし、処理をモジュール化して下請け処理を担うヘルパークラスをくくりだすこともある。
* 手続きや関数をくくりだすユーティリティクラスも存在する。ユーティリティクラスを作る場合は、既存のライブラリに同じ処理がないかを確認すること。

## パラメータ化の意識

クラス設計に王道は無いので、書けないくらいであれば分割は考えずまず書くべき。その後、内部に抱え込んだ値を外部から与えることを考える。

* メソッドレベル
    * 引数で値を与える
* クラスレベル
    * コンストラクタやメソッドで値を与えて、フィールドに状態を持たせる

など。
