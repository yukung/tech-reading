# サーブレット

## サーブレットとは

サーブレットコンテナの上で動くプログラムをサーブレットアプリと呼ぶ。

サーブレットプログラミングとはサーブレットアプリを開発すること。サーブレットアプリは極論すると、HTTPリクエストを入力としてHTTPレスポンスを出力とするプログラム。リクエストURLごとに様々な処理を実行する。サーブレットアプリを１つのクラスのように見立てると、リクエストURLはメソッドに相当し、レスポンスが返り値に相当する。

### ビルドとデプロイ

サーブレット開発では、以下の２つの工程が必要になる。

* ビルド
    * ソースファイルを javac でコンパイルして、クラスファイルを生成する工程
* デプロイ
    * 生成したクラスファイルとその他実行に必要なファイルをサーブレットコンテナがロードできるディレクトリにコピーする工程

この作業を自動化するためのツールとして、ant がある。開発では ant を使いながらビルドとデプロイを繰り返しながら進めていく。

ant の処理を定義するのが build.xml というビルドファイル。このファイルにターゲットとタスクという定義を記述することで、ビルドとデプロイを自動的に行うようにすることができる。

### マッピング

リクエストURLから実行するサーブレットクラスを選択することをマッピングと呼ぶ。マッピングの規則は、web.xml というファイルに定義していく。

Tomcat がホストする各サーブレットアプリを**コンテキスト**と呼び区別する。リクエストURLはまず`コンテキストパス/マッピングパス`に分解される。

    http://localhost:8080/myservlet/MyServlet

のURLで myservlet の部分がコンテキストパス。直感的にはコンテキストパスはアプリ名。web.xml のマッピングで、コンテキストパスより後ろのURLをサーブレットクラスに対応づける。

#### マッピングのURLパターン

`<url-pattern>`に記述できるURLのパターンとマッチの優先順を示す。

1. 完全一致
2. 拡張子ルール一致
3. 最長の前方一致
4. デフォルト

|記述|説明|例|
|----|----|--|
|パス|完全一致パスのルール|/my|
|/* で終端するパス|前方一致パスのルール|/my/*|
|\*.拡張子|拡張子によるマッピングルール|\*.jsp|
|/の1文字|デフォルトルール|/|

#### Tomcat のデフォルト web.xml

各サーブレットアプリごとの web.xml を先に読み、URLパターンが一致しない場合は Tomcat 自体のデフォルト web.xml を参照する。

#### WEB-INF と META-INF

WEB-INFとMETA-INFの2つのディレクトリの下のファイルは、URLのパターンがマッチしてもファイルの中身を返さない決まりになっている。（サーブレットの規格）つまり、WEB-INFディレクトリの下に配置した web.xml の中身がWebブラウザに見えることはない。クラスファイルの中身もそのまま外部からダウンロードできないようになっている。

## サーブレットAPI

サーブレットAPIのパッケージは次の2つ。

* javax.servlet
* javax.servlet.http

`Javax.servlet` パッケージにはHTTPに依存しないクラスやインタフェースがある。クラスのいくつかは抽象基底クラス。

`javax.servlet.http` パッケージにはHTTPに依存したクラスやインタフェースがある。多くのクラスやインタフェースが `javax.servlet` パッケージのクラスやインタフェースを継承している。

### サーブレットクラス

サーブレットクラスは `javax.servlet.http.HttpServlet` を拡張継承した具象クラス。サーブレットアプリの開発者は自作のサーブレットクラスを作成する。フレームワークが抽象基底クラスを用意し、フレームワークを利用する開発者が拡張継承した具象クラスを作成する技法はフレームワークで一般的。サーブレットの世界ではサーブレットコンテナがフレームワーク。

Spring Framework などはサーブレットコンテナの上に乗るフレームワーク。上位のフレームワークをその役割を強調してMVCフレームワークと呼ぶこともある。

サーブレットオブジェクトの生成はサーブレットコンテナ（フレームワーク）の役割。サーブレットコンテナはサーブレットオブジェクトに対して抽象基底クラスのメソッドを呼ぶ。結果として開発者が具象クラスで抽象基底クラスのメソッドをオーバーライドすると、サーブレットコンテナがそのメソッドをコールバックする関係になる。

`HttpServlet` クラスは、全てのメソッドにデフォルト動作の実装を持つ。具象クラスはデフォルト動作を変更したいメソッドだけをオーバーライドする。

開発者は、自作のサーブレットクラスでdoGetやdoPostのように接頭辞doのついた名前のメソッドをオーバーライドする。doメソッドはHTTPのメソッドに対応しており、リクエストがGETメソッドであれば、doGetメソッドが呼ばれる。doメソッドをオーバーライドしない場合、doメソッドが呼ばれると該当HTTPメソッドをサポートしていない旨のエラーをWebブラウザに返します。つまりHTTPエラーを返す実装がデフォルト実装。

doメソッドのパラメータ引数は`HttpServletRequest`オブジェクトと`HttpServletResponse`オブジェクト。doメソッドの基本的な動作は、`HttpServletRequest`オブジェクトからリクエスト情報を読み取り、`HttpServletResponse`オブジェクトにレスポンス情報を書きだす。概念的には`HttpServletRequest`オブジェクトが入力元で`HttpServletResponse`オブジェクトが出力先。

MVCアーキテクチャの下ではレスポンス処理をJSPに任せるのが普通。この場合のdoメソッドの基本構造は`HttpServletRequest`オブジェクトからリクエスト情報を読み取り、JSPに`HttpServletResponse`オブジェクトを渡してレスポンス処理をまるなげする。サーブレットの世界では処理の丸投げを**フォワード**と呼ぶ。

#### initメソッドのオーバーライド

doメソッド以外にオーバーライドすることのあるメソッドはinitメソッド。サーブレットコンテナはサーブレットオブジェクト生成後にinitメソッドをただ1度だけ呼ぶ。各サーブレットオブジェクトはただ一つしか生成されないことに注意する。開発者はinitメソッドをオーバーライドすることで最初に1度だけ行いたい処理を書くことができる。

#### サーブレットクラスの排他制御

サーブレットコンテナは、サーブレットオブジェクトをクラスごとにただ1つだけ生成する。サーブレットは同時に複数のクライアントから接続を受ける。一般に同時に行うリクエスト処理に別々のスレッドを割り当てる。つまり、複数のWebブラウザが同じURLに同時にアクセスすると複数のスレッドが同時に同じサーブレットオブジェクトのdoメソッドを呼び出す。

サーブレットクラスがインスタンスフィールドを持つ場合、排他制御が必要。しかし、一般論としてサーブレットクラスはインスタンスフィールドを持つべきではない。リクエストごとに持つべき状態は`HttpServletRequest`オブジェクトに持たせる。セッションごと（直感的にはログインユーザごと）に持つべき状態は`HttpSession`に持たせる。

上記の指針を守ると、サーブレットクラスに排他制御は不要になる。

doメソッドの引数に渡る`HttpServletRequest`オブジェクトと`HttpServletResponse`オブジェクトはリクエストごとに独立して生成される。これらを他のスレッドと共有することはない。このため、これらには排他制御は不要。

### リクエスト処理

HTTPリクエストから得られる主な情報と取得メソッドを以下に示す。

|リクエストの構成要素|対応メソッド|
|--------------------|------------|
|リクエストURL|`getRequestURL`など|
|クエリパラメータ|`getParameter`や`getParameterValues`など|
|リクエストボディ（=ポストデータ）|`getInputStream`や`getReader`など|
|リクエストヘッダ|`getHeader`や`getHeaders`など|

#### リクエストURL

リクエストURLの情報を取得するメソッドは複数存在する。

|メソッド名|説明|返り値の具体例|
|----------|----|--------------|
|`getContextPath`|コンテキストパス|/appname|
|`getServletPath`|サーブレットクラスのパス|/doJob|
|`getPathInfo`|拡張パス|/extra|
|`getQueryString`|クエリパラメータ|id=foobar&x=y|
|`getRequestURI`|URLのパス部分|/appname/doJob/extra|
|`getRequestURL`|クレリパラメータを除くURL全体|http://localhost:8080/appname/doJob/extra|

リクエストURLのパス部分は次のように分解される。

    http://localhost:8080/コンテキストパス/サーブレットクラスのパス/拡張パス…?クエリパラメータ

#### クエリパラメータ

クエリパラメータはURLの?文字移行に現れる文字列。リンク先URLで指定したり、あるいはフォーム送信で生成することも出来る。

Webブラウザで利用者からの入力を受け付けるには、一般にフォームと呼ばれるHTML要素を使い、フォームの入力項目をGETメソッドまたはPOSTメソッドで送信される。

フォームの入力項目をGETメソッドで送信すると、入力項目はリクエストURLのクエリパラメータになる。

#### GETとPOSTメソッドの使い分けの指針

* GETメソッドはWebサーバから情報を得る場合に使う
    * パラメータが検索条件となったURLとなり、リンクとして利用することができる
    * ただし、ログイン処理にGETメソッドは使わない（パスワードが丸見えになってしまうため）
* POSTメソッドはWebサーバ上の状態を変更するためにWebサーバにデータを送信するために使う

#### クエリパラメータ用メソッド

クエリパラメータの全体は`getQueryString`メソッドで取得できる。通常、これで得られる文字列を自分で解析する必要はない。`HttpServletRequest`オブジェクトが内部で解析して、クエリ名とクエリ値のペアを管理しているため。

クエリパラメータはURL固有のエンコード処理が施されているが、内部解析がデコード処理を隠蔽する。クエリパラメータを取得するメソッドを次にまとめる。

|メソッド定義|説明|
|------------|----|
|`String getParameter(String name)`|クエリ名からクエリ値を取得。存在しない場合、null|
|`Stirng[] getParameterValues(String name)`|クエリ名から複数のクエリ値を取得。存在しない場合、null|
|`Enumeration getParameterNames()`|クエリ名の一覧を取得。クエリが1つも存在しない場合、空のEnumeration。コレクション型を使うと返り値の型は`Set<String>`相当|
|`Map getParameterMap()`|キーがクエリ名、値がクエリ値の集合のマップを取得。コレクション型を使うと返り値の型は`Map<String, String[]>`相当。|

`getParameterValues`メソッドから想像できるように、同じクエリ名に対して複数のクエリ値が存在しえる。

http://localhost:8080/appname?foo=bar1&foo=bar2 のような場合。

クエリ値は常に文字列で得られる。意味的に数値を送信する場合も、ネットワーク上は文字列になるのでメソッドの返り値の型は`String`。必要に応じて数値に変換するのは開発者の責任。

#### フォームのPOSTデータ

フォームの入力項目をPOSTメソッドで送信した場合、通称、POSTデータと呼ぶ。HTTPの観点で見るとPOSTデータはヘッダ部とボディ部で送信される。

HTTPボディ部がフォームのPOSTデータの場合、上記のクエリパラメータを取得するメソッドを使える。`HttpServletRequest`が内部でHTTPボディ部を解析して、クエリ名とクエリ値のペアにするため。

つまり、フォーム送信に関しては、`HttpServletRequest`のクエリパラメータ処理がGETメソッドとPOSTメソッドの違いを隠蔽する。

#### HTTPのボディ部

HTTPのボディ部（POSTデータ）は、フォーム送信に限定するものではない。HTTPボディ部の現実的な形式は次の3パターン。

* HTMLフォームから送るPOSTデータ（フォームデータ）
* ファイルアップロードによるPOSTデータ（ファイルアップロードデータ）
* その他（バイト列データ）

一般的なWebブラウザが送信できるHTTPボディの形式はフォームデータとファイルアップロードデータの2種。それ以外の形式はWebサービスなど他の用途に使うことがある。その他の形式は開発者が自分でHTTPボディ部を解釈する必要がある。

#### HTTPのボディ部のストリーム処理

HTTPボディ部のデータ取得には`HttpServletRequest`の`getInputStream`メソッドもしくは`getReader`メソッドを使う。バイトストリームとして扱う場合は`getInputStream`メソッド、文字ストリームとして扱う場合は`getReader`メソッドを使う。

`ServletInputStream`クラスは`InputStream`クラスを拡張継承したクラス。

HTTPボディ部のデータ取得にはデータ長を取得する`getContentLength`メソッドがあるが、HTTPの構造上、データ長が不明な場合がある。（Content-Lengthヘッダは必須ではないので）データ長が不明な場合、`getContentLength`メソッドは-1を返す。どんな場合も確実にHTTPボディ部を読み取るには、ストリームからデータを全て読み取る処理が必要。

理屈上はHTTPボディ部のデータをストリームとして読み取り、自前で解釈可能。現実的にはライブラリに処理を任せることを勧める。ファイルアップロードデータに関しては次の節に説明を譲り、その他のPOSTデータのフォーマットは用途にいよって様々。WebサービスではXMLデータをHTTPボディ部で送信することが多々ある。この場合も自分でストリーム処理せず、適切なライブラリに処理を任せることを推奨する。

#### リクエストヘッダ

リクエストヘッダ情報の読み取りメソッドは以下。

|メソッド定義|説明|
|------------|----|
|`String getHeader(String name)`|ヘッダ名からヘッダ値を取得。ヘッダが存在しない場合、null|
|`int getIntHeader(String name)`|ヘッダ名からヘッダ値をintで取得。ヘッダが存在しない場合、-1。intに変換できない場合、NumberFormatException例外が発生。|
|`long getDateHeader(String name)`|ヘッダ名からヘッダ値を時刻のエポック値で取得。ヘッダが存在しない場合、-1。エポック値に変換できない場合、IllegalArgumentException例外が発生。|
|`Enumeration getHeaderNames()`|ヘッダ名の一覧を取得。ヘッダが1つも存在しない場合、空のEnumeration。コレクション型を使うと返り値の型は`Set<String>`相当|
|`Enumeration getHeaders(String name)`|ヘッダ名から複数のヘッダ値を取得。ヘッダが存在しない場合、空のEnumeration。コレクション型を使うと返り値の型は`List<String>`相当|

ヘッダ名には大文字小文字の区別がない。（クエリ名は大文字小文字の区別がある）ヘッダ値を文字列以外で取得するメソッドがある。HTTP上はヘッダ値はすべて文字列で送信しているので、これらのメソッドは内部で文字列から数値や日付に変換している。変換処理を自前で書くよりは適切なメソッドで変換処理を隠蔽する。

リクエストヘッダの読み取りは、サーブレットコンテナやフレームワークに隠蔽することが多く、実際に使う機会はそれほど多くない。リクエストヘッダの有無はWebブラウザに依存する部分が多いため、リクエストヘッダに依存するサーブレットアプリは現実的ではないから。

### ファイルアップロード

ファイルアップロード時の送信データは内部動作が異なるため、パラメータ取得のメソッドではデータを取得できない。ファイルアップロードのデータを取得するにはライブラリを使うことを推奨する。

代表的なライブラリは Apache Commons の FileUpload ライブラリ。

### レスポンス処理

レスポンス処理とは `HttpServletResponse` オブジェクトに対してレスポンス出力を行うこと。サーブレットクラスの仕事を端的に言えばリクエスト処理を入力としてレスポンス処理を出力すること。

HTTPレスポンスは、「**レスポンスステータス**」「**レスポンスヘッダ**」「**レスポンスボディ**」の3つの構成要素から成る。`HttpServletResponse`はそれぞれに対応するメソッドを持つ。

|レスポンスの構成要素|対応メソッド|
|--------------------|------------|
|レスポンスステータス|`setStatus`など|
|レスポンスヘッダ|`setHeader`や`addHeader`など|
|レスポンスボディ|`getOutputStream`や`getWriter`など|

#### レスポンスステータス

レスポンスステータスは`200 OK`や`404 Not Found`などがよく知られている。200や404の数字の部分がステータスコードで、HTTPの規格で数値と意味が決まっている。`setStatus`メソッドは引数でint型のステータスコードを与える。ステータスコードは`HttpServletResponse`のクラスフィールドで定数定義されている。

```
#!Java
// ステータスコードの定数定義（一部抜粋）
public static final int SC_OK = 200;
public static final int SC_MOVED_TEMPORARILY = 302;
public static final int SC_UNAUTHORIZED = 401;
public static final int SC_FORBIDDEN = 403;
public static final int SC_NOT_FOUND = 404;
```

現実的にはサーブレットアプリで`setStatus`メソッドを使う場面はあまりない。なぜなら`setStatus`メソッドを呼ばない場合、自動的に200の成功ステータスコードになるため。

200以外のステータスコードを返すための特別に用意されたメソッドがある。

* `sendRedirect`
    * リダイレクト処理を行う
* `sendError`
    * 引数指定したステータスコードでエラーページを返す

`sendError`メソッドで明示的にエラーページを返すことができる。`sendError`メソッドの濫用は避けるべき。なぜならエラーページを返しても利用者に利することは殆ど無いから。例えばフォーム入力でパラメータが足りない場合、エラーページを返すのではなく、利用者に適切なフィードバック（不正な入力項目の合ったフィールドを明示するなど）のある画面を返すほうが望ましい。

#### レスポンスヘッダ

レスポンスヘッダはヘッダ名とヘッダ値のペアで指定する。リクエストヘッダ同様、レスポンスヘッダの処理もサーブレットコンテナやフレームワークで暗黙に処理することがほとんど。Webブラウザがレスポンスヘッダをどう解釈するかWebブラウザ依存が大きく、レスポンスヘッダの利用は汎用性が低いため。

`setContentType`メソッドはレスポンスボディのフォーマットを指示するレスポンスヘッダを返す。`Content-Type`ヘッダの値を指定する。HTML以外のレスポンスを返す場合、指定するほうが利用者の利便性が上がる。

#### レスポンスボディ

レスポンスボディの送信はストリームに対する出力で行う。バイトストリームと文字ストリームそれぞれの取得メソッドがある。

出力ストリームへの書き込みはそのままレスポンスボディとして送信される。直感的には、ストリームにHTMLを書き込むとWebブラウザの画面に表示される。

後述するように適切なMVCアーキテクチャに従うサーブレットアプリでは、レスポンス処理、特にレスポンスボディ部の出力処理をサーブレットクラスが行うべきではない。JSPに任せるのが筋。この場合、出力ストリームの取得メソッドを明示的に呼ぶ出すことはほとんどない。

### フォワード処理

フォワード処理とは別のサーブレットクラスやJSPに処理を丸投げすること。

ただし、サーブレットオブジェクトから他のサーブレットオブジェクトのdoメソッドを呼ぶのは禁止。たとえできたとしても、サーブレットクラスのオブジェクト生成を明示的に行うのは禁止、サーブレットオブジェクトの生成はサーブレットコンテナの仕事。

```
#!java

// 決して行なっては行けないフォワード処理
public class MyServlet extends HttpServlet {
    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        AnotherServlet another = new AnotherServlet();    // 生成してはいけない
        AnotherServlet another = (AnotherServlet)getServletContext().getAttribute("another");    // アプリケーションコンテキストからもダメ
        another.doGet(req, res);    // 他のサーブレットのdoメソッドを呼ぶのは禁止
    }
}
```

原則として、サーブレットオブジェクトから別のサーブレットオブジェクトを参照することは禁止と考える。その代わり、次のフォワード処理をする。

#### フォワード処理の方法

処理をフォワードするには`RequestDispatcher`オブジェクトを使う。`RequestDispatcher`はフォワード先サーブレットオブジェクトのdoメソッドの呼び出しを隠蔽する。

`RequestDispatcher`オブジェクトは次の3つの手段で取得できる。

|取得メソッド|説明|
|------------|----|
|`ServletContext`オブジェクトの`getRequestDispatcher`メソッド|パスから`RequestDispatcher`オブジェクトを取得。コンテキストルートからの絶対パス指定。もっとも一般的な取得手段。|
|`ServletContext`オブジェクトの`getNamedDispatcher`メソッド|名前から`RequestDispatcher`オブジェクトを取得。|
|`HttpServletRequest`オブジェクトの`getRequestDispatcher`メソッド|パスから`RequestDispatcher`オブジェクトを取得。相対パス指定もできる。|

`HttpServletRequest`オブジェクトの`getRequestDispatcher`メソッドは`ServletContext`オブジェクトの同名のメソッドのラッパー。このため、`ServletContext`オブジェクトの`getRequestDispatcher`メソッドの利用を推奨する。doメソッド内で`ServletContext`オブジェクトは`getServletContext`メソッドで取得できる。

`RequestDispatcher`オブジェクトに対して`forward`メソッドを呼ぶとフォワード処理できる。