# EL&JSTL

## EL

ELを利用することで以下の恩恵を享受できる。

* 可読性の向上
* 保守性の向上
* 安全性の向上
* 生産性の向上

ELは主に以下の構文を組み合わせて構成される。

* 文字列リテラル
* 数値リテラル
* 真偽値（true, false）リテラル
* null（リテラル）
* 演算子
* 関数呼び出し

### 文字列リテラル

文字列リテラルで記述した文字列定数は String のオブジェクトとして扱われる。

```
${'foo'}
${"foo"}
```

シングルクォート、ダブルクォートどちらで囲っても文字列リテラルとみなされる。アクションの属性内にELを書くことを考えるとシングルクォートを利用するほうが自然。

文字列リテラル内でクォート文字を使用する場合はバックスラッシュ(`\`)でエスケープする。ただし、違うクォート文字を使用している場合はエスケープする必要はない。

```
${'It\'s nice.'}
${"It's nice."}
${'This is called "JSP".'}
${"This is called \"JSP\"."}
${'\\${…}'}
```

Javaの文字列リテラルではエスケープシーケンスを使って改行（`\r\n`）やタブ（`\t`）を表現できたが、ELではそれができない。ELで改行やタブを扱う場合はそのまま入力する必要がある。

```
<c:out value="
${'if (…) {
    …
}'}
"/>
```

### 数値リテラル

ELは数値リテラルとして整数値リテラル、浮動小数点リテラルに対応している。

整数値リテラルは Long 型の数値オブジェクトとして扱われ、浮動小数点リテラルは Double 型の数値オブジェクトとして扱われる。

```
${123}
${-123}
${123.4}
${123e10}
${123e1000}
```

### 真偽値リテラル

ELは真偽値として true と false に対応している。Javaの true と false と同等。

```
${true}
${false}
```

### null（リテラル）

null はJavaの null と同等。ただし、期待される型が文字列の場合は null は空文字列（""）に変換される。

```
${null}
// ""
```

### エスケープ

ELをELとして評価したくない場合は`$`の前にバックスラッシュ（`\`）を記述する。

### 算術演算子

Javaの算術演算子とほぼ同等。優先順位も自然な順位で定義されている。

#### 浮動小数点での注意点

ELでは、Javaと違い整数値同士の場合でも除算結果は浮動小数点になる。

```
${5 / 2}
// 2.5
```

また、算術演算子は文字列には適用できない。

```
${'Hello ' + 'world'}
// これは変換エラーになる
// やるなら
${'Hello '}${'world'}
```

### 比較演算子

すべての比較演算子は真偽値を返す。

|演算子|説明|
|------|----|
|`==(eq)`|AとBが等しい|
|`!=(ne)`|AとBが等しくない|
|`<(lt)`|AがB未満|
|`<=(le)`|AがB以下|
|`>(gt)`|AがBより大きい|
|`>=(ge)`|AがB以上|
|`empty`|Aはnull|

* empty 以外の比較演算子は数値・文字列どちらにも対応
* 記号と単語どちらでもいいが、普段は自然に見える記号がよい
* ELではnullとの比較はすべて false を返すようになっている。（JavaScript とは違う）

```
${null < 10}    // false
${null == ''}    // false
${null == null}    // true
```

#### 文字列の比較

`==`や`!=`に加えて`<`や`>`などの文字列比較演算も対応している。

```
${'A' < 'A'}    // false
${'A' <= 'A'}    // true
${'A' < 'B'}    // true
${'ABC' < 'ACC'}    // true
${'ABC' < 'AAC'}    // false
```

empty 演算子は値が「**空**」であるかを確認する。「**空**」は以下を意味する。

* null
* 空文字列
* 空のコレクション
* NaN

これ以外の値はすべて「**空**」ではない、つまり false を返す。

```
${empty null}    // true
${empty ''}    // true
${empty 'foo'}    // false
${empty 0}    // false
${empty NaN}    // true
${empty true}    // false
${empty false}    // false
<%
    pageContext.setAttribute("emptyList", java.util.Collections.emptyList());
    pageContext.setAttribute("nonEmptyList", java.util.Arrays.asList(1));
%>
${empty emptyList}    // true
${empty nonEmptyList}    // false
```

注意点は、数値の0が「**空**」にならないということ。数値の0もしくは「**空**」を判定する場合は以下のように記述する。

```
${empty val or val == 0}

### 論理演算子と3項演算子

Javaと同様。

|演算子|説明|
|------|----|
|`&&(and)`|AとBが真の場合に真|
|`\|\|(or)`|AあるいはBが真の場合に真|
|`!(not)`|Aが真の場合に偽、偽の場合に真|
|`A ? B : C`|Aが真ならB、偽ならC|

### スコープ

ELインタプリタは識別子を見つけると、その名前の属性をスコープから取り出そうとする。つまり、

```
${foo}
```

は、

```
<%= pageContext.findAttribute("foo") %>
```

という挙動を取ろうとする。

### プロパティと配列

ドット演算子`（.）`とブラケット演算子`（[]）`を使用してオブジェクトのプロパティにアクセスできる。構造化されたデータを簡単に扱うことができる。

* オブジェクトが`java.util.Map`のとき、ELインタプリタはプロパティ名をキーにして Map の`get`メソッドを使ってプロパティを取得する。
* `java.util.Map`ではなく、オブジェクトが Java Beans 形式のオブジェクトの場合、ELインタプリタは Bean の getter を利用してプロパティを取得する。オブジェクトのクラスに「**is+プロパティ名**」という名前のメソッドが存在する場合、ELインタプリタは`is`メソッドを呼びだそうとする。`is`メソッドの返り値の型が`boolean`ではない場合にエラーになる。

#### ドット演算子の連結

ドット演算子はいくつでも連結できる。ただし、Map のオブジェクトもしくは Bean 形式のオブジェクトという規則に従う必要がある。

#### 配列

配列にアクセスするにはブラケット演算子（`[]`）を使う。厳密には、次のものがブラケット演算子に対応している。

* 配列
* java.util.List

```
${array[0]}
${list[0]}
```

#### ブラケット演算子

ブラケット演算子は配列にアクセスする機能に加えて、一般化されたドット演算子の機能も持つ。

```
${map['foo-bar']}
```

ドット演算子との違いは以下のようになる。

* プロパティ名として任意の文字列を指定できる
* プロパティ名に式を指定できる

ブラケット演算子によるプロパティ取得は冗長なコードになりやすいので、必要な時だけブラケット演算子を使用するようにする。

### 例外

ELの基本的な演算では、ほとんど例外が発生しない。特に協調すべきなのは、NullPointerException の心配をしなくて良い点。

ELインタプリタは null を見つけた時点で評価を完了し、そのまま null を返す。これはELの記述量の現象に大きな貢献をしている。

ただし、算術演算の引数に数値以外のオブジェクトを渡すと例外が発生する。

```
${'x' - 3}    // 例外
```

### 暗黙オブジェクト

JSPと同様に、ELにも宣言なしに使用出来る暗黙オブジェクトが存在する。

|オブジェクト|説明|
|------------|----|
|`pageContext`|`javax.servlet.jsp.PageContext`のオブジェクト|
|`pageScope`|ページスコープにアクセスするためのオブジェクト|
|`requestScope`|リクエストスコープにアクセスするためのオブジェクト|
|`sessionScope`|セッションスコープにアクセスするためのオブジェクト|
|`applicationScope`|アプリケーションスコープにアクセスするためのオブジェクト|
|`param`|リクエストパラメータにアクセスするためのオブジェクト|
|`paramValues`|リクエストパラメータにアクセスするためのオブジェクト|
|`header`|リクエストヘッダにアクセスするためのオブジェクト|
|`headerValues`|リクエストヘッダにアクセスするためのオブジェクト|
|`cookie`|クッキーにアクセスするためのオブジェクト|
|`initParam`|アプリケーションの初期化パラメータにアクセスするためのオブジェクト|

#### pageScope, requestScope, sessionScope, applicationScope

変数を取得する時、どのスコープから取得するかを限定したいときに使える。スコープが小さい方から優先して探索する。

#### param, paramValues

リクエストパラメータにアクセスするための暗黙オブジェクト。取得するパラメータ値は単一の文字列になる。複数の値を持つパラメータを処理する時は`paramValues`を使用する。

### 関数

次の形式で任意の関数を呼び出せる。

    接頭辞:関数名(引数…)

関数はタグライブラリの一部として提供される。taglib ディレクティブでタグライブラリを使用することを宣言することで、EL内でタグライブラリに含まれる関数を呼び出せる。ELの仕様としてはプリミティブな関数は1つも定義されておらず、通常は後述するJSTLの関数ライブラリを使用する。

関数により、処理の共通化や保守性・可読性の向上を期待できる。

### 暗黙の型変換

ELインタプリタはオブジェクトを評価する際、期待される型に暗黙的に変換する。

#### オートボクシング

期待される型にオブジェクトをオートボクシング、オートアンボクシング出来る場合、ELインタプリタはオブジェクトを変換する。

#### 文字列

期待される型が文字列の場合、ELインタプリタは次の規則でオブジェクトを文字列に変換する。

* オブジェクトが`String`の場合はそのまま
* オブジェクトが`null`の場合は空文字列（""）
* オブジェクトが`Enum`の場合は`name()`の返り値
* オブジェクトの`toString()`の返り値

#### 数値

期待される型が数値の場合、ELインタプリタは次の規則でオブジェクトを数値に変換する。

* オブジェクトが数値の場合
* そのまま適切な型に変換
* 期待される型が`BigInteger`あるいは`BigDecimal`の場合はその型に変換
* オブジェクトが空文字列（nullも含める）の場合は0
* オブジェクトが文字列の場合
* 期待される型に`valueOf()`で変換
* 期待される型が`BigInteger`あるいは`BigDecimal`の場合はその型に変換

#### 真偽値

期待される型が真偽値の場合、ELインタプリタは次の規則でオブジェクトを真偽値に変換する。

* オブジェクトが空文字列（nullも含める）は false
* オブジェクトが真偽値の場合はそのまま
* オブジェクトが文字列の場合は`Boolean.valueOf()`で変換

## JSTL

制御構文や書式フォーマット、XMLなどの一般的な機能を定義したJSTL（JSP Standard Tag Library）という標準ライブラリが存在する。JSTLは用途別に次の4つに分類できる。

|機能|接頭辞|URI|説明|
|----|------|---|----|
|コア|c|http://java.sun.com/jsp/jstl/core|制御構文など基本的な機能|
|書式|fmt|http://java.sun.com/jsp/jstl/fmt|日付や数値の書式化機能|
|SQL|sql|http://java.sun.com/jsp/jstl/sql|SQLの実行機能|
|XML|x|http://java.sun.com/jsp/jstl/xml|XMLの操作機能|

### コアタグライブラリ

* `<c:out>`
    * 値を出力するアクション
    * escapeXml属性にtrueを指定すると（デフォルトはtrue）value属性の値をエスケープして出力
    * default属性あるいはボディを指定すると、value属性がnullの時に代わりにその値を出力する
* `<c:set>`
    * スコープに属性を設定するアクション
    * scope属性を指定することで、どのスコープに格納するかを指定できるが、MVCアーキテクチャを厳守するならJSPがページスコープ以外のスコープに変数を格納すべきではない
    * target属性に Map オブジェクトあるいは Bean 形式のオブジェクトを指定することで、そのオブジェクトの状態を変更することができるが、これもMVCアーキテクチャの観点からJSPでデータを更新すべきではない
* `<c:remove>`
    * スコープから変数を消去するアクション
    * var属性で変数を指定し、どのスコープから消去するかをscope属性で指定する。デフォルトではページスコープ。
* `<c:if>`
    * 条件分岐を記述するアクション
    * test属性の真偽によって、条件分岐を行う。test属性の値がtrueならボディを評価し、falseならボディを評価しない。
    * 単一の条件分岐しか記述できないので、複数の条件分岐の場合は<c:choose>を使う
* `<c:choose>`
    * 複数の条件分岐を記述するアクション
    * 子タグとして`<c:when>`と`<c:otherwise>`を記述できる。`<c:when>`は Java の if/else if に対応していて、`<c:otherwise>`は Java の else に対応する
    * `<c:when>`は`<c:if>`と同等の機能を持っており、`<c:choose>`の中に記述できる点だけが異なる。
    * `<c:otherwise>`は`<c:choose>`の中に1つだけ記述できるアクションで、どの条件にも該当しない場合に評価される。
    * `<c:choose>`は`<c:if>`に比べて冗長なので、多用すると可読性を損ねる欠点がある。分岐が2つや3つの場合は`<c:choose>`ではなく`<c:if>`を使うほうが読みやすくなる。条件が複雑な場合は`<c:choose>`の方が読みやすくなる。
* `<c:forEach>`
    * コレクションあるいは特定の範囲の値に対して処理を繰り返すためのアクション
    * 大きく分けて3つの使い方
        * コレクションの全要素をなめる処理
            * 対象コレクションをitems属性で指定し、要素の変数をvar属性で指定
            * items属性に渡せるオブジェクトは次のいずれか
                * 配列
                * java.util.Collection
                * java.util.Iterator
                * java.util.Enumeration
                * java.util.Map
                * String（カンマ区切りリストであると解釈される）
        * 特定の範囲の値に対して繰り返す処理（1から10など）
            * begin属性に開始値を指定し、end属性に終了値を指定する。var属性で指定した変数に値が格納される
            * begin属性、end属性、step属性はすべて0以上の数値である必要があり、end属性はbegin属性以上である必要がある
            * step属性で繰り返しの増加量を指定できる
            * 降順の繰り返しは記述できないので、昇順で繰り返しを記述して減算で目的の値を算出する                
        * コレクションの特定の範囲の要素をなめる処理（2番目の要素から8番目の要素など）
    * 繰り返し中のステータスは、varStatus属性で指定した変数に格納される
        * current
            * 現在の要素（var属性と同じ）
        * index
            * 現在のインデックス
        * count
            * 繰り返し回数
        * first
            * 初回の場合はtrue
        * last
            * 最終回の場合はtrue
        * begin
            * 開始インデックス
        * end
            * 終了インデックス
* `<c:forTokens>`
    * 文字列中のトークンに対して処理を繰り返すアクション
    * `<c:forEach>`のitems属性にカンマ区切りの文字列を渡すと同様のことができるが、トークンを処理する目的においては`<c:forTokens>`の方が適切。
    * items属性は必ず文字列
    * delims属性にデリミタ（区切り文字）を指定（複数指定した場合はいずれか一致した場合にトークンに分割）
    * items属性には文字列を直接指定することもできる
    * begin属性とend属性で特定の範囲のトークンに対してのみ繰り返すこともできる
* `<c:catch>`
    * 例外を補足するためのアクション
    * ボディ評価時に発生した例外を全て捕捉して処理を続行する
    * var属性を指定すると捕捉した例外を変数に格納できる
    * 実行時例外やエラー(`java.lang.Error`)も補足してしまう
    * バグを隠すために`<c:catch>`を使わない

### 書式タグライブラリ

* `<fmt:setLocale>`
* `<fmt:setTimeZone>`
* `<fmt:setBundle>`
* `<fmt:message>`
    * var属性を指定した場合は結果をその辺数に格納。指定しない場合はそのまま出力
* `<fmt:formatNumber>`
* `<fmt:parseNumber>`
    * value属性に数値として扱えない文字列を指定すると例外
* `<fmt:formatDate>`
* `fmt:parseDate>`
    * value属性に日付として扱えない文字列を指定すると例外

### 関数ライブラリ

ELで使用出来る基本的な関数を提供する。

* `fn:contains`
    * 文字列に部分文字列が含まれているか
* `fn:containsIgnoreCase`
    * 文字列に部分文字列が含まれているか、ただし大文字小文字を無視
* `fn:endsWith`
    * 終端が部分文字列であるか
* `fn:escapeXml`
    * XMLの特殊文字をエスケープ。関数呼び出しの引数、カスタムタグ呼び出しの属性でのみ使用すること。特殊文字をエスケープして出力する場合は`<c:out>`を使う
* `fn:indexOf`
    * 文字列の部分文字列のインデックスを取得
    * 見つからなかったら-1
* `fn:join`
    * 文字列配列をセパレータ（区切り文字列）で結合。空文字列やnullもそのまま結合する。コレクションは渡せない
* `fn:length`
    * コレクションや配列、文字列の長さを取得
* `fn:replace`
    * 文字列の部分文字列を置換
* `fn:split`
    * 文字列をデリミタ（区切り文字列）で分割
* `fn:startsWith`
    * 文字列の先頭が部分文字列であるか
* `fn:substring`
    * 部分文字列を取得。引数には開始インデックスと終了インデックスを指定する。負数は文字列の最後のインデックスを意味する
* `fn:substringAfter`
    * 部分文字列の後の文字列を取得
* `fn:substringBefore`
    * 部分文字列の前の文字列を取得
* `fn:toLowerCase`
    * 文字列を小文字に変換
* `fn:toUpperCase`
    * 文字列を大文字に変換
* `fn:trim`
    * 文字列の前後の空白を取り除く