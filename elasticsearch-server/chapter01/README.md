ElasticSearch クラスタ入門
==========================

# 1章 Elasticsearch クラスタ入門

* 共通するフィールドは同じ型（type）である必要がある（p.26）
    * どういう意味だろう
* Elasticsearch の設定（p.29）
    * `config/elasticsearch.yml` の設定値はデフォルト値であり、実行中に動的に変更できるのでファイルの値とは異なっているかもしれないことに注意する
    * `cluster.name` の値が同じものを同じクラスタとして認識する
    * `node.name` は未定義だと起動するたびにユニークな名前を自動的に生成する
    * heap を増やすときは環境変数 `ES_HEAP_SIZE` に設定する
        * 物理メモリの 50% 以上は設定しない。ディスクキャッシュとして使うため
* Elasticsearch の停止（p.32）
    * `-f` オプションでフォアグラウンドで起動しているときは `Ctrl + C` で止まる
    * `TERM` シグナルを送る（ `kill` コマンドなど）
    * REST API 経由で停止
        * 全体停止： `curl -XPOST http://localhost:9200/_cluster/nodes/_shutdown
        * 1ノード停止： `curl -XPOST http://localhost:9200/_cluster/nodes/{identifier}/_shutdown
        * identifier 取得： `curl -XGET http://localhost:9200/_cluster/nodes/
* システムサービス経由での実行
    * パッケージマネージャ経由で入れた場合は script が提供されている
    * 使わない場合は、Elasticsearch サービスラッパー（ https://github.com/elasticsearch/elasticsearch-servicewrapper ）を使える
* ドキュメントの更新（p.36）
    * `_source` フィールドを使ってスクリプトから更新する方法がある
    * ex) `curl -XPOST http://localhost:9200/blog/article/1/_update -d '{"script": "ctx._source.content =\"new content\""}'`
        * `source` フィールドが必要
        * 対象のドキュメントが存在しない場合は、指定された値を持つ新しいドキュメントをインデックスに登録できる
            * `curl -XPOST http://localhost:9200/blog/article/2/_update -d '{ "script": "ctx._source.counter += 1", "upsert": { "counter": 0 } }'`
            * 既に存在しているドキュメントで `counter` フィールドが存在しない場合はエラーが発生する
* 基本型（Core types）（p.42）
    * 文字列（String）
        * `term_vector` is 何
        * `omit_norms`: Lucene の `norm` is 何
        * `omit_term_freq_and_positions`: ES 0.20 から非推奨
    * 数値（Number）
        * `precision_step`: フィールド内の各値に対して生成される語句の数。値が小さい（語句の数が多く生成される）ほど、範囲検索が高速に実行されるが、インデックスサイズが大きくなる。
    * バイナリ
        * Base64 形式で保存される。デフォルトは保存されるがインデックス登録はされない（検索できない）
* マルチフィールド
    * 2つのフィールドに同じフィールドの値を持ちたい場合（通常の検索と、ファセット検索のためなど）
        * `"name": { "type": "multi_field", "fields": { "name": {...}, "facet": {...} } }` と指定すれば、`name` と `name.facet` という2つのフィールドが作成される。インデックス作成時は2つとも指定する必要はなくて、トップレベルの `name` を指定すれば良く、残りの `name.facet` は Elasticsearch が作成する。
* アナライザの使用（p.46）
     * インデックスを作成したり、クエリを解析する時にデータをどのように処理するかを決めるもの
     * インデックス時とクエリ時に別々のアナライザを使用できる
     * デフォルトで定義されたアナライザが用意されている
     * 独自のアナライザも定義できる
     * アナライザは 1 つの `tokenizer` と複数の `filter` で構成される。アナライザはマッピングファイルの `"settings"` に指定する
     * `filter` を定義することもできる。`filter` は `"analysis" の配下（ `"analyzer"` と同列）に定義する
     * アナライザフィールド（ `_analyzer` ）は、ドキュメントに含まれているフィールドからアナライザの名前に使用するための値を特定できるようにするための仕組み
         * ドキュメントの値によって動的にアナライザを変えることができる。ただし、登録されているアナライザと同じ名前でないとならない
     * デフォルトアナライザ
         * アナライザが定義されていない場合、デフォルトで使用するアナライザを指定できる。マッピングファイルの `settings` セクションでカスタムアナライザを指定する方法と同様だが、`default` という名前にする必要がある
* ドキュメントソースの保存（p.50）
    * 個別のフィールドを保存したくない場合は、代わりに入力の JSON 全体を保存できる。デフォルトでこの機能が動作する。
    * ドキュメントソースを保存したくない場合は、 `_source` フィールドを無効にする必要がある
    * タイプの一部として設定を追加できる
* `_all` フィールド
    * 1つのフィールドに幾つかのフィールドをコピーして用意すると便利な場合がある
    * どのフィールドを検索すればよいかわからない場合など
    * Elasticsearch はデフォルトで `_all` フィールドにすべてのテキストフィールドの値を登録する
    * これを無効にしたい場合は、タイプ定義の一部として設定を追加できる
    * `_all` フィールドによってインデックスサイズが大きくなることに注意
* ダイナミックマッピングとテンプレート（p.52）
    * 型の決定メカニズムは、`""` の有無や、`true/false`、小数点の有無などである程度決定される
    * また、文字列から他の型にマッピングしたいときは、マッピング定義で積極的な検証を行うことができる
         * `numeric_detection` を `true` にしておくと `""` が付いた文字列の数字でも、数値として扱える
         * boolean はできない
         * 日付は `dynamic_date_formats` プロパティを配列でフォーマット指定しておくとそのどれかにマッチすれば日付として扱える
    * ダイナミックマッピングされた型のフィールドに異なる型のドキュメントを作成しようとすると、数値 -> 文字列なら例外が発生するが、 long -> double だと Elasticsearch は自動的に小数部を切り捨てて long として保存する
    * この機能をオフにしたくない状況は他にも、既存のインデックスに新しいフィールドを追加したくない場合など。
    * フィールドの自動追加機能をオフにするには、 `dynamic` プロパティに `false` を設定することで可能。
* ダイナミックマッピング（p.55）
    * 異なる型をマッピングしたくなった時は、ダイナミックテンプレートが便利
    * パターンが定義され、ドキュメントのフィールド名に適用される。フィールドがパターンと一致した場合は、テンプレートが使用される
        * `match`/`unmatch`
        * デフォルトのパターンはアスタリスクで、 `match_pattern=regexp` で変更できる
        * `path_match`/`path_unmatch` などのネストされたドキュメントの名前に対してマッチさせることもできる
     * `{name}` は入力ドキュメントで見つかったフィールドの元の名前
     * `{dynamic_type}` は元のドキュメントから決定された型
     * 定義された順にテンプレートをチェックして、最初にマッチしたテンプレートを適用する
* テンプレート（p.56）
     * インデックス設定（マッピング）は、複雑なので再利用したい
     * それができるのがインデックステンプレートという機能
         * インデックス名をチェックするためのパターンを定義しておく
         * インデックス名がそれにマッチした時、テンプレートに定義した値がインデックス構造にコピーされる
         * 複数のテンプレートがマッチした時、全てのテンプレートが適用され、後から定義されたテンプレートが前に適用されたテンプレートで定義された値を上書きする
         * 継承のように使える
         * 適用順を指定する `order` プロパティもある
    * ドキュメントのタイプではなく、インデックスに対して適用できるダイナミックマッピングがテンプレート
    * replica の指定をすると、replica を作りきって異なるサーバインスタンスにコピーを配置できた場合に応答を返して成功となるが、node が 1 つのクラスタでは異なるサーバインスタンスに replica が作れないのでタイムアウトエラーになる
    * テンプレートをファイルに保存することもできる
        * デフォルトでは `config/templates` ディレクトリに配置する
        * REST API から指定する時と若干 JSON の構造が異なり、メインオブジェクトのキーとしてテンプレート名を指定する必要がある
        * また、テンプレートファイルが Elasticsearch の全てのサーバインスタンスに配置されなければならない
        * ファイルに定義されたテンプレートファイルは、REST API 呼び出しでは使えない
* ルーティングの動作（p.58）
    * Elasticsearch はインデックスに登録されるドキュメントを保存する際に、どのシャードに保存するかを決めるために ID を調べ、そのハッシュ値を計算してハッシュ値に基づいて利用可能なプライマリシャードに保存する
    * その後、それらのドキュメントがレプリカに再配布される
    * 検索はインデキシングとは少し異なり、多くの状況では興味のあるデータを取得するには全てのシャードを検索する必要がある
        * 特定のユーザのドキュメントを取得するには次のクエリを発行する
        * `curl -XGET http://localhost:9200/posts/_search?q=userId:12`
    * もし、ある特定のユーザーの全ドキュメントを1つのシャードに保存でき、そのシャードに検索をできたら、パフォーマンスが向上するかもしれない
    * それがルーティング機能
        * ドキュメントやクエリをどのシャードに送るかを制御する
        * ルーティングは、インデキシング時と検索時の両方で値を指定できる
            * インデキシング時は同じユーザーが同じハッシュになるようにすることで、同じシャードに保存される
            * 検索時はインデックス全体ではなくある特定の1つのシャードを検索するようになる
        * ルーティングを使用するときは、ルーティングと同じ値になるフィルタを追加する必要がある
            * ルーティングに利用される値が、構築しようとしているインデックスのシャード数よりも大きな値になるだろうという理由から
            * 複数の異なるルーティングの値が同じシャードを指す場合が存在する
        * フィルタリングを省略すると、指定したルーティングの値に対してデータを取得するのではなく、特定のシャードに属する全てのルーティングの値に対してデータを取得することになる
    * 複数のルーティング値を指定する場合はカンマ区切りで指定する
* フィールドによるルーティング（p.63）
    * リクエストごとにルーティングの値を送信するのは現実的ではない
    * Elasticsearch ではインデキシング時にルーティングの値として使用するフィールドを指定できる
    * クエリ時に `routing` パラメータを渡すだけで良くなっている
    * フィールドによるルーティングを行う場合は、タイプ設定を追加する必要がある
        * `{ "_routing": { "required": true, "path": "userId" } }`
        * ルーティングの値が必須であることを意味し、これがないとインデックス登録に失敗する
        * `path` 属性でフィールドの値を決める
        * つまり、インデキシング時に各ドキュメントに `userId` フィールドが定義されている必要が有ることを示している
    * Elasticsearch は追加のパース処理を行うため、`routing` パラメータを使用するよりも少し遅くなる
* インデックスエイリアスと日常業務の簡素化（p.64）
    * インデックスのエイリアスとは、検索時に利用できる名前を1つ以上のインデックスにつけることができる機能
    * 1つのエイリアスで複数のインデックスを束ねて1つに見せたり、複数のエイリアスが1つのインデックスをしめしたりすることができる
        * 複数のインデックスを持っているエイリアスに対して、リアルタイム GET そうさやインデキシングはできず、 Exception を返す
    * インデキシングのために、ただ1つのインデックスに対して1つのエイリアスを付けることは可能
    * エイリアスを作成する場合は `_aliases` というエンドポイントに対して POST する。body に `add` コマンドで index <-> alias の対応を配列で登録していく
    * 3つのインデックスを横断的に検索するには `day10,day11,day12` のように指定するが、エイリアスがあれば `week12` のように1つでOK
    * 消す場合は `add` ではなく `remove`
    * `add` と `remove` は1つのリクエストとして送信できる
    * 全てのエイリアスを取得するには GET でリクエストを送る
* エイリアスのフィルタリング
    * エイリアスは RDB のビューのようなこともできる。全てのクエリ DSL や件数の取得、検索、クエリによる削除などの操作の際に利用可能
    * 以下のようにすると、 `clientId: 12345` で抽出されたビューのようなものを `client` という名前で参照できるようになる

```console
$ curl -XPOST 'http://localhost:9200/_aliases' -d '{
  "actions": [
    {
      "add": {
        "index": "data",
        "alias": "client",
        "filter": { "term": { "clientId": "12345" } }
      }
    }
  ]
}
```

* エイリアスとルーティング（p.68）
    * フィルタリングを使ったエイリアスと同様に、ルーティングについてもエイリアスを追加できる
    * 以下のようにすると、 `client` エイリアスを利用してデータをインデキシングすると、 `index_routing` によって指定されたルーティングの値が利用され、検索時は `search_routing` により指定された値が利用される
    * `curl -XGET 'http://localhost:9200/client/_search?q=test&routing=99999,12345` というクエリを実行すると、ルーティングの値は、 `12345` になる
        * `search_routing` とクエリパラメータの `routing` を両方採用するから

```console
$ curl -XPOST 'http://localhost:9200/_aliases' -d '{
  "actions": [
    {
      "add": {
        "index": "data",
        "alias": "client",
        "search_routing": "12345, 12346, 12347",
        "index_routing": "12345"
      }
    }
  ]
}
```

