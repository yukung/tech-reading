# DB設計総論

## 手順としての正規化

### DB設計の基本手順

* IDの導入
* 業務の視点からの正規化

### IDの導入

1. 全項目の洗い出し
2. 重複排除
	* 繰返し項目の排除
	* 同じ値の排除
3. 冗長性の排除
	* 導出項目（他の項目との組み合わせや計算で導出できる項目）の排除

ここまでで一般的な正規化は完了。あとは、

* ID を割付ける
* 割り付けたIDで関連付ける

を行うことで、変更に柔軟な疎結合なテーブル関係ができる。

### 業務の視点からの正規化

例えば、単価が一律ではなく、値引きをすることがある、というケースの場合、単に商品と単価でテーブルを切り出してしまうと、同じ商品に単価が複数存在するという状況を表現できない。そのため、明細側に単価を含めることになるが、基準が全くないわけではなく、値引きと捉える場合は、標準単価と実売価格が存在することになるため、商品テーブルと明細テーブル両方に単価を持つべき。こうすることによって、アプリケーション側でフラグを見て判断する、といったことをわざわざしなくても素直にコードを書くことができ、柔軟なシステムとなる。

これを業務の視点からの正規化と呼ぶ。`one fact in one place` 、つまり1つの事実は1つの場所にのみ存在するということは裏を返すと、2つの事実を1つの場所に置いてはいけないということ。そしてこれらを見つけるコツは、データ・値に着目してビジネスルールを見出すこと。

また、これを進めていくと重複だらけのテーブルに見えてくるが、実際には事実が異なる同じ名前の属性があるだけなので、これが正しい正規化。こうしないと結局アプリケーション側でデータの状態を気にするためにコードが分岐して複雑になっていくのである。

## データベース設計の基礎知識

### はじめに

* データベース設計は経験が重要
* データベース設計は影響度が大きい
	* 経験者が割り当てられやすい
	* 関われる人数が限られている
* そのため経験が積みにくい
* 経験不足でいきなりアサインされることがあり、難易度が高くなる

### DB設計の悩みと重要性

#### 悩み

* DB設計が定まらないとコードの設計が確定しない
* DBを参照しているコード全てに影響を及ぼす
* 一度公開すると気軽に変更できない
* 自分の実力が開発のボトルネックになりやすい

#### 抱えがちな問題

* バックアップや領域管理などの運用に影響を与える
* DBにアクセスが集中するため、パフォーマンスボトルネックを抱えやすい
* セキュリティや問題発生時のデータメンテナンスにも影響する

#### 精神的な負担

* 経験が足りないと、これで本当にいいのか確信が持てない
* のんびり設計を進めると、プロジェクト全体の遅延につながる
* どこまでできればいいのか、終わりが見えない

### 3つのポイント

上記の悩みを突き詰めると、以下の3つに収斂される。

1. 箱（エンティティの見出し方）
2. 主キーの設定
3. 重複の排除（いわゆる正規化）

### 箱（エンティティの見出し方）

#### エンティティとは何か

* 一言で言うと集合、セット（set）、クラス
* 要は学校の教室のようなもので、集合＝箱と捉えるとわかりやすい
* このように模擬的に図式化することをモデリングという

#### エンティティ名の役割

* 学級名みたいなもの
* データの「意味」によって名前付けがされる
* レコードはタプルとも呼ばれる「データ項目の組み合わせの構造」
* タプルに実際の値が入って現実化するとインスタンスと言ったりする
* それぞれのデータ項目はドメインともいう。ドメインはリレーショナルデータベースにおいてはカラムと同じ意味

#### エンティティ名の決め方

* 重要な事は、「記録したくないもの」は、データベース設計の対象から除外して構わないということ
* 「記録したいもの」がエンティティ名の候補
	* モノ
		* リソース系エンティティ
	* 行為
		* イベント系エンティティ

見出したエンティティ名を6W3Hによる整理を行うと、ビジネスモデルとデータモデルの間の整合性を見ることができる。

* リソース系
	* 誰に / Whom
	* 誰が / Who
	* 何を / What
	* どこ / Where
* イベント系
	* どのように / How
		* 販売・仕入・出荷・入金
* 属性の候補
	* いつ / When
	* どれくらい / How many
	* いくら / How much
* 業務観点からの正規化の対象
	* なぜ / Why
		* 売上・返品・値引き・補充など

属性の候補や業務観点からの正規化の対象となるエンティティは、最初からこれらと向き合うと不安になりがちなので、最初はイベント系の適当なところに放り込んでしまい、あとから正規化する。

#### ビジネスの流れとデータモデル

* 既存業務であれば紙や画面を見ることで網羅すべきデータ項目についておおよそ検討がつく
* 新規ビジネスではまだ見ぬ業務を想定しながらデータベース設計を行っていく
* データモデル上に現れているものに対する論理的なレビューはできるが、**あるはずのものが不足していることを指摘するのはとても難しい**
* システムが業務上の要件を満たせないと、コードの仕様変更が発生して、業務とアプリケーションとデータベースが三すくみになってプロジェクトの進捗が硬直する
* これを避けるためにも、データベース設計の担当者が業務用件やビジネスモデルを理解すべき
	* 他にも使い勝手や障害対策、パフォーマンスや例外パターンなど考慮すべきことが多いから

### キーの設定

#### キーとはなにか

一般的によく取り上げられるキー

* 主キー（プライマリキー）
	* PRIMARY KEY 制約
	* NOT NULL のユニークインデックス
* ユニークキー
	* ユニークインデックス。NOT NULL 制約がなければ NULL も許可
* 候補キー
	* インデックス
* 外部キー（フォーリンキー）
	* 参照整合性制約

キーというものの意味を正しく理解していないままに主キーとして定義してしまっているために、大きな問題となる。

#### コードとキーの違い

* コードは、ユーザがレコードに容易に到達するためのユーザインタフェース
* コード体系は、システムの都合ではなくビジネスの都合によって決定されるもの

から、「全社統一コード体系の整備」などのアプローチは理想だが、現実的ではないと断言できる。

* コードは、ユーザーインターフェースなので非正規形であるし、移ろいやすいもの
* コードとはそれぞれのレコードに付けられた単なる「名前」であって、識別子ではない
	* コードは「あだ名」
	* 氏名というフィールドをキーにはしないのと同じ

あまりにも数多くの正規化の問題が、メインフレーム時代の複合コードをバラすというものだったために、妙な刷り込みが行われたというのが正しい実態。

主キーには、コード（あだ名）ではなく識別子（identifier）を設定すべき。

* identifier とは、いわば出席番号のようなもの
	* 振り直しや付け替えはせず、単に連番を振る
* こうすると、コード体系が変わろうともレコード間の関連は影響を受けずにそのまま維持される
	* Oracle の ROWID 擬似列や、オブジェクト指向における OID を流用するとかはやってはいけない
	* バックアップしてから再度テーブルに戻すと変わってしまうので、不整合が生じる
* identifier はインスタンスのライフサイクルを表現している
	* その集合の中に属してから消滅するまでの間、特定のインスタンスであることを示す座標として機能している

#### コードはアクセスパス

* コードはインスタンスにたどり着くための経路
* つまり候補キー、インデックス
* 利用者の意図に応じて適宜変更可能なもの
* インスタンスのライフサイクルとコードは「事実として」必ずしも一致しない

#### コードの洗い替え問題

* 商品コードがスペックチェンジによって変更されるケース
	* 参照している側も全て変更しなければならない
* 地区コードが変更されるケース
	* 地区コード自体が変更されるか、地区そのものを全て変更しなければならない
* いずれも「管理のためのコード体系」を、管理上のビジネスニーズを無視してシステマチックに正規化してしまったことが原因
* identifier とコード体系と正規化された個々のドメインをそれぞれ別に用意してやることで、問題を回避できる

例えば、顧客コードの体系に都道府県が入っていたりする場合、顧客が東京から大阪に移転するとコードを変更するか必要が生じるが、そうすると過去の取引履歴が参照できず、比較ができなくなる。こういう設計をして本番に入ってしまうと、運用してしばらく経ってから（プロジェクトメンバーが居なくなってから）問題が表面化する。

コード体系もそれぞれにテーブルとして切り出してやるとより安定する。こうしてコード体系と identifier を分離して考えていくと、identifier が外部キーとして参照すべきものになる。

大切なのは、項目を単に正規化することではなく、「適切」に正規化することが必要。適切な正規化とは、そのデータ項目の役割あるいは意味付けが単純である、すなわち1つの役割あるいは意味しか有しない状態までアトミックに分解すること。

#### 諸口問題

* 諸口とはその他もろもろ、つまり会員制サイトならゲスト扱いにして全て同じコードを設定するような場合
* 顧客テーブルで管理している顧客とは別に、ゲストの扱いを売上テーブルにゲストの顧客名を入れるなりフラグを与えるなり備考欄に顧客名を入れるなり
* これは敗北宣言で、正規化ではない
* データの基本は「事実」を「正しく記録する」こと
* こういうデータ設計は、コード体系と identifier を分離していないから起こる
* これも identifier が振ってあれば、後から顧客コードを振り直すことで正規会員としても扱える

上記のテーブル構造を見て、入力をどうするのか？という質問をされることがあるが、画面はユーザーインターフェースであり、非正規化されたデータである。人間が扱いやすくするべきなので、テーブル構造と対になる画面などありえないとわきまえること。画面は画面がやるべきことをやればいいし、DBも同じ。画面の都合でデータ設計をねじ曲げるなどは本末転倒。

リレーショナルデータモデルの正規化のポイントは関数従属性だが、関数従属性は何に対して考えるのかというと「キー」に対してであり、ビジネス上の都合によるコード体系に対して従属するのではない。そしてリレーショナルデータモデルでいう「キー」とは、ある「インスタンス」を一意に特定できるものであり、アクセスパスではない。コード体系には「ひっくるめて見たい“場合もある”」という恣意性を内包しているが、ひっくるめて「見たい」のは人間の都合でありアクセスパスのことであり、ユーザーインタフェースである。
コード体系に必要なのは「使い勝手」であり、正規化するためにビジネスの柔軟性を損ねるようでは本末転倒。

#### 計画系のコードの扱い

* いわゆる「仮コード」問題
* 「仮コード」と「正式コード」という列をもたせると、以下の様な問題が発生する
	* 正式コードが決まるまでは NULL 値または諸口コードで扱うので、主キーに使えない
	* 仮の状態と正式の状態の2世代しか管理できないので、仮コードの推移を管理できない

これは、identifier の導入は当然として、さらにコードの履歴化が必要になる。顧客エンティティに対して住所履歴を他のエンティティに持つのと同じ。

この場合は、コードはあだ名というよりも住所の扱いとなる。

この時にコードの履歴が追えないと、計画が進んでいくに連れて予実対比などを求められた時に比較ができない問題が生じる。つまりそれぞれのフェーズにおいて違うコード値が付いているのに、同じものとして比較できないといけないたため。

この時に備考欄などに経緯を書いてアプリケーションで解決するのはデータ中心アプローチとは呼べないしデータベース設計の敗北。

#### m:m 問題（コード体系の統一不可能問題）

* 1つのインスタンスに複数のコード体系が存在するケース
	* そのモノを特定する人がそれぞれの都合でコード体系を用意するためにコード値が異なる
* 会社間でまたがった取引などで、同じインスタンスに対して取引先が異なることでコードを変えて扱いたい場合など
* 現実的にコード体系を統一することは不可能
* コードの読み替えは、「業務要件」
* 業務要件を見落としてデータベース設計を行うと、運用後に使えないシステムになる

これを把握してデータベース設計に落としこむには、m:m 関係を表現するエンティティ、具体的には一般に交差（インターセクション）エンティティあるいは関連エンティティを用意する必要がある。

全社統一コード体系は理想だが、精神論だけではエンジニアリングとは呼べない。コード体系の統一は安易に放棄してはならないが、ビジネスルールにも寿命があり、それがシステムの寿命と一致するわけではないということを認識して、将来性を損ねずに現実的な対応をするのが肝要。

#### データライフサイクルと identifier

* データライフサイクルは CRUD のこと
* identifier はデータライフサイクルをインスタンスごとに表現している（存在している）
* ただし、論理削除という概念を導入すると変わってくる
	* 削除フラグなのか、削除日なのか削除したユーザという列を追加するのかは要件に従うことになるが、この場合 identifier それ自体では論理的なライフサイクルを表現せず、単に論理ポインタの役割を果たすだけとなる
* 物理的にレコードを削除して、ファイルや別のテーブル、ログなどに identifier ごと書き出す場合は、ライフサイクルを表現している
	* この場合の identifier の虫食いを再利用すべきかどうか、という問題がある
	* パフォーマンスとの絡みで何年か経過したらバックアップを取って削除する、という対応になるが、もし過去分を追加で戻して比較をしたい場合に、identifier を再利用すると困った事態になる
* 結論としては、 identifier の再利用はすべきではない
* 時間軸として死んだ identifier は「死んだ」という事実を表現している
* identifier を使いきってしまう問題はそうそう発生するものではないので、キャパシティプランニングをしっかりして対応すること

### ビジネス上の正規化

#### 重複の排除

* コツは、「いかに正しくするか」じゃなくて「いかに無理なくムラなく無駄なくするか」
* 最小限のデータで最大限の効果を発揮する
* 重複の排除は、単に正規化をするだけではなく、重複とは何か、どういう状態かということを考えることが大事
* 教科書的に重複しているように見えるものでも、事実が異なるのであればそれは重複ではない
* 事実の目印となるのが identifier

##### よく重複の排除の例に上げられる売上明細の明細部分

* ヘッダ・ディテール関係ともいう
* 売上を表現しているのは、ヘッダ側ではなく明細側
* 別に売上明細テーブルだけでよいのでは？
* ヘッダテーブルが欲しければ、ビューを作ればいいだけ
* そうしないのは、バッチ（一括）売上という事実に対する扱いを容易にするため
    * 例えば、総額に対する税金を計算する時に、1売上ごとにサム・アップするか、総額に対して一括で計算するかで誤差が生じる可能性がある
    * これは一種の導出（デリベーション）ルールであり、ビジネスルール。システム的な都合とはいかない
    * 複数の売上を一括で扱うという「事実」を扱うために見出しを使う
    * 逆に言えば、一括扱いが一切ないのであれば、単にストリームデータとして売上を計上していけばいいので、無理して見出し・明細形式に拘る必要はない
* このように重複とは「何だろうか」ということに目を向ける

##### 重複の排除と履歴データの扱い

* イベント系のエンティティに重複項目を用意したり、都度都度の各種コードを埋め込んでおく、というやり方は古い
* サブセットを使うか、履歴用のエンティティを別途用意するかを考える
    * よくある例が、単価が変わったケース
    * 売上発生時の単価を記録するために商品テーブルに「単価」という列とは別に、売上テーブルに「販売時単価」という項目を用意しようとする
    * これは変。「販売時単価がそのときいくらだったか」という事実の捉え方で、これは「売上」の履歴ではない
    * あくまでも「単価」の履歴なはず
    * もしこれが「売上ごとに設定される単価」であれば「売上」に従属するので問題ない
    * しかしその商品の単価が一律に変更されていたのであれば、それは「商品」に従属しているので、「商品」テーブルに関わる形で管理されていないといけない

#### 履歴や時系列に状態遷移するデータの扱い

* ある1つのものが時系列に状態が変化していくもの
* ステータス変化、ワークフローなど
* 履歴というよりも、予定系、計画系と言える
    * 例えばホテルの予約
    * 予約→チェックイン→宿泊中→チェックアウト
* よくフラグで表現しがちだが、これらはチェックインエンティティやチェックアウトエンティティとして別のテーブルで表現してやることが大切
    * ワークフローの全体をシステム化するとは限らない
    * また、似て非なるものを一緒くたに扱おうとするため、非なる部分をフラグで制御することになり、複雑になる
* ステップが変わったらどうするのか
    * フラグ形式であれば区分コードを追加するだけで対応できそうに見える
    * が、実際はワークフローが増えるということは業務が増えているので、それに関連した画面や帳票、一覧などを出力する業務が増えて、フラグ追加だけでは結果的に済まないケースが多い
    * 既存のシステムなら尚更、テーブルを追加してやるほうがリスクを抑えることができる
* ハードウェアの性能も上がっているので、昔の手法にこだわらず、ハードウェアの進化をもっと活用して良い

#### デリベーションルールとバリデーションルール

* 逆方向に導出ができないことを「不可逆性」という
* 正規化をした結果、不可逆性を有することになっては困る
* 例えば単価×数量＝金額の時、値引きなどがある場合は不可逆性を有するので、「金額」も項目として持つべき
* 可逆性の導出項目は、一般的にはテーブルから追い出すのが望ましいとされているが、毎回アプリケーションで計算するのではなく、データベース上のどこかに保持しておくべき
* それはビューとして表現する
* データベース設計上、ビューはテーブルを補完するものとして扱うのがコツ

##### バリデーションルール

* 例えば、都道府県コードを選ぶと紐付いている営業所コードの中からしか選択できないようにする、といった要件
* これは、「関係」を管理することが肝
* 「従業員」と「組織」との関連
    * 組織エンティティ（リソース系エンティティ）
        * 組織ID
    * 従業員エンティティ（リソース系エンティティ）
        * 従業員ID
        * 組織ID(FK)
* これでは、組織がなくなった場合に従業員も所属がなくなってしまう
* 「所属」エンティティが必要
    * 「所属する」というイベントを管理する
    * 所属エンティティ（イベント系エンティティ）
        * 所属ID
        * 組織ID(FK)
        * 従業員ID(FK)
* この手のパターンはもう無条件にこのようにする、と言ってしまっても過言ではない
* もう一つ、組織階層などツリー構造を関係データベースとしてどう管理するか
* これも1つのパターンとして、無条件に以下のようにして良い
* 組織エンティティ
    * 組織ID
* 組織構造エンティティ
    * 組織構造ID
    * 上位組織ID(FK)
    * 下位組織ID(FK)
* 上記の「従業員」と「組織」「所属」と同じパターンだが、リソース系エンティティ（組織）が同じ構造をしているために正規化した結果1つになっただけ
* ユニーク制約を付与すれば、1:1 にも 1:m の関係にもできる
* 「所属開始日」と「所属終了日」を追加すれば履歴データになる

#### 複雑なビジネスルール

* 複雑なビジネスルールはそれなりに複雑なデータ構造になる
* 一言で「単価」と言っても、人や状況やプロセスによって定義が異なる
* これを単に「単価」と設計してしまうと、そのツケはアプリケーション側にしわ寄せが来る
* 分岐の嵐になる。IF文の嵐になる。
* 本来はデータ構造で表現すべきこと
* データベース設計をサボると、アプリケーション設計がより複雑になってしまう
* データに紐づくものはデータベース上で表現・管理されるべき
* テストを行う前に性能面を気にして非正規形にしがちだが、それは最終的に効果のない正規化だったりする
* 大事なのは正規化する対象を洗い出すこと
* それから正規化をしっかり施すこと
* 正規化した結果エンティティ数が膨大になったとしても、それが現在のビジネスルールの実態なのだということを認識すること

### DB設計の手順

1. おおまかにブロック分けを行う（業務単位か部門単位）
2. それぞれのブロックごとにイベント系を洗い出す（この時点では、正規化を意識しない）
3. イベント系に対する正規化を行って、リソース系を洗い出す
4. リソース系に対する分類の洗い出しを行って、リソース系の正規化を行う
5. ブロック間でリソース系の統合を行い、さらに正規化を行う
6. 導出系の整理をして、最終的な正規化を行う

#### ブロック分け

* 大抵の場合、組織は業務上の役割の分類で括られているので、業務と近似する
* ある程度のブロックに分ける
* 分けるに際しては、プロジェクト内で統一した切り口に揃える

#### イベント系エンティティの抽出

* そもそもシステム化したいということは、イベントを管理するため
* リソースだけを溜め込んでも仕方なく、イベントを分析することによって価値を得られる
* 意外とイベント系のエンティティは少ない
* 動詞で言えるものがイベント系
    * 更に言うとタイムスタンプを打てるものがイベント系
* いつ（When）が属性として設定できるもの
* リソース系と比べてヒアリングや情報収集は比較的容易
* とっかかりやすさから見ても、必要性から見ても、イベント系からアプローチしていくほうが確実
* まずはざっくりと大きなエンティティを書き出す
* 入力系業務と出力系業務を見ればおおよその当たりは付く
    * 入金と出金
    * 入庫と出庫
    * 受注と発注
* 購買部門
    * 発注（out）
    * 受入（in）
* 営業部門
    * 受注（in）
    * 見積（out）
    * 納品（out）
* まずは間違っていてもいいのでエンティティを書き出す

#### イベント系エンティティの正規化

* 見当外れだったのならここで判明するし、当たりがついていれば正規化を施すとずいぶんと見えてくる
* イベント系エンティティを正規化すると、リソース系エンティティが浮かび上がってくる
* コード体系が見えてくるので、コードを手がかりにリソース系エンティティを見出すことができる
* リソース系の洗い出しが進むと、値引きや単価決定、所属などの関連エンティティも浮かび上がってくる
* あくまでも大局観を維持しながら分析していく

#### リソース系エンティティの分類を整理

* 注目すべきは、サブセットの扱い方
* 「顧客」は、「個人顧客」と「法人顧客」に分かれる場合、個別のエンティティとして表現するか、区分を用意してエンティティの属性として捉えるかを判別する
* 大抵の場合は、サブセットという形でエンティティ化しておく方が上手く収まる
    * 例えば、法人顧客としても個人顧客としても扱う場合があったりすると、区分ではアプリケーション側に負担を強いることになる
* 大規模なシステムでは、この「分類」が非常に多いので、分類に惑わされてしまう
    * リソース系エンティティを先に手を付けなかったのは、これが大変だから
   * 分類を見てしまうとどうしても惑わされてしまう
* 歴史のある大企業では過去の経緯で持ち続けている分類なども多く、それを既存のアプリケーション側でカバーしていたりする
* 半年くらいで変わってしまうことも往々にしてあり、組織変更などもあると陳腐化しやすい、移ろいやすいものである
* できるだけ柔軟に対応できるよう、交差エンティティをできるだけ使っておくほうが無難
* この段階でJOIN処理の多発などを気にしてはいけない
* どっちつかずになってしまう

#### ブロック間でのリソース統合

* イベント系エンティティはそれぞれのブロックごとに独立しているもの
* リソース系エンティティは使いまわされる
* 例えば「商品」
* リソース系エンティティを上手く統合していく
* これができると、長生きするシステムになり、アプリケーション側も楽になる
* 個別のエンティティの属性を、複数のエンティティに分離したり関連エンティティを新たに見出したりすることで統合していく
* ブロック間のインタフェースとなる関連エンティティはメンテナンスをどちらの部門が行うのか、はっきりしておかないとメンテナンスされずデータの整合性が保てなくなるので、しっかり調整を行うこと

#### 導出系の整理

* ここから教科書的な正規化を行っていく
* 複数のエンティティを組合せて導出するものは、ビューで済むものはできるだけ冗長なものとして排除していく
* 入庫と出庫なら、導出できるが、例えば「期末確定」を持つべきかどうかという業務ルールに基づく判断が必要なこともある
* こういった「現在xx」というものは、たいていのケースで複数のイベント系エンティティの組合せで導出可能
* 性能が気になるのは事実だが、これは実際にテーブルを作ってテストデータを投入して、ビューの性能を測定してから最終決定をする
* 時系列の推移についてもここで吟味する
* 履歴や、予定系・計画系についてもここで検討
* イベント系エンティティは履歴データなので、リソース系の状態推移が検討の中心となる
* ここまでくれば、基本的には問題のないデータ構造ができているはず
* ここで性能面に問題が見つかれば、導出項目を個別エンティティとして切り出して表現するなどを検討していく
* あまり最初から性能を気にしてあちこちに導出エンティティを作らないようにして、適切なSQLとインデックスさえ作れば、多くのケースで問題のないデータベースとなるはず

# RDBMS 総論

## RDBMS の必要性を考える

### RDBMS の必要性とは

* 標準化されたSQLの存在
* 物理情報と論理情報の分離
* データ整合性保持の容易性確保
* 複数ユーザによる同時利用の実現

####  標準化されたSQLの存在

* 異なるプログラムからでも同一のインターフェースでデータにアクセスできること
* 情報が豊富なこと

#### 物理情報と論理情報の分離

* フラットファイルのようにデータの物理的な構造（先頭から何バイトなど）を意識しなくても、名前でアクセスできること

#### データ整合性保持の容易性確保

* フラットファイルではファイルをオープンして存在チェック、クローズと、本質的には必要ないことまで意識する必要がある
* それが出来ないとデータが壊れる
* RDBMSではその部分を仕組みで解決でき、本質的なことに集中できる
* データ型によりデータの保護も行ってくれるため、生産性や品質の向上に寄与する

#### 複数ユーザの同時利用の実現

* フラットファイルでは、同時にそのデータにアクセスした際の交通整理も実装する必要があるが、RDBMSではそれを仕組みとして解決してくれる
* RDBMSは、本来「事務処理を担うビジネスシステムの中でのデータ活用」という観点から考えられた仕組みである

### 構造化技法に対するアンチテーゼとしてのRDBMS

#### 情報システムの高度成長時代

* 事務処理をコンピュータに置き換え効率化する機運が高かった
* いかに効率よくプログラムを大量生産できるかが議論された
* 属人的な職人によるプログラミング技法を排除して、熟練者でなくても容易にプログラミングを行える方法が検討されていた
* 構造化技法が登場し、1つずつの機能を把握可能な規模にとどめながらも、全体の大規模化に耐えうる構造を実現しようとした
* しかし、構造化技法では限界があった
* 当時の業務システムというのは、基本的には帳票出力マシーンであった
* ジャクソン法やワーニエ法でも、基本的には入出力の構造に着目してプログラムを作成する
* 出力は帳票として変えられないため、入力側のデータ構造を扱いやすい形式に変換してやる必要があった
* 例えば部門別・商品別売上一覧を作るためのデータ構造変換用プログラムや、中間データ作成のソートプログラムなど
* こういったプログラムが、レポートの数だけ必要になる
* 変換前と変換後で二重持ちの状態になり、無駄が多い
* 本当に価値のあるプログラムは、全体の数分の一しかないことになる
* 当時のハードウェアは貧弱でもあったため、データを上書きして再利用したり、CPUも貧弱なので時間がかかり、それを避けようとしてデータの整合性が取れなくなったりしていた
* 価値を創出しているはずのプログラムの3割未満のプログラムも、全てが正しい処理をしているとは言い切れない状況だった

#### データ貴族主義からの解放

* 現場のエンドユーザ側からすれば、ビジネスを取り巻く状況は刻々と変化するため、新しい切り口のレポートが常に欲しい
* プログラムを単に作ればよいだけではなくて、影響がないように調査して設計し、値変換プログラムなどを何本も書く必要があった
* 時間がかかる
* こういった状況を解消すべく、データを誰からでもアクセスできるような仕組みとして、リレーショナルモデルが考案された
* 規模に対する闘い方を根本から見直そうというパラダイムシフトと、エンジニアという特権階級からのデータの解放

#### 効率から効果へ

* 構造化技法はいかに効率よくプログラムを作るか、という発想
* リレーショナルモデルはいかに効果的なプログラムを作るか、ということに着目
    * 逆に言えばいかにムダなプログラムを作らずに済ませられるか
* 改めて強調したいのは、RDBMSは極論するとレポート生成機
* いかに簡単にレポートを作り出せるか
* ということは、いかにデータを取り出すか、簡単にアウトプットして活用できるかが重要
* データを貯めこむ（input）だけでは意味が無い
* つまりデータベースというのは経営資産である

### 経営資産としてのRDBMS

#### なぜデータが重要なのか

* プログラムは、極端に言えば経営資産ではない
* 必要に応じて作りなおしてもいいし、破棄してもよい。柔軟に変更されて然るべき
* データというのは、活用していくほど価値が創出される
* データこそが非常に重要

#### データは誰のものか

* データは企業のもの
* 一部の人の手に閉じ込められている状態は良くないし、不良資産
* データが全員で共有され、活用されなければ、適切な意思決定は行われない
* アウトプット指向で考える
* 利用されないデータはムダなだけ、土地代・電気代を無駄遣いしており、単なるコスト

#### 果たして蓄積することが重要なのか

* レポート指向で設計されるべき
* とりあえずこんなデータがあったらよいといった、突っ込んでいくこと自体が間違っている
* プログラムを簡単に作るためにデータベースをプログラマの都合だけで勝手に設計を変えて使うことがいかに不合理なことかを認識する

### 業務プロセス再編と情報ロジスティクス

#### リエンジニアリング革命再考

* 統合データベースというものを持つことに寄って、企業の活動とビジネスプロセスの最適化を行う
* つまり、「業務プロセスをいかに最短に終わらせることができるか」が重要
* ERPも考え方は同じ
* ビジネスプロセスというものを強く意識し、その再編・最短化、プロセスが生み出す価値の最大化を考えた上で統合データベースというものを作れなければ、それが統合され共有できる状態になっていたとしても、何の意味も持たない

#### 必要な時に必要なところへ必要なだけ

* いかにプログラムを作らずに済ませられるかが重要

## 経営資産の視点に基づくDB設計

### データ中心アプローチの本質

* データの正規化・最適化を持ってデータ中心アプローチということは言えない
* データは企業のプロセスの中で流れていく情報で、この流れを滞り無く無駄なく流れるようにし、「本当に必要な物だけを保持」して「必要なときに必要な形にすぐ構成して取り出せる」ことが重要

#### データライフサイクルと正規化

* CRUD がプロセスの流れで表現されるデータライフサイクル
* CRUD という概念を通じてデータとトランザクション（プロセス）との間にマトリックスが書ける
* 無駄なCRUDを正規化していくことが、トランザクション（プロセス）の正規化
* トランザクションの正規化を進めていくと、余計なUIが省かれていき、UIが省かれれば余計な立場の人が無くなる（ロール、ユーザ、組織）。
* 組織がなくなれば、事業戦略が見直されていく
* こうした流れを推進していくことが、データ中心アプローチの本質

### 数学的正規化と業務的正規化

* 教科書的な正規化は不要なものではないが、現場ではもう１つ知恵が必要
* 理論としての正規化は基本としてわきまえておくべきこと
* 売上伝票１つ取ってみても、単に単価と表現するか、期間によって変動する単価や顧客別の単価、割引単価などをひっくるめて単価と表現するか個別のエンティティの属性として表現するかで、その後のデータ構造の変更容易性も変わってくる
* エンティティが増えれば、それをメンテナンスする役割の人や部署が出現してくるし、その業務フローが変わってくる
* こうした現実をいかに見いだして、ERDに写像できるかがビジネスにおいてのデータベース設計であり、業務的な正規化である

### 論理設計と物理設計

* 物理設計イコール非正規化、ということが果たして正しいのかを考える必要がある

#### ハードウェアの高性能化

* 昔と違い、ハードウェアスペックは年々上昇している
* 正規化すると性能が悪くなる、はそうではなくなっている
* 正規化したことでレコード数が増えても、今のコンピュータのスペックからすると微々たるものになってきている

#### 論理設計を無駄な工程にしないために

* ビジネスモデルを写像して、ビジネスにおける正規化を行ったのに、それを崩す非正規化を行うこと自体が、手戻りと呼んで良い
* ハードウェアの高性能化が、ある種の問題を解決してくれる
* ただそれでも、物理設計というものは存在し、それはスペックを有効に引き出してやるための配置を行うこと
* つまりインデックスの設計であり、これが物理設計と言い切っても過言ではない
* 非正規化しても性能が上がるとは限らない
* SQL はつまるところ構造化プログラムでしか無い
* 基本的にファイルをシーケンシャルアクセスするために、全件総なめが頻繁に起こる
* これをいかに抑えるかが物理設計のポイント

#### インデックスを設計するということ

* 図書カードにポインタの番号が書いてあり、書棚があいうえお順でソートされている状態を思い浮かべるとよい
* ただし、インデックスの利用にはおおきなトレードオフがある
* 追加や更新に対しては、即座に並び替えが必要な点
* ただ追加や更新にも、検索処理は内包されているため、インデックスが必ずしも更新処理を遅くするわけではない

#### 主キーとアイデンティファイアは別のもの

* 社員番号であろうと何であろうと、そのレコードが誕生してから消滅するまでの間、そのレコードが表現する事象がその集合に存在しているのは事実
* レコードそのものの一意性を確保するも識別子が別にあっても良い
* ただそれが、Oracle における `ROWID` や  PostgreSQL における `OID` では、データライフサイクルを表現するには問題がある
* バックアップしたデータをリストアすると、勝手に振り直されていることがあり、これはシステムの都合であってビジネスの都合ではない
* ビジネス上のデータライフサイクルを表現するものとして、アイデンティファイアを設定する
* データが生成された時から消滅するまでの間一意である必要がある
* 主キーとは別。主キーはそのレコードに辿り着くまでのアクセスパスにすぎない
* そのために既存のコード体系を主キーにすると不自由になってしまう
* キーは複数あっても構わない
* データそのものは静的なもので、動的なプロセスがそのときどきで呼びやすいキー、名指ししやすいキーを設定してビジネスプロセスが流れれば良い
* それをインデックスとして実装することが、物理設計といえる

### コード体系は「いつ」「だれ」が決めるのか？

* コード体系は、得てして適当決まってることが多い
* 未来を予測してビジネスの開始時に決めきれることなんて無い
* もっともらしいルールを後付していることがほとんど
* 元が論理的じゃないコード体系について論理的に考えることほど無駄なことはない
* だから、コードとIDは切り分けて扱う方がよい

## 資産活用としての SQL

### SQL の本質と構造化プログラミング

* SQL はインタプリタであり、バッチ処理
* ループの中で1件ずつ SQL を発行するなど、愚の骨頂であるがよく見る話でもある
* 内部動作を知っていれば絶対にやってはいけないことだと理解できるはず

### SQL はバッチ処理である

* 人間の手間を減らす代わりに、SQL が様々なことを肩代わりしている

#### SELECT 文に始まり SELECT 文に終わる

* 例えば `SELECT * FROM t1` という SQL があったとする
    * 内部的にはまず `t1` というテーブルがあるかをカタログテーブルやデータディクショナリと呼ばれるところに検索する
    * さらに `*` で列のインライン展開を行う際にカタログテーブルを参照する
    * 最後にテーブルを全件取得するループ処理が実行される
* `WHERE` 句の絞込みは、C や COBOL で言うところの読み飛ばし処理を行っている
    * 自動的に分岐が入っており、条件に合致するレコードは本当に1件だけかどうかは全件見てみないとわからないため結局全件検索している
* つまり、プログラマはたとえ1件取得するだけの SQL だとしても、常に大量のレコードを相手にしていることを意識していないといけない
* `UPDATE` 文や `DELETE` 文においても、`WHERE` 句は `SELECT` 文と同じ処理が行われているし、更新対象とするべきレコードをテーブルから検索してメモリ上に取り出し、その状態になって初めて項目の書き換えが行われる
* 更新でも内部的には `SELECT` 処理が行われているので、テーブル情報を格納しているカタログテーブルに検索を行うので、テーブルにはレコードができるだけ少ないほうがいいのは当然

#### 結合処理と SORT 処理

* マッチング処理を行うが、これは C や COBOL のように事前にレコードの SORT を行って、順次読み込みの一定条件に基づく突き合わせを行っていく（ソートマージアルゴリズムの場合）
* 結合処理のためのキーと、処理結果の並び替えを指定する `ORDER BY` 句の項目が全く違っているとすれば、3つのテーブルを結合する場合は各テーブルに対する SORT 処理、プラス結果セットに対する `ORDER BY` 句に基づく SORT 処理の計4回もの処理が行われてしまう
* SORT はコストの大きい処理なので、遅いのは当然

#### RDBMS の内部動作を知る方法

* `EXPLAIN` や `PLAN` コマンドを実行すると、どのテーブルにどのようにアクセスするのか、インデックスは使っているのかなどがわかるので、それを見ながら調整していく
* SQL を使いこなすには逆説的には構造化プログラミングによるレポーティングについて学ぶのが有効

### Fetch を使う悪い癖

* 更新処理に `FETCH` を使うのは非常に無駄が多い
* 更新対象レコードを取り出したのに、アプリケーションのメモリ領域にわざわざ取り出して、それをまたデータベース側に戻すオーバーヘッドが発生する
* 大抵の場合、サブクエリを使った `UPDATE` 文を発行することで1発で処理できる
* こうすると、クライアント・サーバ型のやりとりよりもオーバーヘッドを少なくできるのと、`FETCH` 部分のアルゴリズムが DB のオプティマイザに委ねることができるので、自作のアルゴリズムよりも往々にして速いことが多い
* 処理的にも取り出した DB 側のメモリ上で書き換えたほうが速いに決まっている
* そもそも RDBMS の実行計画が信じられず任せられないのであれば RDBMS を使わずに自前で解決すれば良い
* せっかくの機能は使った方がよい
* ISO 標準の構文じゃないからといって RDBMS 特有の機能を徹底的に拒否するのも考えもの
* その機能があるということは、それを使うほうがより効率的に処理が行えるということ
* 標準準拠するメリットと、実行効率のメリットを比べて、メリットが出るのであればちゃんと使うべき
* RDB が移行されるようなことはなかなか無い

### INSERT 文でさえバッチ処理である

* そのレコードが既に存在していないかを調べる必要がある
* 主キーで存在可否を確認する
* つまり、`SELECT` が必要になる
* `CREATE TABLE` や `DROP TABLE` でさえそう
* エンジニアであればない動作に対する気配りはするべき

### インピーダンス・ミスマッチの解決方法

* プログラミング言語と SQL 両方を学習するコスト
* SQL は集合指向、プログラミング言語はレコード指向
* パラダイムが違うものを同じ世界で扱うのでそもそも面倒な話が前提となる
* SQL に対する扱いがぞんざいになり、パフォーマンスが落ちがち
* SQL 側の面倒さを隠蔽するのに、ストアドプロシージャを使うのが1つの解決策

### ストアドプロシージャとは

* SQL の集合をいわば1つの関数として扱うことができる
* メソッドのシグニチャが同じであれば、ストアドプロシージャ内の処理が変わっても呼び出し側には影響をなくできる
* つまり、RDBMS に対するアクセスメソッドのカプセル化を実現できる

### クラスの粒度とエンティティの粒度

* RDBMS 全体を1個の Singleton オブジェクトに見立てて、RDBMS の中に格納されているデータを private なものにしてしまう
* RDBMS の権限付与の仕組みを使えば、公開先の限定も実現可能

### 機能レベルのインターフェイス

* 要件によって、例えば定型的なプログラムからのアクセスは、ストアドプロシージャをインタフェースに使ったり、アドホックなユーザからのクエリはビューをインタフェースに使ったりと、利用に適したインターフェースを提供すべき

# 楽々ERDレッスン

## 第1回　お持ち帰りご注文用紙編

* まずイベントを見出す
    * 注文エンティティ
    * イベントとは行為なので、「〜する」という言い方ができる
    * イベントはなにかということに注目するクセを付けると、色々なことに対して目が利くようになる
* 次にリソースを見出す
    * 顧客エンティティと商品エンティティ
    * 「誰が」「何を」で抜き出せる
    * 「〜する」とは表現できないもの
    * 商売・ビジネスを行う上で必要な資産がリソース
    * リソース系はデータ構造が複雑なケースが多いので、イベント系から洗い出したほうが結果として精度が高い設計が実現できる
* 箱ができたら、項目を入れていく
* 帳票から拾える項目を、ふさわしい箱に埋めていく
    * 税込み金額は税率エンティティとして切り出してもいいが、ここでは一旦そのまま
    * 商品をグループ化している部分はさらに商品カテゴリエンティティとして切り出し
* 項目が埋められたら、エンティティ間のリレーションシップを設定していく
    * 主キーには意味がある項目を設定すると変更されたときに困るので、一意となる無機質な識別子（identifier）を設定する
* ここまで最低限の設計は完成だが、一歩先読みをしておく
    * 注文日時の追加（イベント系は「いつ」が必ずある）
    * 新商品だけでなく、おすすめ商品も管理したくなるかもしれないので、商品区分エンティティとして切り出す
* テーブルが追加されたり、項目が追加されても、基本的なリレーションシップに変更が加えられていないので、テーブルの構造が安定している証拠
    * これを実現しているのが識別子の導入

## 第2回　図書館の予約申込書編

* まずイベントを見出す
    * 予約エンティティ
    * イベント系の見出し方として、〜日という言い方ができるかどうかで判断することもできる
* 次にリソースを抜き出す
    * 「誰が」は名前
        * 予約者エンティティ
    * 「何を」は署名
        * 書籍エンティティ
    * 先入観は誤解のもとになるので捨てる
    * リソース系の場合は、〜名という言い方ができるかどうかという判断基準が使える
* 項目を入れていく
    * 連絡方法は意外と難しい
    * この本を何で知りましたかも、結構引っ掛け問題
    * ご家族に署名をお伝えしてよろしいですか、は毎回の予約事に尋ねるものだと思われるので予約テーブルに持たせたほうが素直
    * どこで受け取るか、という受取方法も、予約の一環なので予約テーブルに持たせる
* 連絡方法について
    * 同じ人であれば毎回同じ連絡方法かどうか
    * 予約のたびに変わるのであれば、予約の付帯情報になるが、毎回同じでいいのであれば予約者の付帯情報
    * 不要という選択肢があるということは、連絡がなくてもいいユースケース、つまり予約だけでなくリクエストもあるということ
    * 連絡が不要なら、連絡先の名前や貸出券番号も不要なはず
    * 連絡不要区分を持たせておく。連絡先を `null` で表現することも可能だが、わかりやすさから項目としておく
* この本を何で知りましたか
    * これは予約とは別の、「知った」という1つの行為、つまりイベント
    * 「誰が」知ったのかは本によって異なるため、「書籍」エンティティだけでなく「予約者」エンティティにも紐づく
    * 何によって知ったのかという手段なので、情報源などとしたほうがわかりやすいが、「予約者」が「書籍」を「情報源」と並べると、日本語として違和感がある
    * 「予約者」が「書籍」を「知った」の方がスマートなので、「知った」エンティティとしておく
* リレーションシップを設定する
    * identifier の追加
* 考えすぎないようにしてみる
    * 例えば連絡先
    * 予約者に付帯する情報だが、毎回入力してもらう形でいいのなら、予約エンティティに項目を持たせてしまっても良い
    * 「知った」エンティティは、誰が知ったのかを記録する必要がないのなら、リレーションシップを排除できる
    * 出版社もメモ程度の扱いなら、テーブルをもたせる必要もない
    * ついついヘビーウェイトな設計にしてしまいがちだが、データモデルが複雑になるということは、それを扱う業務も複雑になってしまう
    * ほどほど感を忘れない
* 考えるポイントが多い理由は、1つの帳票で2つの業務（予約とリクエスト）を兼用していることと、メモ書きとはいえ「何で知ったか」も含めると3つのイベントが混在しているため
* イベントはなにか？に目を向けられるようになると、業務の流れに気を配る余裕ができる

## 第3回　ハンバーガーショップのレシート編

* イベントを見出す
    * 注文エンティティの他に、入金（預かり）というイベントを見いだせる
    * 注文に着目すると、個別の商品の明細と、合計額の見出し部分を見いだせる
    * ヘッダ／ディテール形式、マスタ／ディテール形式なので、1回の注文を表す部分と、内訳を表す部分とを2つのテーブルで表現する
    * この関係はリレーションが既に発生しているので、テーブルとして切り出した際にIDを設定する
* リソースを抜き出す
    * 「誰が」については、目の前でやりとりをするので考える必要がない
    * 「何を」注文したのカニ注目
    * 商品エンティティが見いだせる
* セット商品をどうするか
    * セットを構成する個別の商品と、セット商品とは内訳とまとめの関係
    * 見出し明細形式になるように思われる
    * 実際は必ずセットで扱われるわけではない
    * また、セット商品そのものはあくまでも単品の組合せであり、それ自身では存在しない
    * 複数の商品の組合せに対して「単品としての」名前を付与しているだけ
    * まとめ内訳形式ではあるものの、内訳がまとめと同じレベルに存在するという、特殊な構造
    * これを扱うのに、「事故参照」「再帰」などと呼ばれる形にする
    * 表現方法としては2つある
        * テーブル1つだけで表現する方法
            * このケースの場合は単品商品が必ず1つのセット商品「だけ」にしか属せない
            * 実際は、例えばポテトは色々なセットに組み込まれる
            * 親となるセット商品を一意に特定できない
        * 2つのテーブルを使う方法
   * 「POS#」というレジを表す項目があるが、これはどのレジで注文を受けたのかを記録するものなので、選択肢としてテーブルを外出ししておく
   * 「E/I」という文字があるが、これはイートインの略なので、パッケージという名前で商品の体裁を表現する選択肢として登録するテーブルを1つ用意しておく
* 項目を入れていく
    * 注文テーブルを埋める
        * 合計は、他のレシートを見ても単なる合計しかない＋見出し明細形式なので導出項目として省略してもよいが、わかりやすさのために項目としておく
    * 注文明細テーブルを埋める
        * 明細それぞれの注文された個数を持つ
    * 商品テーブルを埋める
        * 価格と商品名に加えて、セット商品なのかどうかを見分けるための区分を項目としておく
   * セット構成テーブルは、組合せを管理するだけ
       * セット商品ID(FK)と構成商品ID(FK)のみ
  * レジ、パッケージの両テーブルについては、それぞれの要素を示す名称を項目として追加
* お預かりをどう考えるか
    * 考え方としては2つある
        * 「注文とは別のイベントである」としてテーブルを1つ用意する
        * あくまでも注文と対になるものであると考えて、「注文」テーブルの項目にする
   * 難しいところだが、個人的には別のイベントとして分けておくほうがわかりやすい？
       * 注文を受け付けるのと代金をいただくのは、別の仕事だと考えるから

## 第4回　病院の受付伝票編

* イベントを見出す
    * 受付エンティティ
    * 複数の診察をまとめて受け付けてくれるようなので、ヘッダ・ディテール形式
    * 受付明細エンティティ
* リソースを見出す
    * 「誰が」診察を受けるのか、それは患者なので、患者エンティティ
    * 「何を」にあたるのは、商品だったり書籍だったりするが、今回の例では何について診察してもらうか
        * 診察とは病院側が提供するサービスであると考えると、商品と同じ位置づけになるのも納得
        * 診察する対象は、つまり「何科」ということなので、受診科。外科や内科、皮膚科のことなので、受診科エンティティ
        * 「どこに」という捉え方の方が自然かもしれない。どこに、もリソース系
    * 受診科にはそれぞれ提供するサービスにも種類があるはず
        * 受信内容エンティティ
    * 医師という欄があるが、これは販売管理などでいう担当者に該当する
        * 医師エンティティ
* 項目を入れていく
    * 患者
        * 氏名
        * ID
        * 生年月日
    * 受付
        * 受付日時
        * 端末番号
        * 会計番号
   * 受付明細
        * 時刻
* リレーションシップを設定する
* 少し疑ってみる
    * 組み合わせに対する制約の管理
        * 医師はどの受診科についても担当できるわけではない
        * 専門があるはず、また兼任もできるかもしれない
* 入力支援のために必要とされるのが組み合わせに対する制約
* 例えば、以下の様なテーブルを切り出すとそれが可能になる
    * 受診科別可能受診内容
        * 受診科別可能受診内容ID
        * 受診科ID（FK）
        * 受信内容ID（FK）
    * 受診科別担当医師
        * 受診科別担当医師ID
        * 受診科ID（FK）
        * 医師ID（FK）
* 受付のように、商品のような実際のものが存在しないものを扱う場合は少し躊躇しがち
* ただ、こういったケースはリソースに該当するのは何か、ということを意識すると、いわゆるサービス業でも応用が利くようになる

## 第5回　病院の領収書編

* イベントを見出す
    * 領収書となっているが、よく見ると「請求明細書兼領収書」
    * 請求することが主体
    * 請求と領収書発行を分ける必要性がないので一緒になっている
    * 印刷イコール領収済みであると捉えてしまい、領収については考えない
    * 請求エンティティ
    * 請求内容が明細になっているのでヘッダ・ディテール形式
* リソースを抜き出す
    * 「誰に」請求するのかを考えると、患者なので患者エンティティ
    * 「何を」にあたるのは、病院側の提供するサービス、つまり請求内容エンティティ
    * 請求内容は複数のグループに分けて束ねられているので、グループを表現するための請求内容区分エンティティも用意
* 項目を入れていく
    * 患者
        * 患者ID
        * 患者番号
        * 氏名
        * 保険区分
        * 保険負担
    * 請求
        * 請求ID
        * 外来入院区分
        * 発行日（請求日）
        * 会計番号
        * 診察科
        * 請求期間開始日（請求対象期間）
        * 請求期間終了日
        * 診療費合計
        * 非課税対象合計
        * 課税対象合計
        * 内税
        * 請求合計金額
        * 端末番号
        * 備考
    * 請求明細
        * 請求明細ID
        * 請求ID（FK）
        * 点数（点）
        * 保険（円）
        * 自費（円）
* 少し疑ってみる
    * 患者テーブルに保険区分があるが、これは他にも選択肢として選ばれるものだと思われるので、別のテーブルにする
    * 請求テーブルにある診察科も、複数の科から選ばれることになるだろうから、別テーブルに切り出す
    * 外来入院区分も複数の中から選ばれるものなので、別テーブルに切り出す
    * 端末番号も同じ
    * 請求テーブルに入れてある各種の合計についても、明細を集計すれば合計が求められるはずなので、除外する
* 元になる紙がややこしそうに見えても、じっくり見るとさほど複雑ではない
* 項目が減ると迷いがちだが、そのような時こそ、考え方を型にはめてまず当たりをつけることを心がける

### 第4回、第5回の ERD を統合する

* 2つの異なる業務を統合することで、業務プロセスが見えてくる
    * 同じテーブル名のものは1つにする
    * 同じ語彙を指すものは統一する
    * 結果としてリソース系のテーブルが統合されて、イベント系は残る
    * これがいわゆる ERD によって業務プロセスが見えてくるとされるもの
    * 会計番号が2つの業務で出現するので、一連の業務の流れが追跡されていると考えられる
    * ただし、これがどういうルールで振り出されているのかまでは紙からは読み取れないので、業務プロセスの担当者にヒアリングが必要なレベルになる
* 既存の資料から ERD を書くだけでも、ずいぶんと具体的な質問項目を考えることができる
* 現状分析を効率良く薦める上でも、既存の資料から ERD を書くことが、非常に役に立つ
* ERD を手早く作ることができれば、手間隙をかけなくても現状分析は可能
* 視野も広がる

## 第6回　ガスの請求書編

* イベントを見出す
    * 領収書の部分は消されているし、検針結果のお知らせなので検針エンティティ
    * お知らせ日はないので、検針が妥当と言える
* リソースを抜き出す
    * 「誰に」はお客様なのでお客さまエンティティ
    * 「誰が検針したのか」は業務代行者エンティティ
* 項目を入れていく
* お客さまエンティティ
    * お客さまID
    * お客さま番号
    * 名前
* 検針エンティティ
    * 導出項目を排除する際は、まず全部の項目を出しきってしまい、後でゆっくりと排除対象を考えたほうが迷いが少なくて安全
        * ご使用期間が印字され、開始と終了があり、終了日が今回検針日
        * 今回検針日の年月が「x年y月分」となる
        * 「x年y月分」の期間は、前回検針日の翌日から今回検針日まで
    * そこでまず検針日だけを項目に持たせる
        * 今回指示数と前回指示数という項目があり、前回指示数は前回の検針結果があれば導き出せるので、今回分のみ記録すればよい
    * 指示数という項目を持たせる
    * 当月分ご使用量も、今回指示数から前回指示数をマイナスすれば求められるので、項目としては除外
    * ご使用日数という項目があるが、これは前回検針日の翌日から今回検針日までの期間を数えればOKなので項目として持たせるのはやめておく
    * 請求予定金額は、「ガス基本料金」と「ガス従量料金」の合計なので、項目としては除外する
    * 次回検針予定は、自動的に1か月後になっているが、実際にはその日に必ず検針できるとは限らないので、今回検針日から導き出すものとして、項目としては持たせない
    * 適用単位料金は、A表やB表の内の1つが選ばれ、それと対になる料金が決まるようになっているため、もう1つテーブルを追加して、後でリレーションシップによってどの表の料金なのかを紐付けるようにして、項目としては持たせないようにする
    * 「ガス基本料金」と「ガス従量料金」も、「今回のガス使用量」から料金表が決定すると、導出することができる
* リレーションシップを設定する
* 導出項目をビューで表現する
    * 上記の設計のままだと、導出項目を毎回プログラムで処理することになるが、それは面倒
    * ビューを作成する
    * 1つの検針テーブルを2回使うことで、今回分と前回分があたかも別テーブルで存在しているかのように扱う
    * 今回検診結果というビュー名にする
* データベース設計だけでなくSQLを使うスキルがあれば、導出項目を実態として持たせなくても済むことに意識を向けられる
* メリットとしては、データの値が重複することを回避できるので整合性を取るために一箇所の値を修正するだけで大丈夫になること
* 実際に持つ項目が最小限であるということは、登録するプログラム側の入力画面がコンパクトになるということでもある
* 導出ルールが変わってもプログラムを大規模に修正する必要が減る
* ただし、やりすぎると性能の劣化を招く
* レコードを大量に投入してテストしてみる。推測するのではなく計測すること

## 第7回　電気料金の請求書編

* イベントを見出す
    * 請求の他に、検針、そして契約もイベント系エンティティと考えられるので、3つのエンティティを作成する
    * 請求に関しては、請求金額に対しての明細も存在するので、請求内訳エンティティも配置する
* リソースを抜き出す
    * まず契約について考えてみる
        * 「誰と」契約するのかは、お客さまなのでお客さまエンティティ
        * 「何を」契約しているのかを考えると、ご契約種別が目につき、ご契約というものもある
        * それぞれ「契約種別」「契約電力」と呼べるので、その名前でエンティティを用意する
    * 次に検針について考えてみる
        * 検針員も記載されているので、それらで織り込む
    * 最後に請求イベントに関するリソースを考える
        * これはいわゆる商品と同じ位置づけだと考えられる
        * 請求項目エンティティを置く
* 項目を入れていく
    * お客さまテーブル
        * お客さまID
        * お客さま番号
        * 名前
        * 地区番号
    * 契約テーブル
    * ご使用場所は、契約ごとに場所が違うと考えられるので契約の項目として扱う
        * 契約ID
        * ご使用場所
        * 計器番号
    * 検針テーブル
    * 差引や前月指示数、ご使用期間は導出項目として考えられる
    * 検針日と指示数は項目に持たせる
        * 検針ID
        * 検針日
        * 指示数
    * 請求テーブル
    * 請求金額は請求内訳の合計から導出できるので除外
    * お支払期限日は一回の請求に対して設定されるので「請求」テーブルに項目として持たせる
        * 請求ID
        * 支払期限日
    * 「請求内訳」テーブルについては料金を項目として持たせる
        * 請求内訳ID
        * 請求ID（FK）
        * 料金
* リレーションシップを設定する
* 余談
    * 契約テーブルはこのままじゃダメ
        * Webサイトに様々な情報が記載されている
        * 契約期間は、1年間で自動継続だが、契約変更月は日割り計算
        * という制約があるため、本来は「契約開始日」と「契約終了日」が必要
    * 契約種別テーブルとのリレーションシップ
        * 原則、1つの建物に対して1つの契約を結ぶが、1つの建物で複数のメニューをご契約いただけます、という文言があるので、例外ルールがあるはず
        * これに対応するには、「契約」テーブルと「契約種別」テーブルの間に m:m 関係を表現するための関連テーブルが必要
    * 前回は導出項目をビューで表現したが、導出ルールが変更されたり、段階が増えたりすれば対応が必要になる
    * こういった業務ルールは1つのプロセスなので、プロセスは無理やりデータモデルで表現するのではなく、素直にアルゴリズムで表現する方が自然だし、応用も利きやすい
    * データベースだけでシステムの全てを表現できるとは考えないこと

## 第8回　プロジェクトマネジメントプロセスの説明図編

* イベントを見出す
    * イベントがないように見える
    * しかし、この図で表現したいのは、〜ポイントと〜可能になることの間にある線
    * つまり、この2つの組合せが一番表現したいことなので、イベントとなる
    * 組合せエンティティを配置
* リソースを抜き出す
    * 「プロジェクトマネジメント・プロセスを標準化する際のポイント」と「プロジェクトマネジメント・プロセスを標準化することにより可能になること」の2つ
    * 長いのでそれぞれ「ポイント」と「可能になること」とする
    * さらに、「ポイント」は大分類で括られているので、複数のポイントをくくるものとして「ポイントグループ」を置く
* 項目を入れて、リレーションシップを設定する
    * それぞれのエンティティにテキストが入るだけ
* 階層構造を考えてみる
    * 多段階層になり増えていくと対応できないので、ポイントテーブルの階層を自由に設定できるようにする
    * ポイント階層テーブルを置く
        * ポイント階層ID
        * 上位ポイント（FK）
        * ポイントID（FK）
    * こうしておくと、いろいろ融通が利く
* この例は、俗にいう「マスタ管理」の典型例
* 複数のリソース系の多対多の関係や階層構造を管理する場合は必須の表現

# 付録

## SQL のカラクリ

* SQL はバッチ処理である
* SELECT, WHERE, 集合関数, ORDER BY, GROUP BY, JOIN, UPDATE などなど、すべてはバッチ処理
* SELECT * FROM は全件のシーケンシャルスキャン
* WHERE は IF 文のフィルタ（読み飛ばし）処理
* 集合関数は Aggregate 処理
* ORDER BY は Sort 処理
* GROUP BY は HashAggregate 処理
* JOIN はインデックスが効けば nested loop 処理、つまり入れ子のループで処理、インデックスが効かなければ Merge Join、すなわち Sort 処理の後のマッチング処理
* これらの組合せになるので COBOL のバッチ処理と同様のことが裏で行われている
* UPDATE もインデックスが効けばフィルタ処理だし、効かなければシーケンシャルスキャン
* 構造を意識してSQLを書こう
* FROM -> WHERE -> GROUP BY -> グループ対象列 -> 集合関数 -> HAVING と書く

## RDBMS のボトルネックの原因と対策

* 何度も RDBMS に接続しに行くのを避ける
    * 接続は時間がかかる処理
        * ネットワーク上の探索
        * コネクションを張る
        * ログインするユーザの検索、一致確認
        * パスワードの一致確認
        * が必要になる
    * コネクションプーリングをする
* 同じデータを何度も検索するのを避ける
    * 読み出したデータはキャッシュすることも検討する
    * 変更頻度、ユーザ数との相談
* 同じディスクに集中するのを分散する
    * ディスクは遅い
    * ディスクパーティショニングも検討
* 1台の CPU に集中するのを分散する
    * 大量ユーザだとしんどくなってくる
    * 物理的にサーバを分散すると、データの整合性を担保するのが難しくなる
    * レプリケーション機能や、クラスタリングツールなどを利用して整合性を保ったり、冗長化することで負荷や障害対策にもなる