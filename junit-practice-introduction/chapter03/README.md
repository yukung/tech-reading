# 第３章　テスティングフレームワーク

## テスティングフレームワークとは？

* 「どのようにテストを記述して、実行し、検証するか」の仕組みを提供する
* テストコードの記述に集中することができる

### xUnit フレームワーク

* Kent Beck により開発された Smalltalk の SUnit を源流としたユニットテストのフレームワーク
* Kent Beck と Erich Gamma により Java に移植されたのが JUnit
* さまざまな言語に移植されている

## JUnit によるユニットテストの記法

* `public` メソッド
* `org.junit.Test` アノテーションを付与
* 戻り値を `void` とし、引数は持たない

### テストメソッドの `throws` 句

* 制約はないが、一般に `throws` 句に `Exception` クラスを指定する
* JUnit ではテストメソッドが例外を送出した時にテスト失敗として扱うためであり、`throws` 句に送出される可能性のある例外を詳細に列挙したかどうかはテストの挙動に影響を与えない
* 一般的な Java コーディング標準では、メソッドの `throws` 句に `Throwable` や `Exception` などの基底となる例外クラスを指定することを禁止している
	* 例外処理を適切に行うための重要なルールであり、レビューや静的コード解析ツールなどでチェックされる項目となっている
* テストコードを修正する場合にも、そのたびに `throws` 句を修正するのはコストメリットに合わない

### テストメソッドを簡単に挿入する

* IDE のコンテンツアシストを使う

## 可読性の高いテストコードの書き方

* テストコードは、プロダクションコードに比べて一定のパターンで同じようなコードが多くなる傾向がある
* 前提条件が少しだけ異なるなど
* ソースコード上の重複はなるべく減らすように整理すべきだが、テストコードは個々の独立したテストケースに対して可読性が高いことが求められる
* そのテストで何を前提として、何を行い、何を期待しているのかを理解しやすいテストコードが求められる

### テストケース

* テストを行う前提条件
* テストに用いる入力値や操作
* テストを行った時に期待する値や動作

#### 不完全なテストケース

* 不完全なテストケースとして典型的なものは、確認項目に「正しく表示されること」などと書かれたテストケース
	* 呼んだ人によって解釈が変わってしまうと、テストケースとして成立しない
* システムテストや受け入れテストなどを手動で行う場合に発生しやすい状況になる
* 可能な限り誰もが判断できる基準でテストケースを書くようにすべき
* ただし、完璧なテストも完璧なソフトウェアも作ることができない事を忘れない
	* パフォーマンステストで5秒以内と基準を設けたとしても、やむを得ずパスできないのであれば、パフォーマンス改善の前に基準を見直すことも検討すること

### テスト対象

* テスト対象となるクラスやオブジェクトは、**SUT**（System Under Test）と呼ばれる
* そのテストの対象が何であるかについて明確にすること
* １つのテストケースでは１つの SUT を対象としなければならない
	* 複数の SUT を１つのテストケースで扱うと、何のテストなのかが不明瞭になる

#### JUnit では

通常、慣習としては以下のように作成する。

* クラスごとに対応するテストクラスを作る
* テストクラスはテスト対象と同じパッケージとする
* クラス名を「テスト対象のクラス名＋Test」とする
* テストコード内で、テスト対象クラスのインスタンスを生成し、テスト対象オブジェクト（SUT）とする
* インスタンスを `sut` という名前の変数で扱うことで、テスト対象オブジェクトがどれであるかが理解しやすいテストコードとなる

### 実測値と期待値

* メソッドが返す値やオブジェクトの変化する状態などは**実測値**（actual value）と呼ぶ
* 仕様として返すべき値や変化する状態である値を**期待値**（expected value）と呼ぶ
	* 期待値は原則として仕様から一意に決まるものであり、仕様変更がなければ不変な値
* 可読性を高めるために、実測値に `actual`、期待値に `expected` という名前の変数とする
	* `assertThat(actual, is(expected));`
* 1つのメソッドで複数の実測値や期待値が必要となった場合は、テストメソッドを増やして、1つのテストメソッドでは1つのことを検証すること
	* テスト対象が大きすぎる可能性がある

### メソッドと副作用

テストが行いやすいメソッドは、以下の様な性質を持つ。

* メソッドが戻り値を持つ
* メソッドの呼び出しの結果、副作用がない
* 同じ状態、同じパラメータで実行すれば、必ず同じ結果を返す

```java
// 副作用のないメソッド
public static boolean isEmptyOrNull(String value) {
    return value == null || value.isEmpty();
}
```

`ArrayList` の `add` メソッドは副作用がある典型的な例で、こういったメソッドをテストするには、`size` メソッドや `get` メソッドを使い、オブジェクトの状態を間接的に確認するしかない。

```java
// 副作用のあるメソッドの検証例
@Test
public void addで要素を追加するとサイズが1となりgetで取得できる() throws Exception {
    ArrayList<String> sut = new ArrayList<>();
    sut.add("Hello");
    assertThat(sut.size(), is(1));
    assertThat(sut.get(0), is("Hello"));
}
```

また、テスト対象オブジェクトが乱数や現在時刻などで実測値が変化する場合は、さらにテストが難しくなるため、モックオブジェクトなどを使うことでテスト可能にする。

### 4フェーズテスト

ユニットテストに限らず、ソフトウェアのテストは次の4つのフェーズで実行される。

* 事前準備
    * テスト対象オブジェクトの初期化、必要な入力値、期待される結果などの準備を行う
* 実行
    * テスト対象オブジェクトに対し、テストする操作を1つだけ行う
* 検証
    * テストの結果として得られた実測値が期待値と等価であるかを比較検証する
* 後処理
    * 次のテストの実行に影響がないように後始末をする

この4フェーズを意識して書かれたテストコードは、テストを読む人にとって非常に読みやすく理解しやすいコードになる。

### テストフィクスチャ

* **テストフィクスチャ**（test fixtures）とは、テストの実行時に必要とされる全てのデータや状態のこと
* 主にテストを行うための入力値とテストの期待値で構成される
* 単純な整数や生成が容易なオブジェクトであれば、テストコードの中にフィクスチャの初期化コードを含めるが、データベースの初期化や生成が複雑なデータの場合は工夫が必要
* テストフィクスチャのセットアップのためのコードが長くなると、本来やりたかったことが不明瞭になってしまう
* テストコードは対象となるクラスやメソッドのサンプルコードとしての側面もあるため、読み手に重要なのはテストの実行と検証
* テストフィクスチャの構築は、コンパクトにまとめたほうが読みやすくなる
    * 外部定義ファイルに記述する
    * フィクスチャの初期化メソッドを外部クラスに定義してテストケースから呼び出す

## 比較検証を行うアサーション

テスト対象の実行結果が期待される結果・状態となっていうるかを比較検証する仕組みを**アサーション**と呼ぶ。
JUnit では、アサーションを JUnit が提供する API を使って記述していく。

主に `org.junit.Assert` クラスの `assertThat` メソッドと Matcher API を利用してアサーションを記述する。

### JUnit のアサーション

`assertThat` メソッドは以下を指定する。

* 1つ目の引数は実測値
* 2つ目の引数は期待値を含む `Matcher` オブジェクト

`is` メソッドは、`Matcher` オブジェクトを生成するファクトリメソッド。`org.hamcrest.CoreMatchers` クラスに提議されている。

テストコードを自然言語（英語）に近い構文とするために、`static` インポートを使ってアサーションを記述する。

## JUnit が提供するアノテーション

### `@Test` テストメソッドを宣言する

* expected
    * 例外の送出を検証する
* timeout
    * 設定したミリ秒以上の時間がかかった場合、テストが失敗するようになる
    * 指定しない場合は無限ループやデッドロックが発生した場合に実行が永遠に停止しない
    * パフォーマンステストには使わない
    * `Timeout` ルールを使うと、テストクラスに定義されたテスト全てにタイムアウトを設定することもできる

### `@Ignore` テストの実行から除外する

* 一時的にテストの実行をスキップしたい場合に使用する
* クラスに付与すると、テストクラス内の全てのテストメソッドがスキップされる

### `@Before` テストの実行前に処理を行う

* 重複した初期化処理を定義する初期化処理メソッドに付与する
* 初期化処理メソッドは、戻り値が `void` で引数を持たない `public` メソッドである必要がある
* メソッド名は慣習的に `setUp` とする
* `setUp` メソッド内で例外が発生した場合はテストが失敗する
* 複数のテストクラスに共通する初期化処理は、テストクラスの super メソッドに記述する（継承を使う）のではなく、JUnit 4.7 で導入された「ルール」を使う
    * ルールはテストクラスでの共通処理を独立したクラスに定義できる機能

### `@After` テストの実行後に処理を行う

* `@Before` と同様に、戻り値が `void` で引数を持たない `public` メソッドである必要がある
* メソッド名は慣習的に `tearDown` とする
* テストの成功／失敗にかかわらず必ず実行される
* リソースの解放など、「必ず行わなければならない後処理」に使う

### `@BeforeClass` テストの実行前に一度だけ処理を行う

* `@Before` と同様に共通の初期化処理を行うためのアノテーション
* `@Before` と違いテストクラスがクラスローダに読み込まれた後、そのテストクラスに含まれるいずれか最初のテストが開始される前に1回だけ実行される
* 戻り値が `void` で引数を持たない `static` な `public` メソッドである必要がある
* ユニットテストにおいて、テストメソッドは基本的に独立しているべきなので、あまり使うシーンは多くないはず
* ライブラリの制約でテストクラス単位で行わければならない状況や、データの初期化のコストが大きくテストメソッドごとに実行できないような状況のみに利用する

### `@AfterClass` テストの実行後に一度だけ処理を行う

* `@BeforeClass` と同様、やむを得ずテストクラス単位でリソースなどを管理しなければならない場合以外は利用しないほうが良い

## JUnit のテストパターン

ユニットテストは、比較的パターン化しやすい技術。以下に3つの基本パターンを示す。

* 標準的な振る舞いを検証するテスト
* 例外の送出を検証するテスト
* コンストラクタを検証するテスト

### 標準的な振る舞いを検証するテスト

* 4フェーズテストを行う
* 後処理は、基本的にはテストごとにテストクラスのインスタンスが破棄されるため、ガベージコレクションに任せるべき

### 例外の送出を検証するテスト

* `@Test` アノテーションの `expected` 属性に送出される例外の型を指定する
* 例外の型以外はチェックできないため、例外に含まれるメッセージの検証や、想定しない箇所で同じ型の例外については検証できない
* より詳細に例外を検証したい場合は、ルールのひとつである `org.junit.rules.ExpectedException` クラスを使うことで実現できる

### コンストラクタを検証するテスト

* ほとんどのテストではテスト対象となるのはメソッド
* 特殊なパターンとしてコンストラクタのテストがある
* インスタンスが生成された時に、初期状態として妥当な値が設定されているかを検証する
* インスタンスの生成が実行フェーズとなり、インスタンスはテスト対象オブジェクト（SUT）でもあり、実測値でもある
* 変数名を `instance` とすると理解しやすい

```java
@Test
public void インスタンス化テスト() {
    // Exercise
    Person instance = new Person("Duke");
    // Verify
    assertThat(instance.getName(), is("Duke");
    assertThat(instance.getAge(), is(-1));
    assertThat(instance.getEmail(), is(nullValue()));
}
```