# 第２章　ユニットテスト

## ソフトウェアテストとは？

* ある条件下において、ソフトウェアの振る舞いを記録し、その記録が期待される結果となることを検証するプロセス
* １つのテスト項目をテストケースと呼び、いくつかのテストケースをまとめたものをテストスイートと呼ぶ。
* 製造業や建築業で行われているような、設計段階で徹底的に検証して品質を高める手法は、ソフトウェア開発ではあまり効果的ではない
* 実際に作ってみないとわからないことが多い
* 一度作ったプログラムを破棄して作りなおすことが製造業や建築業に比べて容易
* ソフトウェアへの要求の変化が大きく早い

### ソフトウェアテストの目的

* 品質保証とは別の目的のテストも存在する
	* 機能テスト
		* ソフトウェアの完成度、進捗度を計る目的
	* 設計の妥当性を検証するテスト
* 何を目的としたテストかを意識することが重要

### ソフトウェアテストの限界

* 完璧なテストを行うことはできない
* 効果的な入力値を選択して、「十分に良い」テストを行うしかない
* どの程度で「十分に良い」テストなのかは、ユーザの要求や予算に依存する問題

## テスト技法

### ホワイトボックステストとブラックボックステスト

* ユニットテストは、どちらかと言えばホワイトボックステストに分類される
* しかし、内部ロジックに依存しすぎたユニットテストは変更に対して脆くなる
* 外部仕様からテストデータを選択した方がよいという側面もある
* ホワイトボックステストとブラックボックステストを組合せて行うのが良い

### 同値クラスに対するテスト

* 外部仕様、特に出力結果について着目してテストデータを選択する
* ソフトウェアが同様の結果をもたらす値を同値クラスとしてグループ化し、各同値クラスからテストデータを選択することで、膨大な量の組合せを全てテストするのではなく、同値クラスにおいて正常に動作するものとみなし、コストを抑える

### 境界値に対するテスト

* ソフトウェアが異なる結果をもたらす値（境界値）に着目して境界値の近傍からテストデータを選択する
* 「プログラムが使用上の境界値付近で不具合を生みやすい」という経験則から得られた性質を利用するテスト技法
* 最小限のテストデータで不具合を検知しやすくする
* 境界値に対するテストは一般的にはブラックボックステストに分類されるが、テスト対象のプログラムとテストコードを同時に実装する場合は、ホワイトボックステスト的に扱われる

## ユニットテストとは

クラスやメソッドを対象としたプログラムを検証するためのテストで、ソフトウェアテストの中では最も小さい粒度のテスト。ユニットテストでは、対象のクラスやメソッドが期待された振る舞いをするかを検証する。「期待された振る舞い」とは、言い換えれば対象のクラスやメソッドの仕様。
テストケースが自然言語（日本語）で記述されることで、解釈による誤解が生じる余地が残るが、テストケースをプログラムとして表現することで、曖昧さを排除することができる。

### ユニットテストの特徴

* 自然言語によるテストケース表現では、句読点やニュアンスにより曖昧さが排除できずテストの実行者の解釈によるズレが生じる可能性がある
* テストを実行するには手動でプログラムを実行し、手動で結果を確認しなければならないため、大きなコストとなる
* プログラムと記述することで、曖昧さが含まれることなく明確に記述することができ、プログラマが手動でテストを実行するのと違い、コンパイラや実行環境が間違って実行することもない
* テストコードは、テスト対象のクラスやメソッドの実行できるサンプルコードとなり、仕様書ともなる
* プログラマ自身が作成したクラスやメソッドの最初のユーザーになることで、使いにくさや設計の誤りに気づくことができる
* テストコードを作成するコストはかかるが、実行に関するコストは掛からないため、何度も繰り返し実行することや頻繁に実行することができる
* 手動の場合は実行に大きなコストがかかるため、簡単には何度も繰り返し実施できない

### ユニットテストの目的

* ユニットテストはテスト対象のクラスの仕様を明確にしなければ書くことはできない
* ユニットテストを何度も繰り返し実行することで、早い段階で問題を特定できる
* 仕様の明確化とすばやいフィードバックのおかげで、プログラマはリグレッションを恐れず新しい機能や試みを行うことができる
* これまで「動作するコードは決して触ってはいけない」とされ、リスク回避のために避けてきた機能拡張やコードのリファクタリングを安心して行うことができる
* プログラマが自信を持ってコードを書くために、自分自身のために書くテストであるためディベロッパーテストとも呼ばれる
* ユニットテストをより強力に活用する開発手法として「テスト駆動開発」がある
* ユニットテストを実施しているソフトウェアの品質は結果的に高くなり、不具合は減る。また変更に強くなる

### ユニットテストのフレームワーク

* JUnit や TestNG などがある
* 決定的な機能の違いはなく、好みの問題
* フレームワークを利用せずにユニットテストを行うこともできるが、テストの実行、検証、テスト結果のレポートなどの機能をわざわざ実装しなくてもよいので、テストケースの設計と実装に専念できるため、使ったほうが良い

## ユニットテストのパターン

xUnit Test Patterns から抜粋

### 自働化されたテスト―繰り返しいつでも実行できること

* ユニットテストに限らず、ソフトウェアテストは可能な限り自動化するべき
* ユニットテストが完全に自動化されることで、何度でも繰り返してテストを実行することが容易となり、不具合などを早い段階でフィードバックでき、安心してリファクタリングを行うことができる
* GUIのテストなど自働化が難しいテストについては、テストの自働化に対するコストとのトレードオフとなる

### 不安定なテスト―結果が一定でないテストを避けること

* ユニットテストでは、常にすべてのテストが成功している状態を維持することが望ましい
* 成功しないテストを放置する状態や、実行ごとに成功するか失敗するかわからないテスト（不安定なテスト）がある状態は好ましくない
* 他のテストが失敗しても誰も気にしなくなり、気づけば多くのテストが失敗している状態となると、テストがセーフティネットとして機能しなくなり、不具合の発見が遅れてしまう
* 修正範囲が特定できなくなり手を付けられなくなってしまう

### ドキュメントとしてのテスト―仕様書として読めること

* テストケースは、テスト対象のクラスやメソッドに対し開発者が想定しているさまざまなユースケースを記述したもの
* テストが成功する限り、テストで提議されている動きは保証されている
* テストケースは最も正確なドキュメントであり、テスト対象のサンプルコード
* Martin Fowler の「リファクタリング」より、「コードの不吉な匂い」の一つ「コメントは消臭剤」とある
* プログラマが自信のないコードを書く時にコメントが増える傾向にあるため、コメントが多いコードには不具合が多い傾向がある
* ユニットテストを書くことで、インタフェースに関する感心が高くなるので、コメントがなくとも使いやすいインタフェースに導く効果もある

### 問題の局所化―テスト失敗時に問題を特定しやすいこと

* テストケースは十分に小さい単位で可能な限り多く作るべき
* テストが十分に小さいならば、何らかの原因でテストが失敗したとしても、影響範囲と条件が絞り込みやすくなる
* テストに失敗した時、その原因の分析のコストは小さくない
* テストケースはなるべく小さくする

### 不明瞭なテスト―可読性の低いテストコードは避けること

* 読みにくいテストコードは、メンテナンス性も悪く、テストの質にも大きく影響を与える
* 前提条件は、同じコードが２回現れたならば `setUp` メソッドに抽出する
* 同じテストクラスの中で２つ以上の前提条件が重複して出現したならば、コンテキストごとのテストを検討する
* テストの実行は、１つのテストケース内で１つだけ行うようにする。前提となる操作は前提条件に含める
* アサーションは、現実的には１つのテストケースでいくつか行うことになるが、まとめて検証することは避けたほうが可読性が高まる。検証に失敗した時にどのフィールドが一致しないのかをわかりやすくするため、カスタム Matcher を作成して検証する

### 独立したテスト―実行順序に依存しないこと

* テストケースは、可能な限りお互いに影響を与えないように定義すべき
* あるテストの結果やテストの実行順番がテストの結果に影響を与えるならば、テストケースの追加や削除により予期しない形でテストが失敗することになる
* シングルトンとして管理されているリソースやデータベースにアクセスするテストでは、珍しいことではない
* 原則として各テストの初期化処理で必要なデータ等を用意し、テストの終了処理でデータやリソースをテスト前の状態に戻す
* こうすると各テストが独立したものとなり、実行順序にテスト結果が依存しない
* テストが独立していれば、テストの実行時間が増えてしまった場合にも分散してテストを実行しやすくなる
* テストを行いにくい設計を避ける事も重要。ハードコーディングされた設定ファイルを読み込むリソースや、ミュータブルなオブジェクトをシングルトンとして設計するとハマりやすい
* シングルトンオブジェクトをアクセスのしやすさだけで使うのは、グローバル変数の置換えでしかない
* モックやスタブを差し込む際にも、シングルトンオブジェクトではコンストラクタを使えず static なファクトリメソッドから利用するため、差し込めない

